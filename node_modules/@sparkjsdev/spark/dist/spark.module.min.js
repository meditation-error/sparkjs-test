import * as B from "three";
import { Loader as ag, FileLoader as rg, Quaternion as ss, Vector3 as vA, Color as is, Matrix4 as fe } from "three";
var CA = Uint8Array, yt = Uint16Array, gg = Int32Array, cs = new CA([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), hs = new CA([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), og = new CA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), ls = function(t, A) {
  for (var e = new yt(31), s = 0; s < 31; ++s)
    e[s] = A += 1 << t[s - 1];
  for (var i = new gg(e[30]), s = 1; s < 30; ++s)
    for (var n = e[s]; n < e[s + 1]; ++n)
      i[n] = n - e[s] << 5 | s;
  return { b: e, r: i };
}, us = ls(cs, 2), ds = us.b, Ig = us.r;
ds[28] = 258, Ig[258] = 28;
var Qg = ls(hs, 0), Bg = Qg.b, ke = new yt(32768);
for (var iA = 0; iA < 32768; ++iA) {
  var $A = (iA & 43690) >> 1 | (iA & 21845) << 1;
  $A = ($A & 52428) >> 2 | ($A & 13107) << 2, $A = ($A & 61680) >> 4 | ($A & 3855) << 4, ke[iA] = (($A & 65280) >> 8 | ($A & 255) << 8) >> 1;
}
var Yt = function(t, A, e) {
  for (var s = t.length, i = 0, n = new yt(A); i < s; ++i)
    t[i] && ++n[t[i] - 1];
  var a = new yt(A);
  for (i = 1; i < A; ++i)
    a[i] = a[i - 1] + n[i - 1] << 1;
  var r;
  if (e) {
    r = new yt(1 << A);
    var g = 15 - A;
    for (i = 0; i < s; ++i)
      if (t[i])
        for (var I = i << 4 | t[i], Q = A - t[i], o = a[t[i] - 1]++ << Q, C = o | (1 << Q) - 1; o <= C; ++o)
          r[ke[o] >> g] = I;
  } else
    for (r = new yt(s), i = 0; i < s; ++i)
      t[i] && (r[i] = ke[a[t[i] - 1]++] >> 15 - t[i]);
  return r;
}, zt = new CA(288);
for (var iA = 0; iA < 144; ++iA)
  zt[iA] = 8;
for (var iA = 144; iA < 256; ++iA)
  zt[iA] = 9;
for (var iA = 256; iA < 280; ++iA)
  zt[iA] = 7;
for (var iA = 280; iA < 288; ++iA)
  zt[iA] = 8;
var ps = new CA(32);
for (var iA = 0; iA < 32; ++iA)
  ps[iA] = 5;
var Cg = /* @__PURE__ */ Yt(zt, 9, 1), Eg = /* @__PURE__ */ Yt(ps, 5, 1), me = function(t) {
  for (var A = t[0], e = 1; e < t.length; ++e)
    t[e] > A && (A = t[e]);
  return A;
}, bA = function(t, A, e) {
  var s = A / 8 | 0;
  return (t[s] | t[s + 1] << 8) >> (A & 7) & e;
}, xe = function(t, A) {
  var e = A / 8 | 0;
  return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) >> (A & 7);
}, ys = function(t) {
  return (t + 7) / 8 | 0;
}, ft = function(t, A, e) {
  return (A == null || A < 0) && (A = 0), (e == null || e > t.length) && (e = t.length), new CA(t.subarray(A, e));
}, cg = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], wA = function(t, A, e) {
  var s = new Error(A || cg[t]);
  if (s.code = t, Error.captureStackTrace && Error.captureStackTrace(s, wA), !e)
    throw s;
  return s;
}, ws = function(t, A, e, s) {
  var i = t.length, n = s ? s.length : 0;
  if (!i || A.f && !A.l)
    return e || new CA(0);
  var a = !e, r = a || A.i != 2, g = A.i;
  a && (e = new CA(i * 3));
  var I = function(yA) {
    var xA = e.length;
    if (yA > xA) {
      var cA = new CA(Math.max(xA * 2, yA));
      cA.set(e), e = cA;
    }
  }, Q = A.f || 0, o = A.p || 0, C = A.b || 0, E = A.l, l = A.d, c = A.m, h = A.n, u = i * 8;
  do {
    if (!E) {
      Q = bA(t, o, 1);
      var p = bA(t, o + 1, 3);
      if (o += 3, p)
        if (p == 1)
          E = Cg, l = Eg, c = 9, h = 5;
        else if (p == 2) {
          var S = bA(t, o, 31) + 257, m = bA(t, o + 10, 15) + 4, f = S + bA(t, o + 5, 31) + 1;
          o += 14;
          for (var w = new CA(f), R = new CA(19), M = 0; M < m; ++M)
            R[og[M]] = bA(t, o + M * 3, 7);
          o += m * 3;
          for (var x = me(R), L = (1 << x) - 1, N = Yt(R, x, 1), M = 0; M < f; ) {
            var k = N[bA(t, o, L)];
            o += k & 15;
            var d = k >> 4;
            if (d < 16)
              w[M++] = d;
            else {
              var U = 0, v = 0;
              for (d == 16 ? (v = 3 + bA(t, o, 3), o += 2, U = w[M - 1]) : d == 17 ? (v = 3 + bA(t, o, 7), o += 3) : d == 18 && (v = 11 + bA(t, o, 127), o += 7); v--; )
                w[M++] = U;
            }
          }
          var AA = w.subarray(0, S), z = w.subarray(S);
          c = me(AA), h = me(z), E = Yt(AA, c, 1), l = Yt(z, h, 1);
        } else
          wA(1);
      else {
        var d = ys(o) + 4, y = t[d - 4] | t[d - 3] << 8, D = d + y;
        if (D > i) {
          g && wA(0);
          break;
        }
        r && I(C + y), e.set(t.subarray(d, D), C), A.b = C += y, A.p = o = D * 8, A.f = Q;
        continue;
      }
      if (o > u) {
        g && wA(0);
        break;
      }
    }
    r && I(C + 131072);
    for (var sA = (1 << c) - 1, tA = (1 << h) - 1, P = o; ; P = o) {
      var U = E[xe(t, o) & sA], J = U >> 4;
      if (o += U & 15, o > u) {
        g && wA(0);
        break;
      }
      if (U || wA(2), J < 256)
        e[C++] = J;
      else if (J == 256) {
        P = o, E = null;
        break;
      } else {
        var Z = J - 254;
        if (J > 264) {
          var M = J - 257, V = cs[M];
          Z = bA(t, o, (1 << V) - 1) + ds[M], o += V;
        }
        var X = l[xe(t, o) & tA], b = X >> 4;
        X || wA(3), o += X & 15;
        var z = Bg[b];
        if (b > 3) {
          var V = hs[b];
          z += xe(t, o) & (1 << V) - 1, o += V;
        }
        if (o > u) {
          g && wA(0);
          break;
        }
        r && I(C + 131072);
        var dA = C + Z;
        if (C < z) {
          var oA = n - z, pA = Math.min(z, dA);
          for (oA + C < 0 && wA(3); C < pA; ++C)
            e[C] = s[oA + C];
        }
        for (; C < dA; ++C)
          e[C] = e[C - z];
      }
    }
    A.l = E, A.p = P, A.b = C, A.f = Q, E && (Q = 1, A.m = c, A.d = l, A.n = h);
  } while (!Q);
  return C != e.length && a ? ft(e, 0, C) : e.subarray(0, C);
}, hg = /* @__PURE__ */ new CA(0), TA = function(t, A) {
  return t[A] | t[A + 1] << 8;
}, YA = function(t, A) {
  return (t[A] | t[A + 1] << 8 | t[A + 2] << 16 | t[A + 3] << 24) >>> 0;
}, Se = function(t, A) {
  return YA(t, A) + YA(t, A + 4) * 4294967296;
}, lg = function(t) {
  (t[0] != 31 || t[1] != 139 || t[2] != 8) && wA(6, "invalid gzip data");
  var A = t[3], e = 10;
  A & 4 && (e += (t[10] | t[11] << 8) + 2);
  for (var s = (A >> 3 & 1) + (A >> 4 & 1); s > 0; s -= !t[e++])
    ;
  return e + (A & 2);
}, Me = /* @__PURE__ */ function() {
  function t(A, e) {
    typeof A == "function" && (e = A, A = {}), this.ondata = e;
    var s = A && A.dictionary && A.dictionary.subarray(-32768);
    this.s = { i: 0, b: s ? s.length : 0 }, this.o = new CA(32768), this.p = new CA(0), s && this.o.set(s);
  }
  return t.prototype.e = function(A) {
    if (this.ondata || wA(5), this.d && wA(4), !this.p.length)
      this.p = A;
    else if (A.length) {
      var e = new CA(this.p.length + A.length);
      e.set(this.p), e.set(A, this.p.length), this.p = e;
    }
  }, t.prototype.c = function(A) {
    this.s.i = +(this.d = A || !1);
    var e = this.s.b, s = ws(this.p, this.s, this.o);
    this.ondata(ft(s, e, this.s.b), this.d), this.o = ft(s, this.s.b - 32768), this.s.b = this.o.length, this.p = ft(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, t.prototype.push = function(A, e) {
    this.e(A), this.c(e);
  }, t;
}();
function ug(t, A) {
  return ws(t, { i: 2 }, A && A.out, A && A.dictionary);
}
var Ds = /* @__PURE__ */ function() {
  function t(A, e) {
    this.v = 1, this.r = 0, Me.call(this, A, e);
  }
  return t.prototype.push = function(A, e) {
    if (Me.prototype.e.call(this, A), this.r += A.length, this.v) {
      var s = this.p.subarray(this.v - 1), i = s.length > 3 ? lg(s) : 4;
      if (i > s.length) {
        if (!e)
          return;
      } else this.v > 1 && this.onmember && this.onmember(this.r - s.length);
      this.p = s.subarray(i), this.v = 0;
    }
    Me.prototype.c.call(this, e), this.s.f && !this.s.l && !e && (this.v = ys(this.s.p) + 9, this.s = { i: 0 }, this.o = new CA(0), this.push(new CA(0), e));
  }, t;
}(), Ge = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), dg = 0;
try {
  Ge.decode(hg, { stream: !0 }), dg = 1;
} catch {
}
var pg = function(t) {
  for (var A = "", e = 0; ; ) {
    var s = t[e++], i = (s > 127) + (s > 223) + (s > 239);
    if (e + i > t.length)
      return { s: A, r: ft(t, e - 1) };
    i ? i == 3 ? (s = ((s & 15) << 18 | (t[e++] & 63) << 12 | (t[e++] & 63) << 6 | t[e++] & 63) - 65536, A += String.fromCharCode(55296 | s >> 10, 56320 | s & 1023)) : i & 1 ? A += String.fromCharCode((s & 31) << 6 | t[e++] & 63) : A += String.fromCharCode((s & 15) << 12 | (t[e++] & 63) << 6 | t[e++] & 63) : A += String.fromCharCode(s);
  }
};
function yg(t, A) {
  if (A) {
    for (var e = "", s = 0; s < t.length; s += 16384)
      e += String.fromCharCode.apply(null, t.subarray(s, s + 16384));
    return e;
  } else {
    if (Ge)
      return Ge.decode(t);
    var i = pg(t), n = i.s, e = i.r;
    return e.length && wA(8), n;
  }
}
var wg = function(t, A) {
  return A + 30 + TA(t, A + 26) + TA(t, A + 28);
}, Dg = function(t, A, e) {
  var s = TA(t, A + 28), i = yg(t.subarray(A + 46, A + 46 + s), !(TA(t, A + 8) & 2048)), n = A + 46 + s, a = YA(t, A + 20), r = e && a == 4294967295 ? fg(t, n) : [a, YA(t, A + 24), YA(t, A + 42)], g = r[0], I = r[1], Q = r[2];
  return [TA(t, A + 10), g, I, i, n + TA(t, A + 30) + TA(t, A + 32), Q];
}, fg = function(t, A) {
  for (; TA(t, A) != 1; A += 4 + TA(t, A + 2))
    ;
  return [Se(t, A + 12), Se(t, A + 4), Se(t, A + 20)];
};
function mg(t, A) {
  for (var e = {}, s = t.length - 22; YA(t, s) != 101010256; --s)
    (!s || t.length - s > 65558) && wA(13);
  var i = TA(t, s + 8);
  if (!i)
    return {};
  var n = YA(t, s + 16), a = n == 4294967295 || i == 65535;
  if (a) {
    var r = YA(t, s - 12);
    a = YA(t, r) == 101075792, a && (i = YA(t, r + 32), n = YA(t, r + 48));
  }
  for (var g = A && A.filter, I = 0; I < i; ++I) {
    var Q = Dg(t, n, a), o = Q[0], C = Q[1], E = Q[2], l = Q[3], c = Q[4], h = Q[5], u = wg(t, h);
    n = c, (!g || g({
      name: l,
      size: C,
      originalSize: E,
      compression: o
    })) && (o ? o == 8 ? e[l] = ug(t.subarray(u, u + C), { out: new CA(E) }) : wA(14, "unknown compression type " + o) : e[l] = ft(t, u, u + C));
  }
  return e;
}
let VA;
const fs = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && fs.decode();
let Lt = null;
function xg() {
  return (Lt === null || Lt.byteLength === 0) && (Lt = new Uint8Array(VA.memory.buffer)), Lt;
}
function Sg(t, A) {
  return t = t >>> 0, fs.decode(xg().subarray(t, t + A));
}
function Mg(t, A, e, s, i, n, a, r, g, I, Q) {
  return VA.raycast_splats(t, A, e, s, i, n, a, r, g, I, Q);
}
async function Fg(t, A) {
  if (typeof Response == "function" && t instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(t, A);
      } catch (s) {
        if (t.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", s);
        else
          throw s;
      }
    const e = await t.arrayBuffer();
    return await WebAssembly.instantiate(e, A);
  } else {
    const e = await WebAssembly.instantiate(t, A);
    return e instanceof WebAssembly.Instance ? { instance: e, module: t } : e;
  }
}
function Ng() {
  const t = {};
  return t.wbg = {}, t.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, t.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_6ca527665d89694d = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {
    return A.length;
  }, t.wbg.__wbg_new_9fee97a409b32b68 = function(A) {
    return new Uint16Array(A);
  }, t.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {
    return new Uint32Array(A);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, e, s) {
    return new Float32Array(A, e >>> 0, s >>> 0);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, e, s) {
    return new Uint32Array(A, e >>> 0, s >>> 0);
  }, t.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {
    return new Float32Array(A >>> 0);
  }, t.wbg.__wbg_set_10bad9bee0e9c58b = function(A, e, s) {
    A.set(e, s >>> 0);
  }, t.wbg.__wbg_set_d23661d19148b229 = function(A, e, s) {
    A.set(e, s >>> 0);
  }, t.wbg.__wbg_set_f4f1f0daa30696fc = function(A, e, s) {
    A.set(e, s >>> 0);
  }, t.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, e, s) {
    return A.subarray(e >>> 0, s >>> 0);
  }, t.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, e, s) {
    return A.subarray(e >>> 0, s >>> 0);
  }, t.wbg.__wbindgen_init_externref_table = function() {
    const A = VA.__wbindgen_export_0, e = A.grow(4);
    A.set(0, void 0), A.set(e + 0, void 0), A.set(e + 1, null), A.set(e + 2, !0), A.set(e + 3, !1);
  }, t.wbg.__wbindgen_memory = function() {
    return VA.memory;
  }, t.wbg.__wbindgen_throw = function(A, e) {
    throw new Error(Sg(A, e));
  }, t;
}
function kg(t, A) {
  return VA = t.exports, ms.__wbindgen_wasm_module = A, Lt = null, VA.__wbindgen_start(), VA;
}
async function ms(t) {
  if (VA !== void 0) return VA;
  typeof t < "u" && (Object.getPrototypeOf(t) === Object.prototype ? { module_or_path: t } = t : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof t > "u" && (t = new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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", import.meta.url));
  const A = Ng();
  (typeof t == "string" || typeof Request == "function" && t instanceof Request || typeof URL == "function" && t instanceof URL) && (t = fetch(t));
  const { instance: e, module: s } = await Fg(await t, A);
  return kg(e, s);
}
const HA = -12, Gg = 9, PA = (Gg - HA) / 254, Rg = -30, mt = Math.exp(Rg), Ug = 11, Lg = 11, W = 1 << Ug, it = 1 << Lg, xs = 1;
function ht(t) {
  return t === "bool" || t === "bvec2" || t === "bvec3" || t === "bvec4";
}
function lt(t) {
  return t === "int" || t === "uint" || t === "float";
}
function hA(t) {
  return t === "int" || t === "ivec2" || t === "ivec3" || t === "ivec4";
}
function lA(t) {
  return t === "uint" || t === "uvec2" || t === "uvec3" || t === "uvec4";
}
function _t(t) {
  return t === "float" || t === "vec2" || t === "vec3" || t === "vec4";
}
function Ss(t) {
  return t === "mat2" || t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4";
}
function rt(t) {
  return _t(t) || Ss(t);
}
function Nt(t) {
  return t === "vec2" || t === "ivec2" || t === "uvec2";
}
function kt(t) {
  return t === "vec3" || t === "ivec3" || t === "uvec3";
}
function Ot(t) {
  return t === "vec4" || t === "ivec4" || t === "uvec4";
}
function bg(t) {
  return Nt(t) || kt(t) || Ot(t);
}
function gt(t) {
  return t === "mat2" || t === "mat2x2";
}
function ot(t) {
  return t === "mat3" || t === "mat3x3";
}
function It(t) {
  return t === "mat4" || t === "mat4x4";
}
function Ms(t) {
  switch (t) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function Fs(t) {
  switch (t) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function vg(t) {
  if (lt(t))
    return "float";
  if (Nt(t))
    return "vec2";
  if (kt(t))
    return "vec3";
  if (Ot(t))
    return "vec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function Ns(t) {
  if (lt(t))
    return "uint";
  if (Nt(t))
    return "uvec2";
  if (kt(t))
    return "uvec3";
  if (Ot(t))
    return "uvec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function Yg(t) {
  if (lt(t))
    return "int";
  if (Nt(t))
    return "ivec2";
  if (kt(t))
    return "ivec3";
  if (Ot(t))
    return "ivec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function ks(t) {
  if (typeof t == "string")
    return t;
  if (typeof t == "object" && t.type)
    return t.type;
  throw new Error(`Invalid DynoType: ${String(t)}`);
}
function nA(t) {
  return Math.trunc(t).toString();
}
function aA(t) {
  return `${Math.max(0, Math.trunc(t)).toString()}u`;
}
function H(t) {
  return t === Number.POSITIVE_INFINITY ? "INFINITY" : t === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(t) ? t.toFixed(1) : t.toString();
}
function _(t) {
  return t instanceof nt ? t.type : t.dynoOut().type;
}
class nt {
  constructor(A) {
    this.__isDynoValue = !0, this.type = A;
  }
}
class K extends nt {
  constructor(A, e) {
    super(A.outTypes[e]), this.dyno = A, this.key = e;
  }
}
class xt extends nt {
  constructor(A, e) {
    super(A), this.literal = e;
  }
  getLiteral() {
    return this.literal;
  }
}
function ae(t, A) {
  return new xt(t, A);
}
class Gs extends xt {
  constructor(A, e) {
    super(A, ""), this.value = e;
  }
  getLiteral() {
    const { type: A, value: e } = this;
    switch (A) {
      case "bool":
        return e ? "true" : "false";
      case "uint":
        return aA(e);
      case "int":
        return nA(e);
      case "float":
        return H(e);
      case "bvec2": {
        const s = e;
        return `bvec2(${s[0]}, ${s[1]})`;
      }
      case "uvec2": {
        if (e instanceof B.Vector2)
          return `uvec2(${aA(e.x)}, ${aA(e.y)})`;
        const s = e;
        return `uvec2(${aA(s[0])}, ${aA(s[1])})`;
      }
      case "ivec2": {
        if (e instanceof B.Vector2)
          return `ivec2(${nA(e.x)}, ${nA(e.y)})`;
        const s = e;
        return `ivec2(${nA(s[0])}, ${nA(s[1])})`;
      }
      case "vec2": {
        if (e instanceof B.Vector2)
          return `vec2(${H(e.x)}, ${H(e.y)})`;
        const s = e;
        return `vec2(${H(s[0])}, ${H(s[1])})`;
      }
      case "bvec3": {
        const s = e;
        return `bvec3(${s[0]}, ${s[1]}, ${s[2]})`;
      }
      case "uvec3": {
        if (e instanceof B.Vector3)
          return `uvec3(${aA(e.x)}, ${aA(e.y)}, ${aA(e.z)})`;
        const s = e;
        return `uvec3(${aA(s[0])}, ${aA(s[1])}, ${aA(s[2])})`;
      }
      case "ivec3": {
        if (e instanceof B.Vector3)
          return `ivec3(${nA(e.x)}, ${nA(e.y)}, ${nA(e.z)})`;
        const s = e;
        return `ivec3(${nA(s[0])}, ${nA(s[1])}, ${nA(s[2])})`;
      }
      case "vec3": {
        if (e instanceof B.Vector3)
          return `vec3(${H(e.x)}, ${H(e.y)}, ${H(e.z)})`;
        const s = e;
        return `vec3(${H(s[0])}, ${H(s[1])}, ${H(s[2])})`;
      }
      case "bvec4": {
        const s = e;
        return `bvec4(${s[0]}, ${s[1]}, ${s[2]}, ${s[3]})`;
      }
      case "uvec4": {
        if (e instanceof B.Vector4)
          return `uvec4(${aA(e.x)}, ${aA(e.y)}, ${aA(e.z)}, ${aA(e.w)})`;
        const s = e;
        return `uvec4(${aA(s[0])}, ${aA(s[1])}, ${aA(s[2])}, ${aA(s[3])})`;
      }
      case "ivec4": {
        if (e instanceof B.Vector4)
          return `ivec4(${nA(e.x)}, ${nA(e.y)}, ${nA(e.z)}, ${nA(e.w)})`;
        const s = e;
        return `ivec4(${nA(s[0])}, ${nA(s[1])}, ${nA(s[2])}, ${nA(s[3])})`;
      }
      case "vec4": {
        if (e instanceof B.Vector4)
          return `vec4(${H(e.x)}, ${H(e.y)}, ${H(e.z)}, ${H(e.w)})`;
        if (e instanceof B.Quaternion)
          return `vec4(${H(e.x)}, ${H(e.y)}, ${H(e.z)}, ${H(e.w)})`;
        const s = e;
        return `vec4(${H(s[0])}, ${H(s[1])}, ${H(s[2])}, ${H(s[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const s = e, i = s instanceof B.Matrix2 ? s.elements : e, n = new Array(4).fill(0).map((a, r) => H(i[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat2x3": {
        const s = e, i = new Array(6).fill(0).map((n, a) => H(s[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat2x4": {
        const s = e, i = new Array(8).fill(0).map((n, a) => H(s[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const s = e, i = s instanceof B.Matrix3 ? s.elements : e, n = new Array(9).fill(0).map((a, r) => H(i[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat3x2": {
        const s = e, i = new Array(6).fill(0).map((n, a) => H(s[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat3x4": {
        const s = e, i = new Array(12).fill(0).map((n, a) => H(s[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const s = e, i = s instanceof B.Matrix4 ? s.elements : e, n = new Array(16).fill(0).map((a, r) => H(i[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat4x2": {
        const s = e, i = new Array(8).fill(0).map((n, a) => H(s[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat4x3": {
        const s = e, i = new Array(12).fill(0).map((n, a) => H(s[a]));
        return `${A}(${i.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(A)}`);
    }
  }
}
function q(t, A) {
  return new Gs(t, A);
}
function bt(t) {
  const A = String(t);
  if (ht(t))
    return `${A}(false)`;
  if (rt(t))
    return `${A}(0.0)`;
  if (hA(t))
    return `${A}(0)`;
  if (lA(t))
    return `${A}(0u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function Jg(t) {
  const A = String(t);
  if (ht(t))
    return `${A}(true)`;
  if (rt(t))
    return `${A}(1.0)`;
  if (hA(t))
    return `${A}(1)`;
  if (lA(t))
    return `${A}(1u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function Tg(t) {
  const A = String(t);
  if (ht(t))
    return `${A}(true)`;
  if (rt(t))
    return `${A}(-1.0)`;
  if (hA(t))
    return `${A}(-1)`;
  if (lA(t))
    return `${A}(0xFFFFFFFFu)`;
  throw new Error(`Type not implemented: ${A}`);
}
const ns = "    ";
class Rs {
  constructor({ indent: A } = {}) {
    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = ns, this.indent = A ?? ns;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class O {
  constructor({
    inTypes: A,
    outTypes: e,
    inputs: s,
    update: i,
    globals: n,
    statements: a,
    generate: r
  }) {
    this.inTypes = A ?? {}, this.outTypes = e ?? {}, this.inputs = s ?? {}, this.update = i, this.globals = n, this.statements = a, this.generate = r ?? (({ inputs: g, outputs: I, compile: Q }) => {
      var o, C;
      return {
        globals: (o = this.globals) == null ? void 0 : o.call(this, { inputs: g, outputs: I, compile: Q }),
        statements: (C = this.statements) == null ? void 0 : C.call(this, { inputs: g, outputs: I, compile: Q })
      };
    });
  }
  get outputs() {
    const A = {};
    for (const e in this.outTypes)
      A[e] = new K(this, e);
    return A;
  }
  apply(A) {
    return Object.assign(this.inputs, A), this.outputs;
  }
  compile({
    inputs: A,
    outputs: e,
    compile: s
  }) {
    const i = [
      `// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(e).join(", ")})`
    ], n = [];
    for (const I in e) {
      const Q = e[I];
      Q && !s.declares.has(Q) && (s.declares.add(Q), n.push(I));
    }
    const { globals: a, statements: r, uniforms: g } = this.generate({
      inputs: A,
      outputs: e,
      compile: s
    });
    for (const I of a ?? [])
      s.globals.add(I);
    for (const I in g)
      s.uniforms[I] = g[I];
    this.update && s.updaters.push(this.update);
    for (const I of n) {
      const Q = e[I];
      Q && (s.uniforms[Q] || i.push(`${_e(Q, this.outTypes[I])};`));
    }
    return r != null && r.length && (i.push("{"), i.push(...r.map((I) => s.indent + I)), i.push("}")), i;
  }
}
class zA extends O {
  constructor({
    inTypes: A,
    outTypes: e,
    inputs: s,
    update: i,
    globals: n,
    construct: a
  }) {
    super({
      inTypes: A,
      outTypes: e,
      inputs: s,
      update: i,
      globals: n,
      generate: (r) => this.generateBlock(r)
    }), this.construct = a;
  }
  generateBlock({
    inputs: A,
    outputs: e,
    compile: s
  }) {
    var l, c;
    const i = {}, n = {};
    for (const h in A)
      A[h] != null && (i[h] = new xt(this.inTypes[h], A[h]));
    for (const h in e)
      e[h] != null && (n[h] = new nt(this.outTypes[h]));
    const a = { roots: [] }, r = this.construct(i, n, a);
    for (const h of ((l = this.globals) == null ? void 0 : l.call(this, { inputs: A, outputs: e, compile: s })) ?? [])
      s.globals.add(h);
    const g = [], I = /* @__PURE__ */ new Map();
    function Q(h, u, p) {
      let d = I.get(h);
      if (!d) {
        d = {
          sequence: s.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        }, I.set(h, d);
        for (const y in h.inputs) {
          let D = h.inputs[y];
          for (; D; ) {
            if (D instanceof nt) {
              D instanceof K && Q(D.dyno, D.key);
              break;
            }
            D = D.dynoOut();
          }
        }
        g.push(h);
      }
      u && (p || d.newOuts.add(u), d.outNames.set(u, p ?? `${u}_${d.sequence}`));
    }
    for (const h of a.roots)
      Q(h);
    for (const h in n) {
      let u = (r == null ? void 0 : r[h]) ?? n[h];
      for (; u; ) {
        if (u instanceof nt) {
          u instanceof K && Q(u.dyno, u.key, e[h]);
          break;
        }
        u = u.dynoOut();
      }
      n[h] = u;
    }
    const o = [];
    for (const h of g) {
      const u = {}, p = {};
      for (const D in h.inputs) {
        let S = h.inputs[D];
        for (; S; ) {
          if (S instanceof nt) {
            if (S instanceof xt)
              u[D] = S.getLiteral();
            else if (S instanceof K) {
              const m = (c = I.get(S.dyno)) == null ? void 0 : c.outNames.get(S.key);
              if (!m)
                throw new Error(
                  `Source not found for ${S.dyno.constructor.name}.${S.key}`
                );
              u[D] = m;
            }
            break;
          }
          S = S.dynoOut();
        }
      }
      const d = I.get(h) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [D, S] of d.outNames.entries())
        p[D] = S;
      const y = h.compile({ inputs: u, outputs: p, compile: s });
      o.push(y);
    }
    const C = [];
    for (const h in e)
      n[h] instanceof xt && C.push(
        `${e[h]} = ${n[h].getLiteral()};`
      );
    return C.length > 0 && o.push(C), { statements: o.flatMap((h, u) => u === 0 ? h : ["", ...h]) };
  }
}
function kA(t, A, e, { update: s, globals: i } = {}) {
  return new zA({ inTypes: t, outTypes: A, construct: e, update: s, globals: i });
}
function Vt({
  inTypes: t,
  outTypes: A,
  inputs: e,
  update: s,
  globals: i,
  statements: n,
  generate: a
}) {
  return new O({
    inTypes: t,
    outTypes: A,
    inputs: e,
    update: s,
    globals: i,
    statements: n,
    generate: a
  });
}
function _e(t, A, e) {
  const s = typeof A == "string" ? A : A.type;
  if (!s)
    throw new Error(`Invalid DynoType: ${String(A)}`);
  return `${s} ${t}${e != null ? `[${e}]` : ""}`;
}
function UA(t) {
  var n;
  let A = !1;
  const e = t.split(`
`).map((a) => {
    const r = a.trimEnd();
    return A ? r : r.length > 0 ? (A = !0, r) : null;
  }).filter((a) => a != null);
  for (; e.length > 0 && e[e.length - 1].length === 0; )
    e.pop();
  if (e.length === 0)
    return [];
  const s = (n = e[0].match(/^\s*/)) == null ? void 0 : n[0];
  if (!s)
    return e;
  const i = new RegExp(`^${s}`);
  return e.map((a) => a.replace(i, ""));
}
function EA(t) {
  return UA(t).join(`
`);
}
class F extends O {
  constructor({
    a: A,
    outKey: e,
    outTypeFunc: s
  }) {
    const i = { a: _(A) }, n = s(_(A)), a = { [e]: n };
    super({ inTypes: i, outTypes: a, inputs: { a: A } }), this.outKey = e;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
class $ extends O {
  constructor({
    a: A,
    b: e,
    outKey: s,
    outTypeFunc: i
  }) {
    const n = { a: _(A), b: _(e) }, a = i(_(A), _(e)), r = { [s]: a };
    super({ inTypes: n, outTypes: r, inputs: { a: A, b: e } }), this.outKey = s;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
class ut extends O {
  constructor({
    a: A,
    b: e,
    c: s,
    outKey: i,
    outTypeFunc: n
  }) {
    const a = { a: _(A), b: _(e), c: _(s) }, r = n(_(A), _(e), _(s)), g = { [i]: r };
    super({ inTypes: a, outTypes: g, inputs: { a: A, b: e, c: s } }), this.outKey = i;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
const j = { type: "Gsplat" }, Pt = { type: "PackedSplats" }, Hg = (t) => new Ls({ packedSplats: t }), Ht = (t, A) => new vs({ packedSplats: t, index: A }), Us = (t, A, e, s) => new Ys({ packedSplats: t, index: A, base: e, count: s }), Bt = (t) => new Js({ gsplat: t }), at = ({
  gsplat: t,
  flags: A,
  index: e,
  center: s,
  scales: i,
  quaternion: n,
  rgba: a,
  rgb: r,
  opacity: g,
  x: I,
  y: Q,
  z: o,
  r: C,
  g: E,
  b: l
}) => new Ts({
  gsplat: t,
  flags: A,
  index: e,
  center: s,
  scales: i,
  quaternion: n,
  rgba: a,
  rgb: r,
  opacity: g,
  x: I,
  y: Q,
  z: o,
  r: C,
  g: E,
  b: l
}), Re = (t) => new qs({ gsplat: t }), Oe = (t, {
  scale: A,
  rotate: e,
  translate: s,
  recolor: i
}) => new Ks({ gsplat: t, scale: A, rotate: e, translate: s, recolor: i }), FA = EA(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`), he = EA(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
  };
`);
class Ls extends F {
  constructor({
    packedSplats: A
  }) {
    super({ a: A, outKey: "numSplats", outTypeFunc: () => "int" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.numSplats} = ${e.a}.numSplats;`
    ];
  }
}
const bs = EA(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);
      return true;
    } else {
      return false;
    }
  }
`);
class vs extends O {
  constructor({
    packedSplats: A,
    index: e
  }) {
    super({
      inTypes: { packedSplats: Pt, index: "int" },
      outTypes: { gsplat: j },
      inputs: { packedSplats: A, index: e },
      globals: () => [FA, he, bs],
      statements: ({ inputs: s, outputs: i }) => {
        const { gsplat: n } = i;
        if (!n)
          return [];
        const { packedSplats: a, index: r } = s;
        let g;
        return a && r ? g = UA(`
            if (readPackedSplat(${a}.texture, ${a}.numSplats, ${r}, ${n})) {
              bool zeroSize = all(equal(${n}.scales, vec3(0.0, 0.0, 0.0)));
              ${n}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${n}.flags = 0u;
            }
          `) : g = [`${n}.flags = 0u;`], g.push(`${n}.index = ${r ?? "0"};`), g;
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
class Ys extends O {
  constructor({
    packedSplats: A,
    index: e,
    base: s,
    count: i
  }) {
    super({
      inTypes: {
        packedSplats: Pt,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: j },
      inputs: { packedSplats: A, index: e, base: s, count: i },
      globals: () => [FA, he, bs],
      statements: ({ inputs: n, outputs: a }) => {
        const { gsplat: r } = a;
        if (!r)
          return [];
        const { packedSplats: g, index: I, base: Q, count: o } = n;
        let C;
        return g && I && Q && o ? C = UA(`
            ${r}.flags = 0u;
            if ((${I} >= ${Q}) && (${I} < (${Q} + ${o}))) {
              if (readPackedSplat(${g}.texture, ${g}.numSplats, ${I}, ${r})) {
                bool zeroSize = all(equal(${r}.scales, vec3(0.0, 0.0, 0.0)));
                ${r}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `) : C = [`${r}.flags = 0u;`], C.push(`${r}.index = ${I ?? "0"};`), C;
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
class Js extends O {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: j },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat: A },
      globals: () => [FA],
      statements: ({ inputs: e, outputs: s }) => {
        const { gsplat: i } = e, {
          flags: n,
          active: a,
          index: r,
          center: g,
          scales: I,
          quaternion: Q,
          rgba: o,
          rgb: C,
          opacity: E,
          x: l,
          y: c,
          z: h,
          r: u,
          g: p,
          b: d
        } = s;
        return [
          n ? `${n} = ${i ? `${i}.flags` : "0u"};` : null,
          a ? `${a} = isGsplatActive(${i ? `${i}.flags` : "0u"});` : null,
          r ? `${r} = ${i ? `${i}.index` : "0"};` : null,
          g ? `${g} = ${i ? `${i}.center` : "vec3(0.0, 0.0, 0.0)"};` : null,
          I ? `${I} = ${i ? `${i}.scales` : "vec3(0.0, 0.0, 0.0)"};` : null,
          Q ? `${Q} = ${i ? `${i}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};` : null,
          o ? `${o} = ${i ? `${i}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};` : null,
          C ? `${C} = ${i ? `${i}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};` : null,
          E ? `${E} = ${i ? `${i}.rgba.a` : "0.0"};` : null,
          l ? `${l} = ${i ? `${i}.center.x` : "0.0"};` : null,
          c ? `${c} = ${i ? `${i}.center.y` : "0.0"};` : null,
          h ? `${h} = ${i ? `${i}.center.z` : "0.0"};` : null,
          u ? `${u} = ${i ? `${i}.rgba.r` : "0.0"};` : null,
          p ? `${p} = ${i ? `${i}.rgba.g` : "0.0"};` : null,
          d ? `${d} = ${i ? `${i}.rgba.b` : "0.0"};` : null
        ].filter(Boolean);
      }
    });
  }
}
class Ts extends O {
  constructor({
    gsplat: A,
    flags: e,
    index: s,
    center: i,
    scales: n,
    quaternion: a,
    rgba: r,
    rgb: g,
    opacity: I,
    x: Q,
    y: o,
    z: C,
    r: E,
    g: l,
    b: c
  }) {
    super({
      inTypes: {
        gsplat: j,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: j },
      inputs: {
        gsplat: A,
        flags: e,
        index: s,
        center: i,
        scales: n,
        quaternion: a,
        rgba: r,
        rgb: g,
        opacity: I,
        x: Q,
        y: o,
        z: C,
        r: E,
        g: l,
        b: c
      },
      globals: () => [FA],
      statements: ({ inputs: h, outputs: u }) => {
        const { gsplat: p } = u;
        if (!p)
          return [];
        const {
          gsplat: d,
          flags: y,
          index: D,
          center: S,
          scales: m,
          quaternion: f,
          rgba: w,
          rgb: R,
          opacity: M,
          x,
          y: L,
          z: N,
          r: k,
          g: U,
          b: v
        } = h;
        return [
          `${p}.flags = ${y ?? (d ? `${d}.flags` : "0u")};`,
          `${p}.index = ${D ?? (d ? `${d}.index` : "0")};`,
          `${p}.center = ${S ?? (d ? `${d}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${p}.scales = ${m ?? (d ? `${d}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${p}.quaternion = ${f ?? (d ? `${d}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${p}.rgba = ${w ?? (d ? `${d}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          R ? `${p}.rgba.rgb = ${R};` : null,
          M ? `${p}.rgba.a = ${M};` : null,
          x ? `${p}.center.x = ${x};` : null,
          L ? `${p}.center.y = ${L};` : null,
          N ? `${p}.center.z = ${N};` : null,
          k ? `${p}.rgba.r = ${k};` : null,
          U ? `${p}.rgba.g = ${U};` : null,
          v ? `${p}.rgba.b = ${v};` : null
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
const Hs = EA(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class qs extends F {
  constructor({ gsplat: A }) {
    super({ a: A, outKey: "normal", outTypeFunc: () => "vec3" }), this.globals = () => [FA, Hs], this.statements = ({ inputs: e, outputs: s }) => [
      `${s.normal} = gsplatNormal(${e.a}.scales, ${e.a}.quaternion);`
    ];
  }
}
class Ks extends O {
  constructor({
    gsplat: A,
    scale: e,
    rotate: s,
    translate: i,
    recolor: n
  }) {
    super({
      inTypes: {
        gsplat: j,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: j },
      inputs: { gsplat: A, scale: e, rotate: s, translate: i, recolor: n },
      globals: () => [FA],
      statements: ({ inputs: a, outputs: r, compile: g }) => {
        const { gsplat: I } = r;
        if (!I || !a.gsplat)
          return [];
        const { scale: Q, rotate: o, translate: C, recolor: E } = a, l = g.indent;
        return [
          `${I} = ${a.gsplat};`,
          `if (isGsplatActive(${I}.flags)) {`,
          Q ? `${l}${I}.center *= ${Q};` : null,
          o ? `${l}${I}.center = quatVec(${o}, ${I}.center);` : null,
          C ? `${l}${I}.center += ${C};` : null,
          Q ? `${l}${I}.scales *= ${Q};` : null,
          o ? `${l}${I}.quaternion = quatQuat(${o}, ${I}.quaternion);` : null,
          E ? `${l}${I}.rgba *= ${E};` : null,
          "}"
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
const zs = (t) => new _s({ gsplat: t }), qg = (t) => new Ve({ rgba8: t });
class _s extends O {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: j },
      inputs: { gsplat: A },
      globals: () => [FA],
      statements: ({ inputs: e, outputs: s }) => {
        const { output: i } = s;
        if (!i)
          return [];
        const { gsplat: n } = e;
        return n ? UA(`
            if (isGsplatActive(${n}.flags)) {
              ${i} = packSplat(${n}.center, ${n}.scales, ${n}.quaternion, ${n}.rgba);
            } else {
              ${i} = uvec4(0u, 0u, 0u, 0u);
            }
          `) : [`${i} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new K(this, "output");
  }
}
class Ve extends O {
  constructor({ rgba8: A }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8: A },
      statements: ({ inputs: e, outputs: s }) => [
        `target = ${e.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new K(this, "rgba8");
  }
}
const Kg = (t, A, e) => new G({ key: t, type: A, value: e }), zg = (t = !1, A) => new re({ key: A, value: t }), _g = (t = 0, A) => new Os({ key: A, value: t }), Og = (t = 0, A) => new qt({ key: A, value: t }), JA = (t = 0, A) => new Ct({ key: A, value: t }), Vg = (t, A) => new Vs({ key: A, value: t }), Pg = (t, A) => new Ps({ key: A, value: t }), Zg = (t, A) => new Zs({ key: A, value: t }), Xg = (t, A) => new Xs({ key: A, value: t }), Wg = (t, A) => new Ws({ key: A, value: t }), jg = (t, A) => new js({ key: A, value: t }), $g = (t, A) => new $s({ key: A, value: t }), At = (t, A) => new Mt({ key: A, value: t }), Ao = (t, A) => new Ai({ key: A, value: t }), to = (t, A) => new ti({ key: A, value: t }), eo = (t, A) => new ei({ key: A, value: t }), so = (t, A) => new Zt({ key: A, value: t }), io = (t, A) => new si({ key: A, value: t }), no = (t, A) => new ii({ key: A, value: t }), ao = (t, A) => new ni({ key: A, value: t }), ro = (t, A) => new ai({ key: A, value: t }), go = (t, A) => new ri({ key: A, value: t }), oo = (t, A) => new gi({ key: A, value: t }), Io = (t, A) => new oi({ key: A, value: t }), Qo = (t, A) => new Ii({ key: A, value: t }), Bo = (t, A) => new Qi({ key: A, value: t }), Co = (t, A) => new Bi({ key: A, value: t }), Eo = (t, A) => new Ci({ key: A, value: t }), co = (t, A) => new Ei({ key: A, value: t }), ho = (t, A) => new ci({ key: A, value: t }), lo = (t, A) => new hi({ key: A, value: t }), uo = (t, A) => new li({ key: A, value: t }), po = (t, A) => new Jt({ key: A, value: t }), yo = (t, A) => new ui({ key: t, value: A }), wo = (t, A) => new di({ key: A, value: t }), Do = (t, A) => new pi({ key: A, value: t }), fo = (t, A) => new yi({ key: A, value: t }), mo = (t, A) => new wi({ key: A, value: t }), xo = (t, A) => new Di({ key: A, value: t }), So = (t, A) => new fi({ key: A, value: t }), Mo = (t, A) => new mi({ key: A, value: t }), Fo = (t, A) => new xi({ key: A, value: t }), No = (t, A) => new Si({ key: A, value: t }), ko = (t, A) => new Mi({ key: A, value: t });
class G extends O {
  constructor({
    key: A,
    type: e,
    count: s,
    value: i,
    update: n,
    globals: a
  }) {
    A = A ?? "value", super({
      outTypes: { [A]: e },
      update: () => {
        if (n) {
          const r = n(this.value);
          r !== void 0 && (this.value = r);
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs: r, outputs: g }) => {
        const I = (a == null ? void 0 : a({ inputs: r, outputs: g })) ?? [], Q = {}, o = g[A];
        return o && (I.push(`uniform ${_e(o, e, s)};`), Q[o] = this.uniform), { globals: I, uniforms: Q };
      }
    }), this.type = e, this.count = s, this.value = i, this.uniform = { value: i }, this.outKey = A;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
class re extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bool", value: e, update: s });
  }
}
class Os extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uint", value: e, update: s });
  }
}
class qt extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "int", value: e, update: s });
  }
}
class Ct extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "float", value: e, update: s });
  }
}
class Vs extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bvec2", value: e, update: s });
  }
}
class Ps extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uvec2", value: e, update: s });
  }
}
class Zs extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "ivec2", value: e, update: s });
  }
}
class Xs extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "vec2", value: e, update: s });
  }
}
class Ws extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bvec3", value: e, update: s });
  }
}
class js extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uvec3", value: e, update: s });
  }
}
class $s extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "ivec3", value: e, update: s });
  }
}
class Mt extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "vec3", value: e, update: s });
  }
}
class Ai extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bvec4", value: e, update: s });
  }
}
class ti extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uvec4", value: e, update: s });
  }
}
class ei extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "ivec4", value: e, update: s });
  }
}
class Zt extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "vec4", value: e, update: s });
  }
}
class si extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2", value: e, update: s });
  }
}
class ii extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2x2", value: e, update: s });
  }
}
class ni extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2x3", value: e, update: s });
  }
}
class ai extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2x4", value: e, update: s });
  }
}
class ri extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3", value: e, update: s });
  }
}
class gi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3x2", value: e, update: s });
  }
}
class oi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3x3", value: e, update: s });
  }
}
class Ii extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3x4", value: e, update: s });
  }
}
class Qi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4", value: e, update: s });
  }
}
class Bi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4x2", value: e, update: s });
  }
}
class Ci extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4x3", value: e, update: s });
  }
}
class Ei extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4x4", value: e, update: s });
  }
}
class ci extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usampler2D", value: e, update: s });
  }
}
class hi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isampler2D", value: e, update: s });
  }
}
class li extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2D", value: e, update: s });
  }
}
class Jt extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usampler2DArray", value: e, update: s });
  }
}
class ui extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isampler2DArray", value: e, update: s });
  }
}
class di extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2DArray", value: e, update: s });
  }
}
class pi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usampler3D", value: e, update: s });
  }
}
class yi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isampler3D", value: e, update: s });
  }
}
class wi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler3D", value: e, update: s });
  }
}
class Di extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usamplerCube", value: e, update: s });
  }
}
class fi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isamplerCube", value: e, update: s });
  }
}
class mi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "samplerCube", value: e, update: s });
  }
}
class xi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2DShadow", value: e, update: s });
  }
}
class Si extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2DArrayShadow", value: e, update: s });
  }
}
class Mi extends G {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "samplerCubeShadow", value: e, update: s });
  }
}
const Xt = new Float32Array(1), le = new Uint32Array(Xt.buffer);
function Go(t) {
  return Xt[0] = t, le[0];
}
function Ro(t) {
  return le[0] = t, Xt[0];
}
function Et(t) {
  Xt[0] = t;
  const A = le[0], e = A >> 31 & 1, s = A >> 23 & 255, i = A & 8388607, n = e << 15;
  if (s === 255)
    return i !== 0 ? n | 32767 : n | 31744;
  const a = s - 127 + 15;
  if (a >= 31)
    return n | 31744;
  if (a <= 0) {
    if (a < -10)
      return n;
    const g = (i | 8388608) >> 1 - a + 13;
    return n | g;
  }
  const r = i >> 13;
  return n | a << 10 | r;
}
function DA(t) {
  const A = t >> 15 & 1, e = t >> 10 & 31, s = t & 1023;
  let i;
  if (e === 0)
    if (s === 0)
      i = A << 31;
    else {
      let n = s, a = -14;
      for (; (n & 1024) === 0; )
        n <<= 1, a--;
      n &= 1023;
      const r = a + 127, g = n << 13;
      i = A << 31 | r << 23 | g;
    }
  else if (e === 31)
    s === 0 ? i = A << 31 | 2139095040 : i = A << 31 | 2143289344;
  else {
    const n = e - 15 + 127, a = s << 13;
    i = A << 31 | n << 23 | a;
  }
  return le[0] = i, Xt[0];
}
function NA(t) {
  return Math.max(0, Math.min(255, Math.round(t * 255)));
}
function se(t) {
  return Math.max(-127, Math.min(127, Math.round(t * 127)));
}
function Uo(t) {
  return t / 255;
}
function Lo(t) {
  return t / 127;
}
class bo {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch: A,
    maxItems: e = 5
  }) {
    this.asyncFetch = A, this.maxItems = e, this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(A) {
    const e = this.items.findIndex((i) => i.key === A);
    if (e >= 0) {
      const i = this.items.splice(e, 1)[0];
      return this.items.push(i), i.data;
    }
    const s = await this.asyncFetch(A);
    for (this.items.push({ key: A, data: s }); this.items.length > this.maxItems; )
      this.items.shift();
    return s;
  }
}
function vo(t, A) {
  const e = Object.entries(t).map(([s, i]) => [
    s,
    A(i, s)
  ]);
  return Object.fromEntries(e);
}
function Yo(t, A) {
  const e = Object.entries(t).map(([s, i]) => [s, A(i, s)]).filter(([s, i]) => i !== void 0);
  return Object.fromEntries(e);
}
function Fi(t) {
  const A = [], e = /* @__PURE__ */ new Set();
  function s(i) {
    i && typeof i == "object" && !e.has(i) && (e.add(i), i instanceof ArrayBuffer ? A.push(i) : ArrayBuffer.isView(i) ? A.push(i.buffer) : Array.isArray(i) ? i.forEach(s) : Object.values(i).forEach(s));
  }
  return s(t), A;
}
function Jo(t, A) {
  return new Array(t).fill(null).map((e, s) => A(s));
}
class Ni {
  constructor({
    // Allocate a new item with the given args
    allocate: A,
    // Dispose of an item (optional, if GC is enough)
    dispose: e,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid: s
  }) {
    this.items = [], this.allocate = A, this.dispose = e, this.valid = s;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(A) {
    for (; ; ) {
      const e = this.items.pop();
      if (!e)
        break;
      if (this.valid(e, A))
        return e;
      this.dispose && this.dispose(e);
    }
    return this.allocate(A);
  }
  free(A) {
    this.items.push(A);
  }
  disposeAll() {
    let A;
    for (A = this.items.pop(); A; )
      this.dispose && this.dispose(A), A = this.items.pop();
  }
}
function Ue(t, A, e, s, i, n, a, r, g, I, Q, o, C, E, l, c) {
  const h = NA(E), u = NA(l), p = NA(c), d = NA(C), y = Pe(
    new B.Quaternion(g, I, Q, o)
  ), D = y & 255, S = y >>> 8 & 255, m = y >>> 16 & 255, f = n < mt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(n) - HA) / PA) + 1
    )
  ), w = a < mt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(a) - HA) / PA) + 1
    )
  ), R = r < mt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(r) - HA) / PA) + 1
    )
  ), M = Et(e), x = Et(s), L = Et(i), N = A * 4;
  t[N] = h | u << 8 | p << 16 | d << 24, t[N + 1] = M | x << 16, t[N + 2] = L | D << 16 | S << 24, t[N + 3] = f | w << 8 | R << 16 | m << 24;
}
function To(t, A, e, s, i) {
  const n = Et(e), a = Et(s), r = Et(i), g = A * 4;
  t[g + 1] = n | a << 16, t[g + 2] = r | t[g + 2] & 4294901760;
}
function Ho(t, A, e, s, i) {
  const n = e < mt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(e) - HA) / PA) + 1
    )
  ), a = s < mt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(s) - HA) / PA) + 1
    )
  ), r = i < mt ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(i) - HA) / PA) + 1
    )
  ), g = A * 4;
  t[g + 3] = n | a << 8 | r << 16 | t[g + 3] & 4278190080;
}
function qo(t, A, e, s, i, n) {
  const a = Pe(
    new B.Quaternion(e, s, i, n)
  ), r = a & 255, g = a >>> 8 & 255, I = a >>> 16 & 255, Q = A * 4;
  t[Q + 2] = t[Q + 2] & 65535 | r << 16 | g << 24, t[Q + 3] = t[Q + 3] & 16777215 | I << 24;
}
function Ko(t, A, e, s, i, n) {
  const a = NA(e), r = NA(s), g = NA(i), I = NA(n), Q = A * 4;
  t[Q] = a | r << 8 | g << 16 | I << 24;
}
function zo(t, A, e, s, i) {
  const n = NA(e), a = NA(s), r = NA(i), g = A * 4;
  t[g] = n | a << 8 | r << 16 | t[g] & 4278190080;
}
function _o(t, A, e) {
  const s = NA(e), i = A * 4;
  t[i] = t[i] & 16777215 | s << 24;
}
const Oo = new B.Vector3(), Vo = new B.Vector3(), Po = new B.Quaternion(), Zo = new B.Color(), Xo = {
  center: Oo,
  scales: Vo,
  quaternion: Po,
  color: Zo,
  opacity: 0
};
function Le(t, A) {
  const e = Xo, s = A * 4, i = t[s], n = t[s + 1], a = t[s + 2], r = t[s + 3];
  e.color.set(
    (i & 255) / 255,
    (i >>> 8 & 255) / 255,
    (i >>> 16 & 255) / 255
  ), e.opacity = (i >>> 24 & 255) / 255, e.center.set(
    DA(n & 65535),
    DA(n >>> 16 & 65535),
    DA(a & 65535)
  );
  const g = r & 255;
  e.scales.x = g === 0 ? 0 : Math.exp(HA + (g - 1) * PA);
  const I = r >>> 8 & 255;
  e.scales.y = I === 0 ? 0 : Math.exp(HA + (I - 1) * PA);
  const Q = r >>> 16 & 255;
  e.scales.z = Q === 0 ? 0 : Math.exp(HA + (Q - 1) * PA);
  const o = a >>> 16 & 65535 | r >>> 8 & 16711680;
  return vi(o, e.quaternion), e;
}
function mA(t) {
  const A = W, e = Math.max(
    xs,
    Math.min(it, Math.ceil(t / A))
  ), s = Math.ceil(t / (A * e)), i = A * e * s;
  return { width: A, height: e, depth: s, maxSplats: i };
}
function Wo(t) {
  const A = W, e = Math.max(
    xs,
    Math.min(it, Math.ceil(t / A))
  ), s = Math.ceil(t / (A * e));
  return A * e * s;
}
function jo() {
  return navigator.maxTouchPoints > 0 ? !0 : /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function $o() {
  return /Android/.test(navigator.userAgent);
}
function AI() {
  return /Oculus/.test(navigator.userAgent);
}
function tI(t, A, e) {
  const s = new Uint8Array(A * 4);
  for (let i = 0; i < e / 2; i++) {
    const n = i * A * 4, a = (e - 1 - i) * A * 4;
    s.set(t.subarray(n, n + A * 4)), t.set(
      t.subarray(a, a + A * 4),
      n
    ), t.set(s, a);
  }
  return t;
}
function eI(t, A, e) {
  const s = document.createElement("canvas");
  s.width = A, s.height = e;
  const i = s.getContext("2d");
  if (!i)
    throw new Error("Can't get 2d context");
  const n = i.createImageData(A, e);
  return n.data.set(t), i.putImageData(n, 0, 0), s.toDataURL("image/png");
}
function ki(t) {
  const A = new B.Clock(t.autoStart);
  return A.startTime = t.startTime, A.oldTime = t.oldTime, A.elapsedTime = t.elapsedTime, A.running = t.running, A;
}
function sI(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([A, e]) => e !== void 0)
  );
}
const Gi = EA(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function Ri(t) {
  const A = new B.Vector3();
  for (const e of t)
    A.add(e);
  return A.divideScalar(t.length);
}
function Ui(t) {
  if (t.length === 0)
    return new B.Quaternion();
  const A = t[0].clone();
  for (let e = 1; e < t.length; e++)
    t[e].dot(t[0]) < 0 ? (A.x -= t[e].x, A.y -= t[e].y, A.z -= t[e].z, A.w -= t[e].w) : (A.x += t[e].x, A.y += t[e].y, A.z += t[e].z, A.w += t[e].w);
  return A.normalize();
}
function Li(t, A) {
  const e = new B.Vector3(0, 0, 0).applyMatrix4(t), s = new B.Vector3(0, 0, 0).applyMatrix4(A), i = new B.Vector3(0, 0, -1).applyMatrix4(t).sub(e).normalize(), n = new B.Vector3(0, 0, -1).applyMatrix4(A).sub(s).normalize(), a = e.distanceTo(s), r = i.dot(n);
  return { distance: a, coincidence: r };
}
function iI({
  matrix1: t,
  matrix2: A,
  maxDistance: e
}) {
  const s = new B.Vector3(0, 0, 0).applyMatrix4(t), i = new B.Vector3(0, 0, 0).applyMatrix4(A);
  return s.distanceTo(i) <= e;
}
function nI({
  matrix1: t,
  matrix2: A,
  maxDistance: e,
  minCoincidence: s
}) {
  const { distance: i, coincidence: n } = Li(t, A);
  return i <= e && (s == null || n >= s);
}
function bi(t, A) {
  const [e, s] = [new B.Vector3(), new B.Quaternion()], [i, n] = [new B.Vector3(), new B.Quaternion()];
  t.decompose(e, s, new B.Vector3()), A.decompose(i, n, new B.Vector3());
  const a = e.distanceTo(i), r = Math.abs(s.dot(n));
  return { distance: a, coorient: r };
}
function ge({
  matrix1: t,
  matrix2: A,
  maxDistance: e,
  minCoorient: s
}) {
  const { distance: i, coorient: n } = bi(t, A);
  return i <= e && (s == null || n >= s);
}
function aI(t, A = 1e-3) {
  return Math.abs(t) < A ? 0 : Math.sign(t);
}
function rI(t) {
  const A = t.w < 0, e = se(A ? -t.x : t.x), s = se(A ? -t.y : t.y), i = se(A ? -t.z : t.z), n = e & 255, a = s & 255, r = i & 255;
  return n | a << 8 | r << 16;
}
function gI(t, A) {
  const e = t << 24 >> 24, s = t << 16 >> 24, i = t << 8 >> 24;
  A.set(e / 127, s / 127, i / 127, 0);
  const n = A.x * A.x + A.y * A.y + A.z * A.z;
  return A.w = Math.sqrt(Math.max(0, 1 - n)), A;
}
function Pe(t) {
  const A = t.clone().normalize();
  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);
  const e = 2 * Math.acos(A.w), s = Math.sqrt(
    A.x * A.x + A.y * A.y + A.z * A.z
  ), i = s < 1e-6 ? new B.Vector3(1, 0, 0) : new B.Vector3(A.x, A.y, A.z).divideScalar(s), n = Math.abs(i.x) + Math.abs(i.y) + Math.abs(i.z);
  let a = i.x / n, r = i.y / n;
  if (i.z < 0) {
    const E = a;
    a = (1 - Math.abs(r)) * (a >= 0 ? 1 : -1), r = (1 - Math.abs(E)) * (r >= 0 ? 1 : -1);
  }
  const g = a * 0.5 + 0.5, I = r * 0.5 + 0.5, Q = Math.round(g * 255), o = Math.round(I * 255);
  return Math.round(e * (255 / Math.PI)) << 16 | o << 8 | Q;
}
function vi(t, A) {
  const e = t & 255, s = t >>> 8 & 255, i = t >>> 16 & 255, n = e / 255, a = s / 255;
  let r = (n - 0.5) * 2, g = (a - 0.5) * 2;
  const I = 1 - (Math.abs(r) + Math.abs(g)), Q = Math.max(-I, 0);
  r += r >= 0 ? -Q : Q, g += g >= 0 ? -Q : Q;
  const o = new B.Vector3(r, g, I).normalize(), E = i / 255 * Math.PI * 0.5, l = Math.sin(E), c = Math.cos(E);
  return A.set(o.x * l, o.y * l, o.z * l, c), A;
}
function oI(t) {
  const A = t.clone().normalize(), e = 2 * (A.w * A.x + A.y * A.z), s = 1 - 2 * (A.x * A.x + A.y * A.y), i = Math.atan2(e, s), n = 2 * (A.w * A.y - A.z * A.x), a = Math.abs(n) >= 1 ? Math.sign(n) * (Math.PI / 2) : Math.asin(n), r = 2 * (A.w * A.z + A.x * A.y), g = 1 - 2 * (A.y * A.y + A.z * A.z), I = Math.atan2(r, g), Q = (i + Math.PI) / (2 * Math.PI), o = (a + Math.PI) / (2 * Math.PI), C = (I + Math.PI) / (2 * Math.PI), E = Math.round(Q * 255), l = Math.round(o * 255);
  return Math.round(C * 255) << 16 | l << 8 | E;
}
function II(t, A) {
  const e = t & 255, s = t >>> 8 & 255, i = t >>> 16 & 255, n = e / 255, a = s / 255, r = i / 255, g = n * (2 * Math.PI) - Math.PI, I = a * (2 * Math.PI) - Math.PI, Q = r * (2 * Math.PI) - Math.PI, o = Math.cos(g * 0.5), C = Math.sin(g * 0.5), E = Math.cos(I * 0.5), l = Math.sin(I * 0.5), c = Math.cos(Q * 0.5), h = Math.sin(Q * 0.5);
  return A.w = o * E * c + C * l * h, A.x = C * E * c - o * l * h, A.y = o * l * c + C * E * h, A.z = o * E * h - C * l * c, A.normalize(), A;
}
function jt(t, A, e, s) {
  const i = Math.max(-127, Math.min(127, t * 127)), n = Math.max(-127, Math.min(127, A * 127)), a = Math.max(-127, Math.min(127, e * 127)), r = Math.max(-127, Math.min(127, s * 127));
  return i & 255 | (n & 255) << 8 | (a & 255) << 16 | (r & 255) << 24;
}
function QI(t, A, e) {
  const s = A * 2;
  for (let i = 0; i < 9; ++i) {
    const n = Math.max(-63, Math.min(63, e[i] * 63)) & 127, a = i * 7, r = a + 7, g = Math.floor(a / 32), I = a - g * 32, Q = n << I & 4294967295;
    if (t[s + g] |= Q, r > g * 32 + 32) {
      const o = n >>> 32 - I & 4294967295;
      t[s + g + 1] |= o;
    }
  }
}
function BI(t, A, e) {
  t[A * 4 + 0] = jt(
    e[0],
    e[1],
    e[2],
    e[3]
  ), t[A * 4 + 1] = jt(
    e[4],
    e[5],
    e[6],
    e[7]
  ), t[A * 4 + 2] = jt(
    e[8],
    e[9],
    e[10],
    e[11]
  ), t[A * 4 + 3] = jt(
    e[12],
    e[13],
    e[14],
    0
  );
}
function CI(t, A, e) {
  const s = A * 4;
  for (let i = 0; i < 21; ++i) {
    const n = Math.max(-31, Math.min(31, e[i] * 31)) & 63, a = i * 6, r = a + 6, g = Math.floor(a / 32), I = a - g * 32, Q = n << I & 4294967295;
    if (t[s + g] |= Q, r > g * 32 + 32) {
      const o = n >>> 32 - I & 4294967295;
      t[s + g + 1] |= o;
    }
  }
}
function Yi(t, A) {
  const e = [];
  let s = 0, i = null;
  const n = new Ds((g, I) => {
    if (e.push(g), s += g.length, I || s >= A) {
      const Q = new Uint8Array(s);
      let o = 0;
      for (const C of e)
        Q.set(C, o), o += C.length;
      i = Q.slice(0, A);
    }
  }), a = 1024;
  let r = 0;
  for (; i == null && r < t.length; ) {
    const g = t.slice(r, r + a);
    n.push(g, !1), r += a;
  }
  if (i == null && (n.push(new Uint8Array(), !0), i == null))
    throw new Error("Failed to decompress partial gzip");
  return i;
}
class Ji {
  constructor({
    fileBytes: A,
    chunkBytes: e = 64 * 1024
  }) {
    this.fileBytes = A, this.chunkBytes = e, this.offset = 0, this.chunks = [], this.totalBytes = 0, this.gunzip = new Ds((s, i) => {
      this.chunks.push(s), this.totalBytes += s.length;
    });
  }
  read(A) {
    for (; this.totalBytes < A && this.offset < this.fileBytes.length; ) {
      const n = Math.min(
        this.offset + this.chunkBytes,
        this.fileBytes.length
      );
      this.gunzip.push(this.fileBytes.subarray(this.offset, n), !1), this.offset = n;
    }
    if (this.totalBytes < A && this.offset >= this.fileBytes.length && this.gunzip.push(new Uint8Array(0), !0), this.totalBytes < A)
      throw new Error(
        `Unexpected EOF: needed ${A}, got ${this.totalBytes}`
      );
    const e = new Uint8Array(this.totalBytes);
    let s = 0;
    for (const n of this.chunks)
      e.set(n, s), s += n.length;
    const i = e.subarray(0, A);
    return this.chunks = [e.subarray(A)], this.totalBytes -= A, i;
  }
}
const QE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache: bo,
  FreeList: Ni,
  GunzipReader: Ji,
  IDENT_VERTEX_SHADER: Gi,
  Sint8ToFloat: Lo,
  Uint8ToFloat: Uo,
  averagePositions: Ri,
  averageQuaternions: Ui,
  cloneClock: ki,
  coinciDist: Li,
  computeMaxSplats: Wo,
  coorientDist: bi,
  decodeQuatEulerXyz888: II,
  decodeQuatOctXy88R8: vi,
  decodeQuatXyz888: gI,
  decompressPartialGzip: Yi,
  encodeQuatEulerXyz888: oI,
  encodeQuatOctXy88R8: Pe,
  encodeQuatXyz888: rI,
  encodeSh1Rgb: QI,
  encodeSh2Rgb: BI,
  encodeSh3Rgb: CI,
  epsilonSign: aI,
  flipPixels: tI,
  floatBitsToUint: Go,
  floatToSint8: se,
  floatToUint8: NA,
  fromHalf: DA,
  getArrayBuffers: Fi,
  getTextureSize: mA,
  isAndroid: $o,
  isMobile: jo,
  isOculus: AI,
  mapFilterObject: Yo,
  mapObject: vo,
  newArray: Jo,
  omitUndefined: sI,
  pixelsToPngUrl: eI,
  setPackedSplat: Ue,
  setPackedSplatCenter: To,
  setPackedSplatOpacity: _o,
  setPackedSplatQuat: qo,
  setPackedSplatRgb: zo,
  setPackedSplatRgba: Ko,
  setPackedSplatScales: Ho,
  toHalf: Et,
  uintBitsToFloat: Ro,
  unpackSplat: Le,
  withinCoinciDist: nI,
  withinCoorientDist: ge,
  withinDist: iI
}, Symbol.toStringTag, { value: "Module" }));
class Ze {
  constructor({
    graph: A,
    inputs: e,
    outputs: s,
    template: i
  }) {
    this.graph = A, this.template = i, this.inputs = e ?? {}, this.outputs = s ?? {};
    const n = new Rs({ indent: this.template.indent });
    for (const r in this.outputs)
      this.outputs[r] && n.declares.add(this.outputs[r]);
    const a = A.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile: n
    });
    this.shader = i.generate({ globals: n.globals, statements: a }), this.uniforms = n.uniforms, this.updaters = n.updaters;
  }
  prepareMaterial() {
    return EI(this);
  }
  update() {
    for (const A of this.updaters)
      A();
  }
}
class Xe {
  constructor(A) {
    const e = A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m), s = A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!e || !s)
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    this.before = A.substring(0, e.index), this.between = A.substring(
      e.index + e[0].length,
      s.index
    ), this.after = A.substring(
      s.index + s[0].length
    ), this.indent = s[1];
  }
  generate({
    globals: A,
    statements: e
  }) {
    return this.before + Array.from(A).join(`

`) + this.between + e.map((s) => this.indent + s).join(`
`) + this.after;
  }
}
const as = /* @__PURE__ */ new Map();
function EI(t) {
  let A = as.get(t);
  return A || (A = new B.RawShaderMaterial({
    glslVersion: B.GLSL3,
    vertexShader: Gi,
    fragmentShader: t.shader,
    uniforms: t.uniforms
  }), as.set(t, A), A);
}
function We(t, A, e = "add") {
  const s = () => {
    throw new Error(`Invalid ${e} types: ${t}, ${A}`);
  };
  if (t === A) return t;
  if (t === "int") {
    if (hA(A)) return A;
    s();
  }
  if (A === "int") {
    if (hA(t)) return t;
    s();
  }
  if (t === "uint") {
    if (lA(A)) return A;
    s();
  }
  if (A === "uint") {
    if (lA(t)) return t;
    s();
  }
  if (t === "float") {
    if (rt(A)) return A;
    s();
  }
  if (A === "float") {
    if (rt(t)) return t;
    s();
  }
  throw new Error(`Invalid ${e} types: ${t}, ${A}`);
}
function cI(t, A) {
  return We(t, A, "sub");
}
function hI(t, A) {
  const e = () => {
    throw new Error(`Invalid mul types: ${t}, ${A}`);
  }, s = (i) => i;
  if (t === "int") {
    if (hA(A)) return s(A);
    e();
  }
  if (A === "int") {
    if (hA(t)) return s(t);
    e();
  }
  if (t === "uint") {
    if (lA(A)) return s(A);
    e();
  }
  if (A === "uint") {
    if (lA(t)) return s(t);
    e();
  }
  if (t === "float") {
    if (rt(A)) return s(A);
    e();
  }
  if (A === "float") {
    if (rt(t)) return s(t);
    e();
  }
  if (hA(t) || lA(t) || hA(A) || lA(A)) {
    if (t === A) return s(t);
    e();
  }
  if (t === "vec2") {
    if (A === "vec2" || gt(A)) return s("vec2");
    if (A === "mat3x2") return s("vec3");
    if (A === "mat4x2") return s("vec4");
    e();
  }
  if (t === "vec3") {
    if (A === "mat2x3") return s("vec2");
    if (A === "vec3" || ot(A)) return s("vec3");
    if (A === "mat4x3") return s("vec4");
    e();
  }
  if (t === "vec4") {
    if (A === "mat2x4") return s("vec2");
    if (A === "mat3x4") return s("vec3");
    if (A === "vec4" || It(A)) return s("vec4");
    e();
  }
  if (A === "vec2") {
    if (gt(t)) return s("vec2");
    if (t === "mat2x3") return s("vec3");
    if (t === "mat2x4") return s("vec4");
    e();
  }
  if (A === "vec3") {
    if (t === "mat3x2") return s("vec2");
    if (ot(t)) return s("vec3");
    if (t === "mat3x4") return s("vec4");
    e();
  }
  if (A === "vec4") {
    if (t === "mat4x2") return s("vec2");
    if (t === "mat4x3") return s("vec3");
    if (It(t)) return s("vec4");
    e();
  }
  if (gt(t)) {
    if (gt(A)) return s("mat2");
    if (A === "mat3x2") return s("mat3x2");
    if (A === "mat4x2") return s("mat4x2");
    e();
  }
  if (t === "mat2x3") {
    if (gt(A)) return s("mat2x3");
    if (A === "mat3x2") return s("mat3");
    if (A === "mat4x2") return s("mat4x3");
    e();
  }
  if (t === "mat2x4") {
    if (gt(A)) return s("mat2x4");
    if (A === "mat3x2") return s("mat3x4");
    if (A === "mat4x2") return s("mat4");
    e();
  }
  if (t === "mat3x2") {
    if (A === "mat2x3") return s("mat2");
    if (ot(A)) return s("mat3x2");
    if (A === "mat4x3") return s("mat4x2");
    e();
  }
  if (ot(t)) {
    if (A === "mat2x3") return s("mat2x3");
    if (ot(A)) return s("mat3");
    if (A === "mat4x3") return s("mat4x3");
    e();
  }
  if (t === "mat3x4") {
    if (A === "mat2x3") return s("mat2x4");
    if (ot(A)) return s("mat3x4");
    if (A === "mat4x3") return s("mat4");
    e();
  }
  if (t === "mat4x2") {
    if (A === "mat2x4") return s("mat2");
    if (A === "mat3x4") return s("mat3x2");
    if (It(A)) return s("mat4x2");
    e();
  }
  if (t === "mat4x3") {
    if (A === "mat2x4") return s("mat2x3");
    if (A === "mat3x4") return s("mat3");
    if (It(A)) return s("mat4x3");
    e();
  }
  if (It(t)) {
    if (A === "mat2x4") return s("mat2x4");
    if (A === "mat3x4") return s("mat3x4");
    if (It(A)) return s("mat4");
    e();
  }
  throw new Error(`Invalid mul types: ${t}, ${A}`);
}
function lI(t, A) {
  return We(t, A, "div");
}
function uI(t, A) {
  if (t === A) return t;
  if (t === "int") {
    if (hA(A)) return A;
  } else if (A === "int") {
    if (hA(t)) return t;
  } else if (t === "uint") {
    if (lA(A)) return A;
  } else if (A === "uint" && lA(t))
    return t;
  throw new Error(`Invalid imod types: ${t}, ${A}`);
}
function dI(t, A) {
  if (t === A || A === "float") return t;
  throw new Error(`Invalid mod types: ${t}, ${A}`);
}
function pI(t) {
  return t;
}
function yI(t) {
  return t;
}
function wI(t) {
  return t;
}
function DI(t) {
  return t;
}
function fI(t) {
  return t;
}
function mI(t) {
  return t;
}
function xI(t) {
  return t;
}
function SI(t) {
  return t;
}
function MI(t) {
  return t;
}
function FI(t) {
  return t;
}
function NI(t) {
  return t;
}
function kI(t) {
  return t;
}
function GI(t) {
  return t;
}
function RI(t) {
  return t;
}
function UI(t) {
  return t;
}
function LI(t) {
  return t;
}
function Ti(t, A, e = "min") {
  if (t === A) return t;
  if (A === "float") {
    if (_t(t)) return t;
  } else if (A === "int") {
    if (hA(t)) return t;
  } else if (A === "uint" && lA(t))
    return t;
  throw new Error(`Invalid ${e} types: ${t}, ${A}`);
}
function bI(t, A) {
  return Ti(t, A, "max");
}
function vI(t, A, e) {
  if (A === "float") {
    if (_t(t)) return t;
  } else if (A === "int") {
    if (hA(t)) return t;
  } else if (A === "uint" && lA(t))
    return t;
  throw new Error(`Invalid clamp types: ${t}, ${A}`);
}
function YI(t, A, e) {
  if (e === t || e === "float" || e === "bool" && t === "float" || e === "bvec2" && t === "vec2" || e === "bvec3" && t === "vec3" || e === "bvec4" && t === "vec4") return t;
  throw new Error(`Invalid mix types: ${t}, ${A}, ${e}`);
}
function JI(t, A) {
  if (t === A || A === "float") return A;
  throw new Error(`Invalid step types: ${t}, ${A}`);
}
function TI(t, A, e) {
  if (t === A && (t === e || t === "float"))
    return e;
  throw new Error(`Invalid smoothstep types: ${t}, ${A}, ${e}`);
}
function Hi(t, A = "isNan") {
  if (t === "float") return "bool";
  if (t === "vec2") return "bvec2";
  if (t === "vec3") return "bvec3";
  if (t === "vec4") return "bvec4";
  throw new Error(`Invalid ${A} types: ${t}`);
}
function HI(t) {
  return Hi(t, "isInf");
}
const fA = (t, A) => new _i({ a: t, b: A }), Ft = (t, A) => new Oi({ a: t, b: A }), BA = (t, A) => new Vi({ a: t, b: A }), ie = (t, A) => new Pi({ a: t, b: A }), be = (t, A) => new Zi({ a: t, b: A }), qi = (t, A) => new Xi({ a: t, b: A }), qI = (t) => new Wi({ a: t }).outputs, je = (t) => new ji({ a: t }), KI = (t) => new $i({ a: t }), zI = (t) => new An({ a: t }), _I = (t) => new tn({ a: t }), OI = (t) => new en({ a: t }), VI = (t) => new sn({ a: t }), PI = (t) => new nn({ a: t }), ne = (t) => new an({ a: t }), ZI = (t, A) => new rn({ a: t, b: A }), XI = (t) => new gn({ a: t }), WI = (t) => new on({ a: t }), jI = (t) => new In({ a: t }), $I = (t) => new Qn({ a: t }), AQ = (t) => new Bn({ a: t }), tQ = (t) => new Cn({ a: t }), eQ = (t) => new En({ a: t }), sQ = (t, A) => new cn({ a: t, b: A }), Ki = (t, A) => new hn({ a: t, b: A }), iQ = (t, A, e) => new ln({ a: t, min: A, max: e }), zi = (t, A, e) => new un({ a: t, b: A, t: e }), nQ = (t, A) => new dn({ edge: t, x: A }), aQ = (t, A, e) => new pn({ edge0: t, edge1: A, x: e }), rQ = (t) => new yn({ a: t }), gQ = (t) => new wn({ a: t });
class _i extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "sum", outTypeFunc: We }), this.statements = ({ inputs: s, outputs: i }) => [`${i.sum} = ${s.a} + ${s.b};`];
  }
}
class Oi extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "difference", outTypeFunc: cI }), this.statements = ({ inputs: s, outputs: i }) => [`${i.difference} = ${s.a} - ${s.b};`];
  }
}
class Vi extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "product", outTypeFunc: hI }), this.statements = ({ inputs: s, outputs: i }) => [`${i.product} = ${s.a} * ${s.b};`];
  }
}
class Pi extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "quotient", outTypeFunc: lI }), this.statements = ({ inputs: s, outputs: i }) => [`${i.quotient} = ${s.a} / ${s.b};`];
  }
}
class Zi extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "remainder", outTypeFunc: uI }), this.statements = ({ inputs: s, outputs: i }) => [`${i.remainder} = ${s.a} % ${s.b};`];
  }
}
class Xi extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "remainder", outTypeFunc: dI }), this.statements = ({ inputs: s, outputs: i }) => [`${i.remainder} = mod(${s.a}, ${s.b});`];
  }
}
class Wi extends O {
  constructor({ a: A }) {
    const e = { a: _(A) }, s = e.a, i = {
      fract: s,
      integer: s
    };
    super({ inTypes: e, outTypes: i, inputs: { a: A } }), this.statements = ({ inputs: n, outputs: a }) => [`${a.fract} = modf(${n.a}, ${a.integer});`];
  }
}
class ji extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "neg", outTypeFunc: pI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.neg} = -${e.a};`];
  }
}
class $i extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "abs", outTypeFunc: yI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.abs} = abs(${e.a});`];
  }
}
class An extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "sign", outTypeFunc: wI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.sign} = sign(${e.a});`];
  }
}
class tn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "floor", outTypeFunc: DI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.floor} = floor(${e.a});`];
  }
}
class en extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "ceil", outTypeFunc: fI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.ceil} = ceil(${e.a});`];
  }
}
class sn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "trunc", outTypeFunc: mI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.trunc} = trunc(${e.a});`];
  }
}
class nn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "round", outTypeFunc: xI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.round} = round(${e.a});`];
  }
}
class an extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "fract", outTypeFunc: SI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.fract} = fract(${e.a});`];
  }
}
class rn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "power", outTypeFunc: MI }), this.statements = ({ inputs: s, outputs: i }) => [`${i.power} = pow(${s.a}, ${s.b});`];
  }
}
class gn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp", outTypeFunc: FI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.exp} = exp(${e.a});`];
  }
}
class on extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp2", outTypeFunc: NI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.exp2} = exp2(${e.a});`];
  }
}
class In extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "log", outTypeFunc: kI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.log} = log(${e.a});`];
  }
}
class Qn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "log2", outTypeFunc: GI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.log2} = log2(${e.a});`];
  }
}
class Bn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqr", outTypeFunc: RI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.sqr} = ${e.a} * ${e.a};`];
  }
}
class Cn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqrt", outTypeFunc: UI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.sqrt} = sqrt(${e.a});`];
  }
}
class En extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "inversesqrt", outTypeFunc: LI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.inversesqrt} = inversesqrt(${e.a});`];
  }
}
class cn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "min", outTypeFunc: Ti }), this.statements = ({ inputs: s, outputs: i }) => [`${i.min} = min(${s.a}, ${s.b});`];
  }
}
class hn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "max", outTypeFunc: bI }), this.statements = ({ inputs: s, outputs: i }) => [`${i.max} = max(${s.a}, ${s.b});`];
  }
}
class ln extends ut {
  constructor({
    a: A,
    min: e,
    max: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "clamp",
      outTypeFunc: vI
    }), this.statements = ({ inputs: i, outputs: n }) => {
      const { a, b: r, c: g } = i;
      return [`${n.clamp} = clamp(${a}, ${r}, ${g});`];
    };
  }
}
class un extends ut {
  constructor({ a: A, b: e, t: s }) {
    super({ a: A, b: e, c: s, outKey: "mix", outTypeFunc: YI }), this.statements = ({ inputs: i, outputs: n }) => {
      const { a, b: r, c: g } = i;
      return [`${n.mix} = mix(${a}, ${r}, ${g});`];
    };
  }
}
class dn extends $ {
  constructor({ edge: A, x: e }) {
    super({
      a: A,
      b: e,
      outKey: "step",
      outTypeFunc: JI
    }), this.statements = ({ inputs: s, outputs: i }) => {
      const { a: n, b: a } = s;
      return [`${i.step} = step(${n}, ${a});`];
    };
  }
}
class pn extends ut {
  constructor({
    edge0: A,
    edge1: e,
    x: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "smoothstep",
      outTypeFunc: TI
    }), this.statements = ({ inputs: i, outputs: n }) => {
      const { a, b: r, c: g } = i;
      return [`${n.smoothstep} = smoothstep(${a}, ${r}, ${g});`];
    };
  }
}
class yn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "isNan", outTypeFunc: Hi }), this.statements = ({ inputs: e, outputs: s }) => [`${s.isNan} = isNan(${e.a});`];
  }
}
class wn extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "isInf", outTypeFunc: HI }), this.statements = ({ inputs: e, outputs: s }) => [`${s.isInf} = isInf(${e.a});`];
  }
}
const oQ = (t, A) => new fn({ a: t, b: A }), IQ = (t, A) => new mn({ a: t, b: A }), QQ = (t, A) => new xn({ a: t, b: A }), BQ = (t) => new Sn({ a: t }), CQ = (t, A) => new Mn({ a: t, b: A }), EQ = (t, A) => new Fn({ a: t, b: A }), cQ = (t, A) => new Nn({ a: t, b: A }), Dn = (t, A) => new kn({ a: t, b: A }), hQ = (t, A) => new Gn({ a: t, b: A }), lQ = (t, A) => new Rn({ a: t, b: A }), uQ = (t) => new Un({ a: t }), dQ = (t) => new Ln({ a: t }), $e = (t, A, e) => new bn({ cond: t, t: A, f: e }), pQ = (t) => new Yn({ a: t });
class fn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (s, i) => s, outKey: "and" }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.and === "bool" ? [`${i.and} = ${s.a} && ${s.b};`] : [`${i.and} = ${s.a} & ${s.b};`];
  }
}
class mn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (s, i) => s, outKey: "or" }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.or === "bool" ? [`${i.or} = ${s.a} || ${s.b};`] : [`${i.or} = ${s.a} | ${s.b};`];
  }
}
class xn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (s, i) => s, outKey: "xor" }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.xor === "bool" ? [`${i.xor} = ${s.a} ^^ ${s.b};`] : [`${i.xor} = ${s.a} ^ ${s.b};`];
  }
}
class Sn extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "not" }), this.statements = ({ inputs: e, outputs: s }) => this.outTypes.not === "bool" ? [`${s.not} = !${e.a};`] : [`${s.not} = not(${e.a});`];
  }
}
class Mn extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, i) => ue(s, "lessThan"),
      outKey: "lessThan"
    }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.lessThan === "bool" ? [`${i.lessThan} = ${s.a} < ${s.b};`] : [`${i.lessThan} = lessThan(${s.a}, ${s.b});`];
  }
}
class Fn extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, i) => ue(s, "lessThanEqual"),
      outKey: "lessThanEqual"
    }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.lessThanEqual === "bool" ? [`${i.lessThanEqual} = ${s.a} <= ${s.b};`] : [
      `${i.lessThanEqual} = lessThanEqual(${s.a}, ${s.b});`
    ];
  }
}
class Nn extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, i) => ue(s, "greaterThan"),
      outKey: "greaterThan"
    }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.greaterThan === "bool" ? [`${i.greaterThan} = ${s.a} > ${s.b};`] : [
      `${i.greaterThan} = greaterThan(${s.a}, ${s.b});`
    ];
  }
}
class kn extends $ {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, i) => ue(s, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.greaterThanEqual === "bool" ? [`${i.greaterThanEqual} = ${s.a} >= ${s.b};`] : [
      `${i.greaterThanEqual} = greaterThanEqual(${s.a}, ${s.b});`
    ];
  }
}
class Gn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: vn, outKey: "equal" }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.equal === "bool" ? [`${i.equal} = ${s.a} == ${s.b};`] : [`${i.equal} = equal(${s.a}, ${s.b});`];
  }
}
class Rn extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: yQ, outKey: "notEqual" }), this.statements = ({ inputs: s, outputs: i }) => this.outTypes.notEqual === "bool" ? [`${i.notEqual} = ${s.a} != ${s.b};`] : [`${i.notEqual} = notEqual(${s.a}, ${s.b});`];
  }
}
class Un extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "bool", outKey: "any" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.any} = any(${e.a});`];
  }
}
class Ln extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "bool", outKey: "all" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.all} = all(${e.a});`];
  }
}
class bn extends ut {
  constructor({
    cond: A,
    t: e,
    f: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "select",
      outTypeFunc: (i, n, a) => n
    }), this.statements = ({ inputs: i, outputs: n }) => {
      const { a, b: r, c: g } = i;
      return [`${n.select} = (${a}) ? (${r}) : (${g});`];
    };
  }
}
function ue(t, A) {
  if (lt(t))
    return "bool";
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function vn(t, A = "equal") {
  if (lt(t))
    return "bool";
  if (ht(t))
    return t;
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function yQ(t) {
  return vn(t, "notEqual");
}
function wQ(t) {
  if (ht(t))
    return "bool";
  if (hA(t))
    return "int";
  if (lA(t))
    return "uint";
  throw new Error(`Invalid compXor type: ${t}`);
}
class Yn extends F {
  constructor({ a: A }) {
    const e = wQ(_(A));
    super({ a: A, outTypeFunc: (s) => e, outKey: "compXor" }), this.statements = ({ inputs: s, outputs: i }) => {
      if (lt(this.outTypes.compXor))
        return [`${i.compXor} = ${s.a};`];
      const a = (Nt(e) ? ["x", "y"] : kt(e) ? ["x", "y", "z"] : ["x", "y", "z", "w"]).map((g) => `${s.a}.${g}`), r = ht(e) ? "^^" : "^";
      return [`${i.compXor} = ${a.join(` ${r} `)};`];
    };
  }
}
const DQ = (t) => new _n({ value: t }), fQ = (t) => new On({ value: t }), mQ = (t) => new Vn({ value: t }), Jn = (t) => new Pn({ value: t }), xQ = (t) => new Zn({ value: t }), SQ = (t) => new Xn({ value: t }), MQ = (t) => new Wn({ value: t }), FQ = (t) => new jn({ value: t }), NQ = (t) => new $n({ value: t }), kQ = (t) => new Aa({ value: t }), GQ = (t) => new ta({ value: t }), RQ = (t) => new ea({ value: t }), UQ = (t) => new sa({ value: t }), Tn = (t) => new ia({ value: t }), ct = (t) => new na({ value: t }), Hn = (t) => new aa({ value: t }), LQ = (t) => new ra({ value: t }), bQ = (t) => new ga({ value: t }), vQ = (t) => new oa({ value: t }), qn = (t) => new Ia({ value: t }), YQ = (t) => new Qa({ value: t }), JQ = (t) => new Ba({ value: t }), TQ = (t) => new Ca({ value: t }), HQ = (t) => new Ea({ value: t }), qQ = (t) => new ca({ value: t }), KQ = (t) => new ha({ value: t }), zQ = (t) => new la({ value: t }), Kn = (t) => new ua({ value: t }), _Q = (t) => new da({ value: t }), zn = (t) => new pa({ value: t });
class gA extends F {
  constructor({
    value: A,
    outType: e,
    outKey: s
  }) {
    super({ a: A, outTypeFunc: () => e, outKey: s }), this.statements = ({ inputs: i, outputs: n }) => [
      `${n[s]} = ${ks(e)}(${i.a});`
    ];
  }
}
class _n extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bool", outKey: "bool" });
  }
}
class On extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "int", outKey: "int" });
  }
}
class Vn extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uint", outKey: "uint" });
  }
}
class Pn extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "float", outKey: "float" });
  }
}
class Zn extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec2", outKey: "bvec2" });
  }
}
class Xn extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec3", outKey: "bvec3" });
  }
}
class Wn extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec4", outKey: "bvec4" });
  }
}
class jn extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec2", outKey: "ivec2" });
  }
}
class $n extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec3", outKey: "ivec3" });
  }
}
class Aa extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec4", outKey: "ivec4" });
  }
}
class ta extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec2", outKey: "uvec2" });
  }
}
class ea extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec3", outKey: "uvec3" });
  }
}
class sa extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec4", outKey: "uvec4" });
  }
}
class ia extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec2", outKey: "vec2" });
  }
}
class na extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec3", outKey: "vec3" });
  }
}
class aa extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec4", outKey: "vec4" });
  }
}
class ra extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat2", outKey: "mat2" });
  }
}
class ga extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat3", outKey: "mat3" });
  }
}
class oa extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat4", outKey: "mat4" });
  }
}
class Ia extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "int", outTypeFunc: () => "int" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.int} = floatBitsToInt(${e.a});`];
  }
}
class Qa extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = floatBitsToUint(${e.a});`];
  }
}
class Ba extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.float} = intBitsToFloat(${e.a});`];
  }
}
class Ca extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.float} = uintBitsToFloat(${e.a});`];
  }
}
class Ea extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = packSnorm2x16(${e.a});`];
  }
}
class ca extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.vec2} = unpackSnorm2x16(${e.a});`];
  }
}
class ha extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = packUnorm2x16(${e.a});`];
  }
}
class la extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.vec2} = unpackUnorm2x16(${e.a});`];
  }
}
class ua extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = packHalf2x16(${e.a});`];
  }
}
class da extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.vec2} = unpackHalf2x16(${e.a});`];
  }
}
class pa extends F {
  constructor({ value: A }) {
    super({ a: A, outKey: "rgba8", outTypeFunc: () => "vec4" }), this.statements = ({ inputs: e, outputs: s }) => [
      `uvec4 uRgba = uvec4(${e.a} & 0xffu, (${e.a} >> 8u) & 0xffu, (${e.a} >> 16u) & 0xffu, (${e.a} >> 24u) & 0xffu);`,
      `${s.rgba8} = vec4(uRgba) / 255.0;`
    ];
  }
}
const OQ = (t) => new fa({ a: t }), VQ = (t, A) => new ma({ a: t, b: A }), ya = (t, A) => new xa({ a: t, b: A }), PQ = (t, A) => new Sa({ a: t, b: A }), wa = (t) => new Ma({ a: t }), ZQ = (t, A, e) => new ka({ a: t, b: A, c: e }), XQ = (t, A) => new Ga({ incident: t, normal: A }), WQ = (t, A, e) => new Ra({ incident: t, normal: A, eta: e }), St = (t) => new Ja({ vector: t }), qA = ({
  vector: t,
  vectorType: A,
  x: e,
  y: s,
  z: i,
  w: n,
  r: a,
  g: r,
  b: g,
  a: I
}) => new Ta({ vector: t, vectorType: A, x: e, y: s, z: i, w: n, r: a, g: r, b: g, a: I }), jQ = (t) => new Fa({ a: t }), Da = (t, A) => new Na({ a: t, b: A }), $Q = (t, A) => new Ha({ vector: t, select: A }), AB = (t, A) => new Ua({ a: t, b: A }), tB = (t, A) => new La({ a: t, b: A }), eB = (t) => new ba({ a: t }), sB = (t) => new va({ a: t }), iB = (t) => new Ya({ a: t });
class fa extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "float", outKey: "length" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.length} = length(${e.a});`
    ];
  }
}
class ma extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "distance", outTypeFunc: (s, i) => "float" }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.distance} = distance(${s.a}, ${s.b});`
    ];
  }
}
class xa extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "dot", outTypeFunc: (s, i) => "float" }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.dot} = dot(${s.a}, ${s.b});`
    ];
  }
}
class Sa extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "cross", outTypeFunc: (s, i) => "vec3" }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.cross} = cross(${s.a}, ${s.b});`
    ];
  }
}
class Ma extends F {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "normalize" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.normalize} = normalize(${e.a});`
    ];
  }
}
function nB(t) {
  if (t === "vec3")
    return "vec2";
  if (t === "vec4")
    return "vec3";
  throw new Error("Invalid type");
}
class Fa extends F {
  constructor({ a: A }) {
    super({
      a: A,
      outTypeFunc: (e) => nB(e),
      outKey: "projected"
    }), this.statements = ({ inputs: e, outputs: s }) => {
      if (this.inTypes.a === "vec3")
        return [`${s.projected} = ${e.a}.xy / ${e.a}.z;`];
      if (this.inTypes.a === "vec4")
        return [`${s.projected} = ${e.a}.xyz / ${e.a}.w;`];
      throw new Error("Invalid type");
    };
  }
}
function aB(t) {
  if (t === "float") return "vec2";
  if (t === "vec2") return "vec3";
  if (t === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class Na extends $ {
  constructor({ a: A, b: e }) {
    const s = _(A), i = aB(s);
    super({ a: A, b: e, outKey: "extend", outTypeFunc: () => i }), this.statements = ({ inputs: n, outputs: a }) => [
      `${a.extend} = ${i}(${n.a}, ${n.b});`
    ];
  }
}
class ka extends ut {
  constructor({ a: A, b: e, c: s }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "forward",
      outTypeFunc: (i, n, a) => i
    }), this.statements = ({ inputs: i, outputs: n }) => [
      `${n.forward} = faceforward(${i.a}, ${i.b}, ${i.c});`
    ];
  }
}
class Ga extends $ {
  constructor({
    incident: A,
    normal: e
  }) {
    super({
      a: A,
      b: e,
      outKey: "reflection",
      outTypeFunc: (s, i) => s
    }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.reflection} = reflect(${s.a}, ${s.b});`
    ];
  }
}
class Ra extends ut {
  constructor({
    incident: A,
    normal: e,
    eta: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "refraction",
      outTypeFunc: (i, n, a) => i
    }), this.statements = ({ inputs: i, outputs: n }) => [
      `${n.refraction} = refract(${i.a}, ${i.b}, ${i.c});`
    ];
  }
}
class Ua extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "product", outTypeFunc: (s, i) => s }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.product} = matrixCompMult(${A}, ${e});`
    ];
  }
}
function rB(t, A) {
  if (t === "vec2") {
    if (A === "vec2") return "mat2";
    if (A === "vec3") return "mat3x2";
    if (A === "vec4") return "mat4x2";
  }
  if (t === "vec3") {
    if (A === "vec2") return "mat2x3";
    if (A === "vec3") return "mat3";
    if (A === "vec4") return "mat4x3";
  }
  if (t === "vec4") {
    if (A === "vec2") return "mat2x4";
    if (A === "vec3") return "mat3x4";
    if (A === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${t}, ${A}`);
}
class La extends $ {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "outer", outTypeFunc: rB }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.outer} = outerProduct(${s.a}, ${s.b});`
    ];
  }
}
function gB(t) {
  if (t === "mat2") return "mat2";
  if (t === "mat3") return "mat3";
  if (t === "mat4") return "mat4";
  if (t === "mat2x2") return "mat2x2";
  if (t === "mat2x3") return "mat3x2";
  if (t === "mat2x4") return "mat4x2";
  if (t === "mat3x2") return "mat2x3";
  if (t === "mat3x3") return "mat3x3";
  if (t === "mat3x4") return "mat4x3";
  if (t === "mat4x2") return "mat2x4";
  if (t === "mat4x3") return "mat3x4";
  if (t === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${t}`);
}
class ba extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "transpose", outTypeFunc: gB }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.transpose} = transpose(${e.a});`
    ];
  }
}
class va extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "det", outTypeFunc: (e) => "float" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.det} = determinant(${e.a});`
    ];
  }
}
class Ya extends F {
  constructor({ a: A }) {
    super({ a: A, outKey: "inverse", outTypeFunc: (e) => e }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.inverse} = inverse(${A});`
    ];
  }
}
function oB(t) {
  const A = (e) => e;
  switch (t) {
    case "vec2":
      return A({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return A({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return A({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return A({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return A({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return A({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return A({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
class Ja extends O {
  constructor({ vector: A }) {
    const s = { vector: _(A) }, i = oB(s.vector);
    super({ inTypes: s, outTypes: i, inputs: { vector: A } }), this.statements = ({ inputs: n, outputs: a }) => {
      const { x: r, y: g, z: I, w: Q, r: o, g: C, b: E, a: l } = a, { vector: c } = n;
      return [
        r ? `${r} = ${c}.x;` : null,
        g ? `${g} = ${c}.y;` : null,
        I ? `${I} = ${c}.z;` : null,
        Q ? `${Q} = ${c}.w;` : null,
        o ? `${o} = ${c}.r;` : null,
        C ? `${C} = ${c}.g;` : null,
        E ? `${E} = ${c}.b;` : null,
        l ? `${l} = ${c}.a;` : null
      ].filter(Boolean);
    };
  }
}
class Ta extends O {
  constructor({
    vector: A,
    vectorType: e,
    x: s,
    y: i,
    z: n,
    w: a,
    r,
    g,
    b: I,
    a: Q
  }) {
    if (!A && !e)
      throw new Error("Either vector or vectorType must be provided");
    const o = e ?? _(A), C = Ms(o), E = Fs(o), l = {
      vector: o,
      x: C,
      y: C,
      r: C,
      g: C
    }, c = { vector: A, x: s, y: i, r, g };
    E >= 3 && (Object.assign(l, { z: C, b: C }), Object.assign(c, { z: n, b: I })), E >= 4 && (Object.assign(l, { w: C, a: C }), Object.assign(c, { w: a, a: Q })), super({ inTypes: l, outTypes: { vector: o }, inputs: c }), this.statements = ({ inputs: h, outputs: u }) => {
      const { vector: p } = u, {
        vector: d,
        x: y,
        y: D,
        z: S,
        w: m,
        r: f,
        g: w,
        b: R,
        a: M
      } = h, x = [
        `${p}.x = ${y ?? f ?? (d ? `${d}.x` : bt(C))};`,
        `${p}.y = ${D ?? w ?? (d ? `${d}.y` : bt(C))};`
      ];
      return E >= 3 && x.push(
        `${p}.z = ${S ?? R ?? (d ? `${d}.z` : bt(C))};`
      ), E >= 4 && x.push(
        `${p}.w = ${m ?? M ?? (d ? `${d}.w` : bt(C))};`
      ), x;
    };
  }
  dynoOut() {
    return new K(
      this,
      "vector"
    );
  }
}
function IB(t, A) {
  let e = null;
  if (_t(t) ? e = A.length === 1 ? "float" : A.length === 2 ? "vec2" : A.length === 3 ? "vec3" : A.length === 4 ? "vec4" : null : hA(t) ? e = A.length === 1 ? "int" : A.length === 2 ? "ivec2" : A.length === 3 ? "ivec3" : A.length === 4 ? "ivec4" : null : lA(t) && (e = A.length === 1 ? "uint" : A.length === 2 ? "uvec2" : A.length === 3 ? "uvec3" : A.length === 4 ? "uvec4" : null), e == null)
    throw new Error(`Invalid swizzle: ${A}`);
  return e;
}
class Ha extends F {
  constructor({ vector: A, select: e }) {
    super({
      a: A,
      outKey: "swizzle",
      outTypeFunc: (s) => IB(s, e)
    }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.swizzle} = ${s.a}.${e};`
    ];
  }
}
const QB = (t, A, e) => new Pa({ index: t, from: A, to: e }), BB = (t) => new Gt({ value: t }), CB = (t) => new GA({ state: t }), EB = (t) => new RA({ state: t }), qa = (t) => new Za({ value: t }), Ka = (t) => new Xa({ value: t }), za = (t) => new Wa({ value: t }), _a = (t) => new ja({ value: t }), cB = (t) => new $a({ value: t }), hB = (t) => new Ar({ value: t }), Oa = (t) => new tr({ value: t }), ve = (t) => new er({ value: t }), Va = (t, A, e) => new sr({ z: t, zNear: A, zFar: e }).outputs.depth;
class Pa extends O {
  constructor({
    from: A,
    to: e,
    index: s
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from: A, to: e, index: s },
      statements: ({ inputs: i, outputs: n }) => [
        `${n.index} = ${i.index} - ${i.from} + ${i.to};`
      ]
    });
  }
  dynoOut() {
    return new K(this, "index");
  }
}
class GA extends O {
  constructor({ state: A }) {
    const e = _(A);
    super({
      inTypes: { state: e },
      outTypes: { state: "uint" },
      inputs: { state: A },
      globals: () => [
        EA(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs: s, outputs: i }) => {
        const n = e === "uint" ? `${s.state}` : e === "int" ? `uint(${s.state})` : `floatBitsToUint(${s.state})`;
        return [`${i.state} = pcg_next(${n});`];
      }
    });
  }
  dynoOut() {
    return new K(this, "state");
  }
}
class RA extends O {
  constructor({ state: A }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state: A },
      globals: () => [
        EA(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs: e, outputs: s }) => [
        `${s.hash} = pcg_hash(${e.state});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Gt extends O {
  constructor({ value: A }) {
    const e = _(A), s = Ns(e);
    super({
      inTypes: { value: e },
      outTypes: { state: "uint" },
      inputs: { value: A },
      globals: () => [
        EA(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs: i, outputs: n }) => {
        const a = lA(e) ? `${i.value}` : hA(e) ? `${s}(${i.value})` : `floatBitsToUint(${i.value})`;
        return [
          `${s} bits = ${a};`,
          `${n.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new K(this, "state");
  }
}
class Za extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "uint" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Gt({ value: e }).outputs.state;
        return s = new GA({ state: s }).outputs.state, new RA({ state: s }).outputs;
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Xa extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "uvec2" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Gt({ value: e }).outputs.state;
        s = new GA({ state: s }).outputs.state;
        const i = new RA({ state: s }).outputs.hash;
        s = new GA({ state: s }).outputs.state;
        const n = new RA({ state: s }).outputs.hash;
        return { hash: qA({ vectorType: "uvec2", x: i, y: n }) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Wa extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "uvec3" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Gt({ value: e }).outputs.state;
        s = new GA({ state: s }).outputs.state;
        const i = new RA({ state: s }).outputs.hash;
        s = new GA({ state: s }).outputs.state;
        const n = new RA({ state: s }).outputs.hash;
        s = new GA({ state: s }).outputs.state;
        const a = new RA({ state: s }).outputs.hash;
        return { hash: qA({ vectorType: "uvec3", x: i, y: n, z: a }) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class ja extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "uvec4" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Gt({ value: e }).outputs.state;
        s = new GA({ state: s }).outputs.state;
        const i = new RA({ state: s }).outputs.hash;
        s = new GA({ state: s }).outputs.state;
        const n = new RA({ state: s }).outputs.hash;
        s = new GA({ state: s }).outputs.state;
        const a = new RA({ state: s }).outputs.hash;
        s = new GA({ state: s }).outputs.state;
        const r = new RA({ state: s }).outputs.hash;
        return { hash: qA({ vectorType: "uvec4", x: i, y: n, z: a, w: r }) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class $a extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "float" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = qa(e);
        return { hash: BA(Jn(s), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Ar extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "vec2" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = Ka(e);
        return { hash: BA(Tn(s), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class tr extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "vec3" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = za(e);
        return { hash: BA(ct(s), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class er extends zA {
  constructor({ value: A }) {
    super({
      inTypes: { value: _(A) },
      outTypes: { hash: "vec4" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = _a(e);
        return { hash: BA(Hn(s), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class sr extends O {
  constructor({
    z: A,
    zNear: e,
    zFar: s
  }) {
    super({
      inTypes: { z: "float", zNear: "float", zFar: "float" },
      outTypes: { depth: "float" },
      inputs: { z: A, zNear: e, zFar: s },
      statements: ({ inputs: i, outputs: n }) => [
        `float clamped = clamp(${i.z}, ${i.zNear}, ${i.zFar});`,
        `${n.depth} = (log2(clamped + 1.0) - log2(${i.zNear} + 1.0)) / (log2(${i.zFar} + 1.0) - log2(${i.zNear} + 1.0));`
      ]
    });
  }
  dynoOut() {
    return new K(this, "depth");
  }
}
const ir = (t, {
  scale: A,
  scales: e,
  rotate: s,
  translate: i
}) => new ar({ position: t, scale: A, scales: e, rotate: s, translate: i }).outputs.position, nr = (t, {
  scale: A,
  scales: e,
  rotate: s
}) => new rr({ dir: t, scale: A, scales: e, rotate: s }).outputs.dir, lB = (t, { rotate: A }) => new gr({ quaternion: t, rotate: A }).outputs.quaternion;
class ar extends O {
  constructor({
    position: A,
    scale: e,
    scales: s,
    rotate: i,
    translate: n
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position: A, scale: e, scales: s, rotate: i, translate: n },
      statements: ({ inputs: a, outputs: r }) => {
        const { position: g } = r;
        if (!g)
          return [];
        const { scale: I, scales: Q, rotate: o, translate: C } = a;
        return [
          `${g} = ${a.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          I ? `${g} *= ${I};` : null,
          Q ? `${g} *= ${Q};` : null,
          o ? `${g} = quatVec(${o}, ${g});` : null,
          C ? `${g} += ${C};` : null
        ].filter(Boolean);
      }
    });
  }
}
class rr extends O {
  constructor({
    dir: A,
    scale: e,
    scales: s,
    rotate: i
  }) {
    super({
      inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { dir: "vec3" },
      inputs: { dir: A, scale: e, scales: s, rotate: i },
      statements: ({ inputs: n, outputs: a }) => {
        const { dir: r } = a;
        if (!r)
          return [];
        const { scale: g, scales: I, rotate: Q } = n;
        return [
          `${r} = ${n.dir ?? "vec3(0.0, 0.0, 0.0)"};`,
          g ? `${r} *= ${g};` : null,
          I ? `${r} *= ${I};` : null,
          Q ? `${r} = quatVec(${Q}, ${r});` : null
        ].filter(Boolean);
      }
    });
  }
}
class gr extends O {
  constructor({
    quaternion: A,
    rotate: e
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion: A, rotate: e },
      statements: ({ inputs: s, outputs: i }) => {
        const { quaternion: n } = i;
        return n ? [
          `${n} = ${s.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          e ? `${n} = quatQuat(${s.rotate}, ${n});` : null
        ].filter(Boolean) : [];
      }
    });
  }
}
const uB = () => {
  throw new Error("Not implemented");
}, dB = () => {
  throw new Error("Not implemented");
}, pB = () => {
  throw new Error("Not implemented");
}, yB = () => {
  throw new Error("Not implemented");
}, wB = () => {
  throw new Error("Not implemented");
}, DB = () => {
  throw new Error("Not implemented");
}, fB = (t, A) => new or({ texture: t, lod: A }), mB = (t, A, e) => new Ir({ texture: t, coord: A, bias: e }), xB = (t, A, e) => new Qr({ texture: t, coord: A, lod: e });
class or extends O {
  constructor({ texture: A, lod: e }) {
    const s = _(A);
    super({
      inTypes: { texture: s, lod: "int" },
      outTypes: { size: Br(s) },
      inputs: { texture: A, lod: e },
      statements: ({ inputs: i, outputs: n }) => [
        `${n.size} = textureSize(${i.texture}, ${i.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "size");
  }
}
class Ir extends O {
  constructor({
    texture: A,
    coord: e,
    bias: s
  }) {
    const i = _(A);
    super({
      inTypes: {
        texture: i,
        coord: SB(i),
        bias: "float"
      },
      outTypes: { sample: Cr(i) },
      inputs: { texture: A, coord: e, bias: s },
      statements: ({ inputs: n, outputs: a }) => [
        `${a.sample} = texture(${n.texture}, ${n.coord}${n.bias ? `, ${n.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "sample");
  }
}
class Qr extends O {
  constructor({
    texture: A,
    coord: e,
    lod: s
  }) {
    const i = _(A);
    super({
      inTypes: {
        texture: i,
        coord: Br(i),
        lod: "int"
      },
      outTypes: { texel: Cr(i) },
      inputs: { texture: A, coord: e, lod: s },
      statements: ({ inputs: n, outputs: a }) => [
        `${a.texel} = texelFetch(${n.texture}, ${n.coord}, ${n.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "texel");
  }
}
function Br(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function SB(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function Cr(t) {
  switch (t) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
const MB = (t) => new Er({ degrees: t }), FB = (t) => new cr({ radians: t }), Ye = (t) => new hr({ radians: t }), NB = (t) => new lr({ radians: t }), kB = (t) => new ur({ radians: t }), GB = (t) => new dr({ sin: t }), RB = (t) => new pr({ cos: t }), UB = (t) => new yr({ tan: t }), LB = (t, A) => new wr({ y: t, x: A }), bB = (t) => new Dr({ x: t }), vB = (t) => new fr({ x: t }), YB = (t) => new mr({ x: t }), JB = (t) => new xr({ x: t }), TB = (t) => new Sr({ x: t }), HB = (t) => new Mr({ x: t });
class Er extends F {
  constructor({ degrees: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "radians" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.radians} = radians(${e.a});`
    ];
  }
}
class cr extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "degrees" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.degrees} = degrees(${e.a});`
    ];
  }
}
class hr extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "sin" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.sin} = sin(${e.a});`
    ];
  }
}
class lr extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "cos" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.cos} = cos(${e.a});`
    ];
  }
}
class ur extends F {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "tan" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.tan} = tan(${e.a});`
    ];
  }
}
class dr extends F {
  constructor({ sin: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "asin" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.asin} = asin(${e.a});`
    ];
  }
}
class pr extends F {
  constructor({ cos: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "acos" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.acos} = acos(${e.a});`
    ];
  }
}
class yr extends F {
  constructor({ tan: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "atan" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.atan} = atan(${e.a});`
    ];
  }
}
class wr extends $ {
  constructor({ y: A, x: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, i) => s,
      outKey: "atan2"
    }), this.statements = ({ inputs: s, outputs: i }) => [
      `${i.atan2} = atan2(${s.a}, ${s.b});`
    ];
  }
}
class Dr extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "sinh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.sinh} = sinh(${e.a});`
    ];
  }
}
class fr extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "cosh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.cosh} = cosh(${e.a});`
    ];
  }
}
class mr extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "tanh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.tanh} = tanh(${e.a});`
    ];
  }
}
class xr extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "asinh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.asinh} = asinh(${e.a});`
    ];
  }
}
class Sr extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "acosh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.acosh} = acosh(${e.a});`
    ];
  }
}
class Mr extends F {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "atanh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.atanh} = atanh(${e.a});`
    ];
  }
}
const BE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: $i,
  Acos: pr,
  Acosh: Sr,
  Add: _i,
  All: Ln,
  And: fn,
  Any: Un,
  Asin: dr,
  Asinh: xr,
  Atan: yr,
  Atan2: wr,
  Atanh: Mr,
  BVec2: Zn,
  BVec3: Xn,
  BVec4: Wn,
  BinaryOp: $,
  Bool: _n,
  Ceil: en,
  Clamp: ln,
  Combine: Ta,
  CombineGsplat: Ts,
  CompMult: Ua,
  CompXor: Yn,
  Compilation: Rs,
  Cos: lr,
  Cosh: fr,
  Cross: Sa,
  Degrees: cr,
  Determinant: va,
  Distance: ma,
  Div: Pi,
  Dot: xa,
  Dyno: O,
  DynoBlock: zA,
  DynoBool: re,
  DynoBvec2: Vs,
  DynoBvec3: Ws,
  DynoBvec4: Ai,
  DynoConst: Gs,
  DynoFloat: Ct,
  DynoInt: qt,
  DynoIsampler2D: hi,
  DynoIsampler2DArray: ui,
  DynoIsampler3D: yi,
  DynoIsamplerCube: fi,
  DynoIvec2: Zs,
  DynoIvec3: $s,
  DynoIvec4: ei,
  DynoLiteral: xt,
  DynoMat2: si,
  DynoMat2x2: ii,
  DynoMat2x3: ni,
  DynoMat2x4: ai,
  DynoMat3: ri,
  DynoMat3x2: gi,
  DynoMat3x3: oi,
  DynoMat3x4: Ii,
  DynoMat4: Qi,
  DynoMat4x2: Bi,
  DynoMat4x3: Ci,
  DynoMat4x4: Ei,
  DynoOutput: K,
  DynoProgram: Ze,
  DynoProgramTemplate: Xe,
  DynoRemapIndex: Pa,
  DynoSampler2D: li,
  DynoSampler2DArray: di,
  DynoSampler2DArrayShadow: Si,
  DynoSampler2DShadow: xi,
  DynoSampler3D: wi,
  DynoSamplerCube: mi,
  DynoSamplerCubeShadow: Mi,
  DynoUint: Os,
  DynoUniform: G,
  DynoUsampler2D: ci,
  DynoUsampler2DArray: Jt,
  DynoUsampler3D: pi,
  DynoUsamplerCube: Di,
  DynoUvec2: Ps,
  DynoUvec3: js,
  DynoUvec4: ti,
  DynoValue: nt,
  DynoVec2: Xs,
  DynoVec3: Mt,
  DynoVec4: Zt,
  Equal: Gn,
  Exp: gn,
  Exp2: on,
  ExtendVec: Na,
  FaceForward: ka,
  Float: Pn,
  FloatBitsToInt: Ia,
  FloatBitsToUint: Qa,
  Floor: tn,
  Fract: an,
  GreaterThan: Nn,
  GreaterThanEqual: kn,
  Gsplat: j,
  GsplatNormal: qs,
  Hash: Za,
  Hash2: Xa,
  Hash3: Wa,
  Hash4: ja,
  HashFloat: $a,
  HashVec2: Ar,
  HashVec3: tr,
  HashVec4: er,
  IMod: Zi,
  IVec2: jn,
  IVec3: $n,
  IVec4: Aa,
  Int: On,
  IntBitsToFloat: Ba,
  Inverse: Ya,
  InverseSqrt: En,
  IsInf: wn,
  IsNan: yn,
  Length: fa,
  LessThan: Mn,
  LessThanEqual: Fn,
  Log: In,
  Log2: Qn,
  Mat2: ra,
  Mat3: ga,
  Mat4: oa,
  Max: hn,
  Min: cn,
  Mix: un,
  Mod: Xi,
  Modf: Wi,
  Mul: Vi,
  Neg: ji,
  Normalize: Ma,
  NormalizedDepth: sr,
  Not: Sn,
  NotEqual: Rn,
  NumPackedSplats: Ls,
  Or: mn,
  Outer: La,
  OutputPackedSplat: _s,
  OutputRgba8: Ve,
  PackHalf2x16: ua,
  PackSnorm2x16: Ea,
  PackUnorm2x16: ha,
  PcgHash: RA,
  PcgMix: Gt,
  PcgNext: GA,
  Pow: rn,
  ProjectH: Fa,
  Radians: Er,
  ReadPackedSplat: vs,
  ReadPackedSplatRange: Ys,
  ReflectVec: Ga,
  RefractVec: Ra,
  Round: nn,
  Select: bn,
  Sign: An,
  SimpleCast: gA,
  Sin: hr,
  Sinh: Dr,
  Smoothstep: pn,
  Split: Ja,
  SplitGsplat: Js,
  Sqr: Bn,
  Sqrt: Cn,
  Step: dn,
  Sub: Oi,
  Swizzle: Ha,
  TPackedSplats: Pt,
  Tan: ur,
  Tanh: mr,
  TexelFetch: Qr,
  Texture: Ir,
  TextureSize: or,
  TransformDir: rr,
  TransformGsplat: Ks,
  TransformPosition: ar,
  TransformQuaternion: gr,
  Transpose: ba,
  TrinaryOp: ut,
  Trunc: sn,
  UVec2: ta,
  UVec3: ea,
  UVec4: sa,
  Uint: Vn,
  UintBitsToFloat: Ca,
  UintToRgba8: pa,
  UnaryOp: F,
  UnpackHalf2x16: da,
  UnpackSnorm2x16: ca,
  UnpackUnorm2x16: la,
  Vec2: ia,
  Vec3: na,
  Vec4: aa,
  Xor: xn,
  abs: KI,
  acos: RB,
  acosh: TB,
  add: fA,
  all: dQ,
  and: oQ,
  any: uQ,
  arrayIndex: wB,
  arrayLength: DB,
  asin: GB,
  asinh: JB,
  atan: UB,
  atan2: LB,
  atanh: HB,
  bool: DQ,
  bvec2: xQ,
  bvec3: SQ,
  bvec4: MQ,
  ceil: OI,
  clamp: iQ,
  combine: qA,
  combineGsplat: at,
  comment: yB,
  compMult: AB,
  compXor: pQ,
  cos: NB,
  cosh: vB,
  cross: PQ,
  defineGsplat: FA,
  defineGsplatNormal: Hs,
  definePackedSplats: he,
  degrees: FB,
  determinant: sB,
  distance: VQ,
  div: ie,
  dot: ya,
  dyno: Vt,
  dynoBlock: kA,
  dynoBool: zg,
  dynoBvec2: Vg,
  dynoBvec3: Wg,
  dynoBvec4: Ao,
  dynoConst: q,
  dynoDeclare: _e,
  dynoFloat: JA,
  dynoFor: pB,
  dynoIf: uB,
  dynoInt: Og,
  dynoIsampler2D: lo,
  dynoIsampler2DArray: yo,
  dynoIsampler3D: fo,
  dynoIsamplerCube: So,
  dynoIvec2: Zg,
  dynoIvec3: $g,
  dynoIvec4: eo,
  dynoLiteral: ae,
  dynoMat2: io,
  dynoMat2x2: no,
  dynoMat2x3: ao,
  dynoMat2x4: ro,
  dynoMat3: go,
  dynoMat3x2: oo,
  dynoMat3x3: Io,
  dynoMat3x4: Qo,
  dynoMat4: Bo,
  dynoMat4x2: Co,
  dynoMat4x3: Eo,
  dynoMat4x4: co,
  dynoSampler2D: uo,
  dynoSampler2DArray: wo,
  dynoSampler2DArrayShadow: No,
  dynoSampler2DShadow: Fo,
  dynoSampler3D: mo,
  dynoSamplerCube: Mo,
  dynoSamplerCubeShadow: ko,
  dynoSwitch: dB,
  dynoUint: _g,
  dynoUsampler2D: ho,
  dynoUsampler2DArray: po,
  dynoUsampler3D: Do,
  dynoUsamplerCube: xo,
  dynoUvec2: Pg,
  dynoUvec3: jg,
  dynoUvec4: to,
  dynoVec2: Xg,
  dynoVec3: At,
  dynoVec4: so,
  equal: hQ,
  exp: XI,
  exp2: WI,
  extendVec: Da,
  faceforward: ZQ,
  float: Jn,
  floatBitsToInt: qn,
  floatBitsToUint: YQ,
  floor: _I,
  fract: ne,
  greaterThan: cQ,
  greaterThanEqual: Dn,
  gsplatNormal: Re,
  hash: qa,
  hash2: Ka,
  hash3: za,
  hash4: _a,
  hashFloat: cB,
  hashVec2: hB,
  hashVec3: Oa,
  hashVec4: ve,
  imod: be,
  int: fQ,
  intBitsToFloat: JQ,
  inverse: iB,
  inversesqrt: eQ,
  isAllFloatType: rt,
  isBoolType: ht,
  isFloatType: _t,
  isInf: gQ,
  isIntType: hA,
  isMat2: gt,
  isMat3: ot,
  isMat4: It,
  isMatFloatType: Ss,
  isNan: rQ,
  isScalarType: lt,
  isUintType: lA,
  isVector2Type: Nt,
  isVector3Type: kt,
  isVector4Type: Ot,
  isVectorType: bg,
  ivec2: FQ,
  ivec3: NQ,
  ivec4: kQ,
  length: OQ,
  lessThan: CQ,
  lessThanEqual: EQ,
  literalNegOne: Tg,
  literalOne: Jg,
  literalZero: bt,
  log: jI,
  log2: $I,
  mat2: LQ,
  mat3: bQ,
  mat4: vQ,
  max: Ki,
  min: sQ,
  mix: zi,
  mod: qi,
  modf: qI,
  mul: BA,
  neg: je,
  normalize: wa,
  normalizedDepth: Va,
  not: BQ,
  notEqual: lQ,
  numPackedSplats: Hg,
  numberAsFloat: H,
  numberAsInt: nA,
  numberAsUint: aA,
  or: IQ,
  outer: tB,
  outputPackedSplat: zs,
  outputRgba8: qg,
  packHalf2x16: Kn,
  packSnorm2x16: HQ,
  packUnorm2x16: KQ,
  pcgHash: EB,
  pcgMix: BB,
  pcgNext: CB,
  pow: ZI,
  projectH: jQ,
  radians: MB,
  readPackedSplat: Ht,
  readPackedSplatRange: Us,
  reflectVec: XQ,
  refractVec: WQ,
  remapIndex: QB,
  round: PI,
  sameSizeIvec: Yg,
  sameSizeUvec: Ns,
  sameSizeVec: vg,
  select: $e,
  sign: zI,
  sin: Ye,
  sinh: bB,
  smoothstep: aQ,
  split: St,
  splitGsplat: Bt,
  sqr: AQ,
  sqrt: tQ,
  step: nQ,
  sub: Ft,
  swizzle: $Q,
  tan: kB,
  tanh: YB,
  texelFetch: xB,
  texture: mB,
  textureSize: fB,
  transformDir: nr,
  transformGsplat: Oe,
  transformPos: ir,
  transformQuat: lB,
  transpose: eB,
  trunc: VI,
  typeLiteral: ks,
  uint: mQ,
  uintBitsToFloat: TQ,
  uintToRgba8: zn,
  uniform: Kg,
  unindent: EA,
  unindentLines: UA,
  unpackHalf2x16: _Q,
  unpackSnorm2x16: qQ,
  unpackUnorm2x16: zQ,
  uvec2: GQ,
  uvec3: RQ,
  uvec4: UQ,
  valType: _,
  vec2: Tn,
  vec3: ct,
  vec4: Hn,
  vectorDim: Fs,
  vectorElementType: Ms,
  xor: QQ
}, Symbol.toStringTag, { value: "Module" }));
var qB = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;
const IA = class IA {
  constructor({ renderer: A } = {}) {
    this.renderer = A, this.capacity = 0, this.count = 0;
  }
  dispose() {
    this.target && (this.target.dispose(), this.target = void 0);
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  ensureBuffer(A, e) {
    const i = Math.ceil(Math.max(1, A) / W) * W * 4;
    if (e.byteLength >= i)
      return e;
    const n = new ArrayBuffer(i);
    if (e instanceof ArrayBuffer)
      return n;
    const a = e.constructor;
    return new a(n);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(A) {
    const { width: e, height: s, depth: i, maxSplats: n } = mA(A);
    (!this.target || n > this.capacity) && (this.dispose(), this.capacity = n, this.target = new B.WebGLArrayRenderTarget(e, s, i, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: B.NearestFilter,
      minFilter: B.NearestFilter
    }), this.target.texture.format = B.RGBAFormat, this.target.texture.type = B.UnsignedByteType, this.target.texture.internalFormat = "RGBA8", this.target.scissorTest = !0);
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let e = IA.readbackProgram.get(A);
    if (!e) {
      const i = kA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: n }) => (A.inputs.index = n, { rgba8: new Ve({ rgba8: A.outputs.rgba8 }) })
      );
      IA.programTemplate || (IA.programTemplate = new Xe(qB)), e = new Ze({
        graph: i,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: IA.programTemplate
      }), Object.assign(e.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), IA.readbackProgram.set(A, e);
    }
    const s = e.prepareMaterial();
    return IA.mesh.material = s, { program: e, material: s };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, e) {
    A.setRenderTarget(null), A.xr.enabled = e.xrEnabled, A.autoClear = e.autoClear;
  }
  process({
    count: A,
    material: e
  }) {
    const s = this.renderer;
    if (!s)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const i = W * it;
    e.uniforms.targetBase.value = 0, e.uniforms.targetCount.value = A;
    let n = 0;
    for (; n < A; ) {
      const a = Math.floor(n / i), r = a * i, g = Math.min(
        it,
        Math.ceil((A - r) / W)
      );
      e.uniforms.targetLayer.value = a, this.target.scissor.set(0, 0, W, g), s.setRenderTarget(this.target, a), s.xr.enabled = !1, s.autoClear = !1, s.render(IA.scene, IA.camera), n += W * g;
    }
    this.count = A;
  }
  async read({
    readback: A
  }) {
    const e = this.renderer;
    if (!e)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const s = Math.ceil(this.count / W) * W;
    if (A.byteLength < s * 4)
      throw new Error(
        `Readback buffer too small: ${A.byteLength} < ${s * 4}`
      );
    const i = new Uint8Array(
      A instanceof ArrayBuffer ? A : A.buffer
    ), n = W * it;
    let a = 0;
    const r = [];
    for (; a < this.count; ) {
      const g = Math.floor(a / n), I = g * n, Q = Math.min(
        it,
        Math.ceil((this.count - I) / W)
      );
      e.setRenderTarget(this.target, g);
      const o = W * Q * 4, C = i.subarray(
        I * 4,
        I * 4 + o
      ), E = e == null ? void 0 : e.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        W,
        Q,
        C
      );
      r.push(E), a += W * Q;
    }
    return Promise.all(r).then(() => A);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader: A,
    count: e,
    renderer: s
  }) {
    if (this.renderer = s || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(e);
    const { program: i, material: n } = this.prepareProgramMaterial(A);
    i.update();
    const a = this.saveRenderState(this.renderer);
    this.process({ count: e, material: n }), this.resetRenderState(this.renderer, a);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback: A
  }) {
    if (!this.renderer)
      throw new Error("No renderer");
    const e = this.saveRenderState(this.renderer), s = this.read({ readback: A });
    return this.resetRenderState(this.renderer, e), s;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader: A,
    count: e,
    renderer: s,
    readback: i
  }) {
    if (this.renderer = s || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(e);
    const { program: n, material: a } = this.prepareProgramMaterial(A);
    n.update();
    const r = this.saveRenderState(this.renderer);
    this.process({ count: e, material: a });
    const g = this.read({ readback: i });
    return this.resetRenderState(this.renderer, r), g;
  }
  getTexture() {
    var A;
    return (A = this.target) == null ? void 0 : A.texture;
  }
};
IA.programTemplate = null, IA.readbackProgram = /* @__PURE__ */ new Map(), IA.geometry = new B.PlaneGeometry(2, 2), IA.mesh = new B.Mesh(
  IA.geometry,
  new B.RawShaderMaterial({ visible: !1 })
), IA.scene = new B.Scene().add(IA.mesh), IA.camera = new B.Camera();
let oe = IA;
const QA = class QA {
  constructor(A = {}) {
    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new G({
      key: "rgbaArray",
      type: Fr,
      globals: () => [Nr],
      value: {
        texture: QA.getEmpty(),
        count: 0
      },
      update: (e) => {
        var s;
        return e.texture = ((s = this.readback) == null ? void 0 : s.getTexture()) ?? this.source ?? QA.getEmpty(), e.count = this.count, e;
      }
    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / W) * W, this.count = Math.min(
      this.capacity,
      A.count ?? Number.POSITIVE_INFINITY
    )) : (this.capacity = A.capacity ?? 0, this.count = 0);
  }
  // Free up resources
  dispose() {
    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(A) {
    var e;
    if (!this.array || A > (((e = this.array) == null ? void 0 : e.length) ?? 0) / 4) {
      this.capacity = mA(A).maxSplats;
      const s = new Uint8Array(this.capacity * 4);
      this.array && s.set(this.array), this.array = s;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var e;
    let A = (e = this.readback) == null ? void 0 : e.getTexture();
    return (this.source || this.array) && (A = this.maybeUpdateSource()), A ?? QA.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array)
      throw new Error("No array");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: e, depth: s } = this.source.image;
        this.capacity !== A * e * s && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));
      else {
        const { width: A, height: e, depth: s } = mA(this.capacity);
        this.source = new B.DataArrayTexture(
          this.array,
          A,
          e,
          s
        ), this.source.format = B.RGBAFormat, this.source.type = B.UnsignedByteType, this.source.internalFormat = "RGBA8", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader: A,
    count: e,
    renderer: s
  }) {
    this.readback || (this.readback = new oe({ renderer: s })), this.readback.render({ reader: A, count: e, renderer: s }), this.capacity = this.readback.capacity, this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats: A,
    base: e,
    count: s,
    renderer: i
  }) {
    const { dynoSplats: n, dynoBase: a, dynoCount: r, reader: g } = QA.makeDynos();
    return n.packedSplats = A, a.value = e, r.value = s, this.render({ reader: g, count: s, renderer: i }), this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback)
      throw new Error("No readback");
    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!QA.emptySource) {
      const A = new Uint8Array(4);
      QA.emptySource = new B.DataArrayTexture(A, 1, 1, 1), QA.emptySource.format = B.RGBAFormat, QA.emptySource.type = B.UnsignedByteType, QA.emptySource.internalFormat = "RGBA8", QA.emptySource.needsUpdate = !0;
    }
    return QA.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!QA.dynos) {
      const A = new ts(), e = new qt({ value: 0 }), s = new qt({ value: 0 }), i = kA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: n }) => {
          if (!n)
            throw new Error("index is undefined");
          n = fA(n, e);
          const a = Us(
            A,
            n,
            e,
            s
          );
          return { rgba8: Bt(a).outputs.rgba };
        }
      );
      QA.dynos = { dynoSplats: A, dynoBase: e, dynoCount: s, reader: i };
    }
    return QA.dynos;
  }
};
QA.emptySource = null, QA.dynos = null;
let Je = QA;
const Fr = { type: "RgbaArray" }, Nr = EA(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function KB(t, A) {
  return new O({
    inTypes: { rgba: Fr, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba: t, index: A },
    globals: () => [Nr],
    statements: ({ inputs: s, outputs: i }) => UA(`
        if ((index >= 0) && (index < ${s.rgba}.count)) {
          ${i.rgba} = texelFetch(${s.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${i.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  }).outputs.rgba;
}
var zB = /* @__PURE__ */ ((t) => (t.ALL = "all", t.PLANE = "plane", t.SPHERE = "sphere", t.BOX = "box", t.ELLIPSOID = "ellipsoid", t.CYLINDER = "cylinder", t.CAPSULE = "capsule", t.INFINITE_CONE = "infinite_cone", t))(zB || {});
function _B(t) {
  switch (t) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${t}`);
  }
}
var OB = /* @__PURE__ */ ((t) => (t.MULTIPLY = "multiply", t.SET_RGB = "set_rgb", t.ADD_RGBA = "add_rgba", t))(OB || {});
function VB(t) {
  switch (t) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${t}`);
  }
}
class PB extends B.Object3D {
  constructor(A = {}) {
    super();
    const { type: e, invert: s, opacity: i, color: n, displace: a, radius: r } = A;
    this.type = e ?? "sphere", this.invert = s ?? !1, this.opacity = i ?? 1, this.color = n ?? new B.Color(1, 1, 1), this.displace = a ?? new B.Vector3(0, 0, 0), this.radius = r ?? 0;
  }
}
const ce = class ce extends B.Object3D {
  constructor(A = {}) {
    const {
      name: e,
      rgbaBlendMode: s = "multiply",
      sdfSmooth: i = 0,
      softEdge: n = 0,
      invert: a = !1,
      sdfs: r = null
    } = A;
    super(), this.rgbaBlendMode = s, this.sdfSmooth = i, this.softEdge = n, this.invert = a, this.sdfs = r, this.ordering = ce.nextOrdering++, this.name = e ?? `Edit ${this.ordering}`;
  }
  addSdf(A) {
    this.sdfs == null && (this.sdfs = []), this.sdfs.includes(A) || this.sdfs.push(A);
  }
  removeSdf(A) {
    this.sdfs != null && (this.sdfs = this.sdfs.filter((e) => e !== A));
  }
};
ce.nextOrdering = 1;
let Ie = ce;
class ZB {
  constructor({ maxSdfs: A, maxEdits: e }) {
    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new G({
      key: "sdfArray",
      type: kr,
      globals: () => [Gr],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (s) => (s.numSdfs = this.numSdfs, s.sdfTexture = this.sdfTexture, s)
    }), this.maxEdits = Math.max(16, e ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new qt({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(A, e) {
    const s = new B.DataTexture(
      A,
      8,
      e,
      B.RGBAIntegerFormat,
      B.UnsignedIntType
    );
    return s.internalFormat = "RGBA32UI", s.needsUpdate = !0, s;
  }
  newEdits(A, e) {
    return new G({
      key: "edits",
      type: "uvec4",
      count: e,
      globals: () => [Rr],
      value: A
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs: A,
    maxEdits: e
  }) {
    let s = !1;
    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), e > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, e), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), s = !0), s;
  }
  updateEditData(A, e) {
    const s = this.editData[A] !== e;
    return this.editData[A] = e, s;
  }
  updateEditFloatData(A, e) {
    dt[0] = e;
    const s = this.editFloatData[A] !== dt[0];
    return s && (this.editFloatData[A] = dt[0]), s;
  }
  encodeEdit(A, {
    sdfFirst: e,
    sdfCount: s,
    invert: i,
    rgbaBlendMode: n,
    softEdge: a,
    sdfSmooth: r
  }) {
    const g = A * 4;
    let I = !1;
    return I = this.updateEditData(g + 0, n | (i ? 256 : 0)) || I, I = this.updateEditData(g + 1, e | s << 16) || I, I = this.updateEditFloatData(g + 2, a) || I, I = this.updateEditFloatData(g + 3, r) || I, I;
  }
  updateSdfData(A, e) {
    const s = this.sdfData[A] !== e;
    return this.sdfData[A] = e, s;
  }
  updateSdfFloatData(A, e) {
    dt[0] = e;
    const s = this.sdfFloatData[A] !== dt[0];
    return s && (this.sdfFloatData[A] = dt[0]), s;
  }
  encodeSdf(A, {
    sdfType: e,
    invert: s,
    center: i,
    quaternion: n,
    scale: a,
    sizes: r
  }, g) {
    const I = A * 32, Q = e | (s ? 256 : 0);
    let o = !1;
    o = this.updateSdfFloatData(I + 0, (i == null ? void 0 : i.x) ?? 0) || o, o = this.updateSdfFloatData(I + 1, (i == null ? void 0 : i.y) ?? 0) || o, o = this.updateSdfFloatData(I + 2, (i == null ? void 0 : i.z) ?? 0) || o, o = this.updateSdfData(I + 3, Q) || o, o = this.updateSdfFloatData(I + 4, (n == null ? void 0 : n.x) ?? 0) || o, o = this.updateSdfFloatData(I + 5, (n == null ? void 0 : n.y) ?? 0) || o, o = this.updateSdfFloatData(I + 6, (n == null ? void 0 : n.z) ?? 0) || o, o = this.updateSdfFloatData(I + 7, (n == null ? void 0 : n.w) ?? 0) || o, o = this.updateSdfFloatData(I + 8, (a == null ? void 0 : a.x) ?? 0) || o, o = this.updateSdfFloatData(I + 9, (a == null ? void 0 : a.y) ?? 0) || o, o = this.updateSdfFloatData(I + 10, (a == null ? void 0 : a.z) ?? 0) || o, o = this.updateSdfData(I + 11, 0) || o, o = this.updateSdfFloatData(I + 12, (r == null ? void 0 : r.x) ?? 0) || o, o = this.updateSdfFloatData(I + 13, (r == null ? void 0 : r.y) ?? 0) || o, o = this.updateSdfFloatData(I + 14, (r == null ? void 0 : r.z) ?? 0) || o, o = this.updateSdfFloatData(I + 15, (r == null ? void 0 : r.w) ?? 0) || o;
    const C = Math.min(4, g.length);
    for (let E = 0; E < C; ++E) {
      const l = I + 16 + E * 4;
      o = this.updateSdfFloatData(l + 0, g[E].x) || o, o = this.updateSdfFloatData(l + 1, g[E].y) || o, o = this.updateSdfFloatData(l + 2, g[E].z) || o, o = this.updateSdfFloatData(l + 3, g[E].w) || o;
    }
    return o;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(A) {
    const e = A.reduce((o, { sdfs: C }) => o + C.length, 0), s = this.ensureCapacity({
      maxEdits: A.length,
      maxSdfs: e
    }), i = [new B.Vector4(), new B.Vector4()], n = new B.Vector3(), a = new B.Quaternion(), r = new B.Vector3(), g = new B.Vector4();
    let I = 0, Q = s;
    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, Q = !0);
    for (const [o, { edit: C, sdfs: E }] of A.entries()) {
      Q = this.encodeEdit(o, {
        sdfFirst: I,
        sdfCount: E.length,
        invert: C.invert,
        rgbaBlendMode: VB(C.rgbaBlendMode),
        softEdge: C.softEdge,
        sdfSmooth: C.sdfSmooth
      }) || Q;
      let l = !1;
      for (const c of E)
        g.set(c.scale.x, c.scale.y, c.scale.z, c.radius), c.scale.setScalar(1), c.updateMatrixWorld(), c.matrixWorld.clone().invert().decompose(n, a, r), c.scale.set(g.x, g.y, g.z), c.updateMatrixWorld(), i[0].set(c.color.r, c.color.g, c.color.b, c.opacity), i[1].set(c.displace.x, c.displace.y, c.displace.z, 1), l = this.encodeSdf(
          I,
          {
            sdfType: _B(c.type),
            invert: c.invert,
            center: n,
            quaternion: a,
            scale: r,
            sizes: g
          },
          i
        ) || l, I += 1;
      this.numSdfs = I, l && (this.sdfTexture.needsUpdate = !0), Q || (Q = l);
    }
    return { updated: Q, dynoUpdated: s };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(A) {
    return XB(
      A,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const kr = { type: "SdfArray" }, Gr = EA(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`), Rr = EA(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function XB(t, A, e, s) {
  return new O({
    inTypes: {
      gsplat: j,
      sdfArray: kr,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: j },
    globals: () => [Gr, Rr],
    inputs: { gsplat: t, sdfArray: A, numEdits: e, rgbaDisplaceEdits: s },
    statements: ({ inputs: n, outputs: a }) => {
      const { sdfArray: r, numEdits: g, rgbaDisplaceEdits: I } = n, { gsplat: Q } = a;
      return UA(`
        ${Q} = ${n.gsplat};
        if (isGsplatActive(${Q}.flags)) {
          for (int editIndex = 0; editIndex < ${g}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${I}[editIndex], ${r}.sdfTexture, ${r}.numSdfs,
              ${Q}.center, ${Q}.rgba
            );
          }
        }
      `);
    }
  }).outputs.gsplat;
}
const dt = new Float32Array(1);
class WB {
  constructor(A) {
    this.modifier = A, this.cache = /* @__PURE__ */ new Map();
  }
  apply(A) {
    let e = this.cache.get(A);
    return e || (e = kA(
      { index: "int" },
      { gsplat: j },
      ({ index: s }) => {
        const { gsplat: i } = A.apply({ index: s });
        return this.modifier.apply({ gsplat: i });
      }
    ), this.cache.set(A, e)), e;
  }
}
class wt {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new Ct({ value: Number.NEGATIVE_INFINITY }), this.rotate = new Zt({
      value: new B.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    }), this.translate = new Mt({
      value: new B.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Vec3 position in a dyno program.
  apply(A) {
    return ir(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  applyDir(A) {
    return nr(A, {
      rotate: this.rotate
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  applyGsplat(A) {
    return Oe(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(A) {
    const e = new B.Vector3(), s = new B.Quaternion(), i = new B.Vector3();
    A.decompose(i, s, e);
    const n = (e.x + e.y + e.z) / 3;
    let a = !1;
    return n !== this.scale.value && (this.scale.value = n, a = !0), i.equals(this.translate.value) || (this.translate.value.copy(i), a = !0), s.equals(this.rotate.value) || (this.rotate.value.copy(s), a = !0), a;
  }
  // Update this transform to match the object's to-world transform.
  update(A) {
    return A.updateMatrixWorld(), this.updateFromMatrix(A.matrixWorld);
  }
}
class Kt extends B.Object3D {
  constructor({
    numSplats: A,
    generator: e,
    construct: s,
    update: i
  }) {
    if (super(), this.numSplats = A ?? 0, this.generator = e, this.frameUpdate = i, this.version = 0, s) {
      const n = s(this);
      Object.assign(this, n);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  set needsUpdate(A) {
    A && this.updateVersion();
  }
}
const et = class et extends Kt {
  constructor(A = {}) {
    const e = new wt(), s = new wt(), i = new wt(), n = new wt(), a = new Zt({
      value: new B.Vector4(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      )
    }), r = new Ct({ value: 0 }), g = new Ct({ value: 0 }), I = {
      transform: e,
      viewToWorld: s,
      worldToView: i,
      viewToObject: n,
      recolor: a,
      time: r,
      deltaTime: g
    };
    if (super({
      update: ({ time: Q, deltaTime: o, viewToWorld: C, globalEdits: E }) => this.update({ time: Q, deltaTime: o, viewToWorld: C, globalEdits: E })
    }), this.isInitialized = !1, this.recolor = new B.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new KA(), this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = I, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)
      this.initialized = this.asyncInitialize(A).then(async () => {
        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {
          const Q = A.onLoad(this);
          Q instanceof Promise && await Q;
        }
        return this;
      });
    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {
      const Q = A.onLoad(this);
      Q instanceof Promise && (this.initialized = Q.then(() => this));
    }
  }
  async asyncInitialize(A) {
    const { url: e, fileBytes: s, fileType: i, fileName: n, maxSplats: a, constructSplats: r } = A;
    if (e || s || r) {
      const g = {
        url: e,
        fileBytes: s,
        fileType: i,
        fileName: n,
        maxSplats: a,
        construct: r
      };
      this.packedSplats.reinitialize(g);
    }
    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats, this.updateGenerator());
  }
  static async staticInitialize() {
    await ms(), et.isStaticInitialized = !0;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(A, e, s, i, n) {
    this.packedSplats.pushSplat(A, e, s, i, n);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(A) {
    this.packedSplats.forEachSplat(A);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  constructGenerator(A) {
    const { transform: e, viewToObject: s, recolor: i } = A, n = kA(
      { index: "int" },
      { gsplat: j },
      ({ index: a }) => {
        if (!a)
          throw new Error("index is undefined");
        let r = Ht(this.packedSplats.dyno, a);
        if (this.maxSh >= 1) {
          const { sh1Texture: I, sh2Texture: Q, sh3Texture: o } = this.ensureShTextures();
          if (I) {
            const C = s.translate, { center: E } = Bt(r).outputs, l = wa(Ft(E, C));
            let c = tC(r, I, l);
            this.maxSh >= 2 && Q && (c = fA(c, eC(r, Q, l))), this.maxSh >= 3 && o && (c = fA(c, sC(r, o, l)));
            let { rgba: h } = Bt(r).outputs;
            h = fA(h, Da(c, q("float", 0))), r = at({ gsplat: r, rgba: h });
          }
        }
        if (this.splatRgba) {
          const I = KB(this.splatRgba.dyno, a);
          r = at({ gsplat: r, rgba: I });
        }
        this.skinning && (r = this.skinning.modify(r)), this.objectModifier && (r = this.objectModifier.apply({ gsplat: r }).gsplat), r = e.applyGsplat(r);
        const g = BA(i, Bt(r).outputs.rgba);
        return r = at({ gsplat: r, rgba: g }), this.rgbaDisplaceEdits && (r = this.rgbaDisplaceEdits.modify(r)), this.worldModifier && (r = this.worldModifier.apply({ gsplat: r }).gsplat), { gsplat: r };
      }
    );
    this.generator = n;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by SparkRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    time: A,
    viewToWorld: e,
    deltaTime: s,
    globalEdits: i
  }) {
    var h;
    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = s, et.dynoTime.value = A;
    const { transform: n, viewToObject: a, recolor: r } = this.context;
    let g = n.update(this);
    this.context.viewToWorld.updateFromMatrix(e) && this.enableViewToWorld && (g = !0);
    const I = e.clone().invert();
    this.context.worldToView.updateFromMatrix(I) && this.enableWorldToView && (g = !0);
    const C = new B.Matrix4().compose(
      n.translate.value,
      n.rotate.value,
      new B.Vector3().setScalar(n.scale.value)
    ).invert().multiply(e);
    a.updateFromMatrix(C) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (g = !0);
    const E = new B.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    E.equals(r.value) || (r.value.copy(E), g = !0);
    const l = this.editable ? (this.edits ?? []).concat(i) : [];
    this.editable && !this.edits && this.traverseVisible((u) => {
      u instanceof Ie && l.push(u);
    }), l.sort((u, p) => u.ordering - p.ordering);
    const c = l.map((u) => {
      if (u.sdfs != null)
        return { edit: u, sdfs: u.sdfs };
      const p = [];
      return u.traverseVisible((d) => {
        d instanceof PB && p.push(d);
      }), { edit: u, sdfs: p };
    });
    if (c.length > 0 && !this.rgbaDisplaceEdits) {
      const u = c.length, p = c.reduce(
        (d, y) => d + y.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new ZB({
        maxEdits: u,
        maxSdfs: p
      }), this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const u = this.rgbaDisplaceEdits.update(c);
      g || (g = u.updated), u.dynoUpdated && this.updateGenerator();
    }
    g && this.updateVersion(), (h = this.onFrame) == null || h.call(this, { mesh: this, time: A, deltaTime: s });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(A, e) {
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)
      return;
    const { near: s, far: i, ray: n } = A, a = this.matrixWorld.clone().invert(), r = new B.Matrix3().setFromMatrix4(a), g = n.origin.clone().applyMatrix4(a), I = n.direction.clone().applyMatrix3(r), Q = new B.Vector3();
    a.decompose(new B.Vector3(), new B.Quaternion(), Q), (Q.x * Q.y * Q.z) ** (1 / 3);
    const C = Mg(
      g.x,
      g.y,
      g.z,
      I.x,
      I.y,
      I.z,
      s,
      i,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      !0
    );
    for (const E of C) {
      const l = n.direction.clone().multiplyScalar(E).add(n.origin);
      e.push({
        distance: E,
        point: l,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1)
      return {};
    let A = this.packedSplats.extra.sh1Texture;
    if (!A) {
      let i = this.packedSplats.extra.sh1;
      const { width: n, height: a, depth: r, maxSplats: g } = mA(
        i.length / 2
      );
      if (i.length < g * 2) {
        const Q = new Uint32Array(g * 2);
        Q.set(i), this.packedSplats.extra.sh1 = Q, i = Q;
      }
      const I = new B.DataArrayTexture(i, n, a, r);
      I.format = B.RGIntegerFormat, I.type = B.UnsignedIntType, I.internalFormat = "RG32UI", I.needsUpdate = !0, A = new Jt({
        value: I,
        key: "sh1"
      }), this.packedSplats.extra.sh1Texture = A;
    }
    if (!this.packedSplats.extra.sh2)
      return { sh1Texture: A };
    let e = this.packedSplats.extra.sh2Texture;
    if (!e) {
      let i = this.packedSplats.extra.sh2;
      const { width: n, height: a, depth: r, maxSplats: g } = mA(
        i.length / 4
      );
      if (i.length < g * 4) {
        const Q = new Uint32Array(g * 4);
        Q.set(i), this.packedSplats.extra.sh2 = Q, i = Q;
      }
      const I = new B.DataArrayTexture(i, n, a, r);
      I.format = B.RGBAIntegerFormat, I.type = B.UnsignedIntType, I.internalFormat = "RGBA32UI", I.needsUpdate = !0, e = new Jt({
        value: I,
        key: "sh2"
      }), this.packedSplats.extra.sh2Texture = e;
    }
    if (!this.packedSplats.extra.sh3)
      return { sh1Texture: A, sh2Texture: e };
    let s = this.packedSplats.extra.sh3Texture;
    if (!s) {
      let i = this.packedSplats.extra.sh3;
      const { width: n, height: a, depth: r, maxSplats: g } = mA(
        i.length / 4
      );
      if (i.length < g * 4) {
        const Q = new Uint32Array(g * 4);
        Q.set(i), this.packedSplats.extra.sh3 = Q, i = Q;
      }
      const I = new B.DataArrayTexture(i, n, a, r);
      I.format = B.RGBAIntegerFormat, I.type = B.UnsignedIntType, I.internalFormat = "RGBA32UI", I.needsUpdate = !0, s = new Jt({
        value: I,
        key: "sh3"
      }), this.packedSplats.extra.sh3Texture = s;
    }
    return { sh1Texture: A, sh2Texture: e, sh3Texture: s };
  }
};
et.staticInitialized = et.staticInitialize(), et.isStaticInitialized = !1, et.dynoTime = new Ct({ value: 0 });
let ZA = et;
const jB = EA(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`), $B = EA(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`), AC = EA(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function tC(t, A, e) {
  return Vt({
    inTypes: { gsplat: j, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh1: A, viewDir: e },
    globals: () => [FA, jB],
    statements: ({ inputs: s, outputs: i }) => UA(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${i.rgb} = evaluateSH1(${s.gsplat}, ${s.sh1}, ${s.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function eC(t, A, e) {
  return Vt({
    inTypes: { gsplat: j, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh2: A, viewDir: e },
    globals: () => [FA, $B],
    statements: ({ inputs: s, outputs: i }) => UA(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${i.rgb} = evaluateSH2(${s.gsplat}, ${s.sh2}, ${s.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function sC(t, A, e) {
  return Vt({
    inTypes: { gsplat: j, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh3: A, viewDir: e },
    globals: () => [FA, AC],
    statements: ({ inputs: s, outputs: i }) => UA(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${i.rgb} = evaluateSH3(${s.gsplat}, ${s.sh3}, ${s.viewDir});
        } else {
          ${i.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
const Dt = class Dt {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes: A }) {
    this.header = "", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const e = new ReadableStream({
      start: (a) => {
        a.enqueue(this.fileBytes.slice(0, 65536)), a.close();
      }
    }).pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const s = `end_header
`;
    for (; ; ) {
      const { value: a, done: r } = await e.read();
      if (r)
        throw new Error("Failed to read header");
      this.header += a;
      const g = this.header.indexOf(s);
      if (g >= 0) {
        this.header = this.header.slice(0, g + s.length);
        break;
      }
    }
    const i = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, i), this.elements = {};
    let n = null;
    this.comments = [], this.header.trim().split(`
`).forEach((a, r) => {
      const g = a.trim();
      if (r === 0) {
        if (g !== "ply")
          throw new Error("Invalid PLY header");
        return;
      }
      if (g.length === 0)
        return;
      const I = g.split(" ");
      switch (I[0]) {
        case "format":
          if (I[1] === "binary_little_endian")
            this.littleEndian = !0;
          else if (I[1] === "binary_big_endian")
            this.littleEndian = !1;
          else
            throw new Error(`Unsupported PLY format: ${I[1]}`);
          if (I[2] !== "1.0")
            throw new Error(`Unsupported PLY version: ${I[2]}`);
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(g.slice(8));
          break;
        case "element": {
          const Q = I[1];
          n = {
            name: Q,
            count: Number.parseInt(I[2]),
            properties: {}
          }, this.elements[Q] = n;
          break;
        }
        case "property":
          if (n == null)
            throw new Error("Property must be inside an element");
          I[1] === "list" ? n.properties[I[4]] = {
            isList: !0,
            type: I[3],
            countType: I[2]
          } : n.properties[I[2]] = {
            isList: !1,
            type: I[1]
          };
          break;
      }
    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);
  }
  parseData(A) {
    let e = 0;
    const s = this.data;
    if (s == null)
      throw new Error("No data to parse");
    for (const i in this.elements) {
      const n = this.elements[i], { count: a, properties: r } = n, g = {}, I = [];
      for (const [o, C] of Object.entries(r))
        C.isList ? (g[o] = [], I.push(() => {
          const E = g[o];
          E.length = Ae[C.countType](
            s,
            e,
            this.littleEndian
          ), e += pt[C.countType];
          for (let l = 0; l < E.length; l++)
            E[l] = Ae[C.type](
              s,
              e,
              this.littleEndian
            ), e += pt[C.type];
        })) : (g[o] = 0, I.push(() => {
          g[o] = Ae[C.type](
            s,
            e,
            this.littleEndian
          ), e += pt[C.type];
        }));
      const Q = A(n) ?? (() => {
      });
      for (let o = 0; o < a; o++) {
        for (const C of I)
          C();
        Q(o, g);
      }
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(A, e) {
    if (this.elements.vertex == null)
      throw new Error("No vertex element found");
    let s = !1;
    const i = [];
    let n = 0, a = [], r = [], g = [], I, Q, o;
    function C() {
      const u = nC[n];
      a = new Array(3).fill(null).flatMap(
        (p, d) => [0, 1, 2].map((y, D) => `f_rest_${d + D * u / 3}`)
      ), r = new Array(5).fill(null).flatMap(
        (p, d) => [0, 1, 2].map((y, D) => `f_rest_${3 + d + D * u / 3}`)
      ), g = new Array(7).fill(null).flatMap(
        (p, d) => [0, 1, 2].map((y, D) => `f_rest_${8 + d + D * u / 3}`)
      ), I = n >= 1 ? new Float32Array(3 * 3) : void 0, Q = n >= 2 ? new Float32Array(5 * 3) : void 0, o = n >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function E(u, p) {
      if (!I)
        throw new Error("Missing sh1");
      for (const [d, y] of a.entries())
        I[d] = p[y] * 8 / 255 - 4;
      if (Q)
        for (const [d, y] of r.entries())
          Q[d] = p[y] * 8 / 255 - 4;
      if (o)
        for (const [d, y] of g.entries())
          o[d] = p[y] * 8 / 255 - 4;
      e == null || e(u, I, Q, o);
    }
    function l(u) {
      const {
        min_x: p,
        min_y: d,
        min_z: y,
        max_x: D,
        max_y: S,
        max_z: m,
        min_scale_x: f,
        min_scale_y: w,
        min_scale_z: R,
        max_scale_x: M,
        max_scale_y: x,
        max_scale_z: L
      } = u.properties;
      if (!p || !d || !y || !D || !S || !m || !f || !w || !R || !M || !x || !L)
        throw new Error("Missing PLY chunk properties");
      return s = !0, (N, k) => {
        const {
          min_x: U,
          min_y: v,
          min_z: AA,
          max_x: z,
          max_y: sA,
          max_z: tA,
          min_scale_x: P,
          min_scale_y: J,
          min_scale_z: Z,
          max_scale_x: V,
          max_scale_y: X,
          max_scale_z: b,
          min_r: dA,
          min_g: oA,
          min_b: pA,
          max_r: yA,
          max_g: xA,
          max_b: cA
        } = k;
        i.push({
          min_x: U,
          min_y: v,
          min_z: AA,
          max_x: z,
          max_y: sA,
          max_z: tA,
          min_scale_x: P,
          min_scale_y: J,
          min_scale_z: Z,
          max_scale_x: V,
          max_scale_y: X,
          max_scale_z: b,
          min_r: dA,
          min_g: oA,
          min_b: pA,
          max_r: yA,
          max_g: xA,
          max_b: cA
        });
      };
    }
    function c(u) {
      if (e && u.name === "sh")
        return n = gs(u.properties), C(), E;
      if (u.name !== "vertex")
        return null;
      const { packed_position: p, packed_rotation: d, packed_scale: y, packed_color: D } = u.properties;
      if (!p || !d || !y || !D)
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      const S = Math.sqrt(2);
      return (m, f) => {
        const w = i[m >>> 8];
        if (w == null)
          throw new Error("Missing PLY chunk");
        const {
          min_x: R,
          min_y: M,
          min_z: x,
          max_x: L,
          max_y: N,
          max_z: k,
          min_scale_x: U,
          min_scale_y: v,
          min_scale_z: AA,
          max_scale_x: z,
          max_scale_y: sA,
          max_scale_z: tA,
          min_r: P,
          min_g: J,
          min_b: Z,
          max_r: V,
          max_g: X,
          max_b: b
        } = w, { packed_position: dA, packed_rotation: oA, packed_scale: pA, packed_color: yA } = f, xA = (dA >>> 21 & 2047) / 2047 * (L - R) + R, cA = (dA >>> 11 & 1023) / 1023 * (N - M) + M, LA = (dA & 2047) / 2047 * (k - x) + x, SA = ((oA >>> 20 & 1023) / 1023 - 0.5) * S, XA = ((oA >>> 10 & 1023) / 1023 - 0.5) * S, WA = ((oA & 1023) / 1023 - 0.5) * S, Y = Math.sqrt(Math.max(0, 1 - SA * SA - XA * XA - WA * WA)), uA = oA >>> 30, _A = uA === 0 ? SA : uA === 1 ? Y : XA, Rt = uA <= 1 ? XA : uA === 2 ? Y : WA, Wt = uA <= 2 ? WA : Y, MA = uA === 0 ? Y : SA, T = Math.exp(
          (pA >>> 21 & 2047) / 2047 * (z - U) + U
        ), OA = Math.exp(
          (pA >>> 11 & 1023) / 1023 * (sA - v) + v
        ), de = Math.exp(
          (pA & 2047) / 2047 * (tA - AA) + AA
        ), pe = (yA >>> 24 & 255) / 255 * ((V ?? 1) - (P ?? 0)) + (P ?? 0), ye = (yA >>> 16 & 255) / 255 * ((X ?? 1) - (J ?? 0)) + (J ?? 0), we = (yA >>> 8 & 255) / 255 * ((b ?? 1) - (Z ?? 0)) + (Z ?? 0), De = (yA & 255) / 255;
        A(
          m,
          xA,
          cA,
          LA,
          T,
          OA,
          de,
          _A,
          Rt,
          Wt,
          MA,
          De,
          pe,
          ye,
          we
        );
      };
    }
    const h = (u) => {
      if (u.name === "chunk")
        return l(u);
      if (s)
        return c(u);
      if (u.name !== "vertex")
        return null;
      const {
        x: p,
        y: d,
        z: y,
        scale_0: D,
        scale_1: S,
        scale_2: m,
        rot_0: f,
        rot_1: w,
        rot_2: R,
        rot_3: M,
        opacity: x,
        f_dc_0: L,
        f_dc_1: N,
        f_dc_2: k,
        red: U,
        green: v,
        blue: AA,
        alpha: z
      } = u.properties;
      if (!p || !d || !y)
        throw new Error("Missing PLY properties: x, y, z");
      const sA = D && S && m, tA = f && w && R && M, P = z != null ? te[z.type] : 1, J = U != null ? te[U.type] : 1, Z = v != null ? te[v.type] : 1, V = AA != null ? te[AA.type] : 1;
      return n = gs(u.properties), C(), (X, b) => {
        const dA = sA ? Math.exp(b.scale_0) : Dt.defaultPointScale, oA = sA ? Math.exp(b.scale_1) : Dt.defaultPointScale, pA = sA ? Math.exp(b.scale_2) : Dt.defaultPointScale, yA = tA ? b.rot_1 : 0, xA = tA ? b.rot_2 : 0, cA = tA ? b.rot_3 : 0, LA = tA ? b.rot_0 : 1, SA = x != null ? 1 / (1 + Math.exp(-b.opacity)) : z != null ? b.alpha / P : 1, XA = L != null ? b.f_dc_0 * $t + 0.5 : U != null ? b.red / J : 1, WA = N != null ? b.f_dc_1 * $t + 0.5 : v != null ? b.green / Z : 1, Y = k != null ? b.f_dc_2 * $t + 0.5 : AA != null ? b.blue / V : 1;
        if (A(
          X,
          b.x,
          b.y,
          b.z,
          dA,
          oA,
          pA,
          yA,
          xA,
          cA,
          LA,
          SA,
          XA,
          WA,
          Y
        ), e && I) {
          if (I)
            for (const [uA, _A] of a.entries())
              I[uA] = b[_A];
          if (Q)
            for (const [uA, _A] of r.entries())
              Q[uA] = b[_A];
          if (o)
            for (const [uA, _A] of g.entries())
              o[uA] = b[_A];
          e(X, I, Q, o);
        }
      };
    };
    this.parseData(h);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(A) {
    let e = 0;
    const s = this.data;
    if (s == null)
      throw new Error("No parsed data");
    if (A.length !== this.numSplats * 4)
      throw new Error("Invalid RGBA array length");
    for (const i in this.elements) {
      const n = this.elements[i], { count: a, properties: r } = n, g = [];
      let I = 0;
      const Q = i === "vertex";
      if (Q) {
        for (const o of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"])
          if (!r[o] || r[o].type !== "float")
            throw new Error(`Can't injectRgba due to property: ${o}`);
      }
      for (const [o, C] of Object.entries(r))
        if (C.isList)
          g.push(() => {
            const E = Ae[C.countType](
              s,
              e,
              this.littleEndian
            );
            e += pt[C.countType], e += E * pt[C.type];
          });
        else {
          if (Q)
            if (o === "f_dc_0" || o === "f_dc_1" || o === "f_dc_2") {
              const E = Number.parseInt(
                o.slice(5)
              );
              g.push(() => {
                const l = (A[I + E] / 255 - 0.5) / $t;
                rs[C.type](
                  s,
                  e,
                  this.littleEndian,
                  l
                );
              });
            } else o === "opacity" && g.push(() => {
              const E = Math.max(
                -100,
                Math.min(
                  100,
                  -Math.log(1 / (A[I + 3] / 255) - 1)
                )
              );
              rs[C.type](
                s,
                e,
                this.littleEndian,
                E
              );
            });
          g.push(() => {
            e += pt[C.type];
          });
        }
      for (let o = 0; o < a; o++) {
        for (const C of g)
          C();
        Q && (I += 4);
      }
    }
  }
};
Dt.defaultPointScale = 1e-3;
let Qe = Dt;
const $t = 0.28209479177387814, Ae = {
  char: (t, A, e) => t.getInt8(A),
  uchar: (t, A, e) => t.getUint8(A),
  short: (t, A, e) => t.getInt16(A, e),
  ushort: (t, A, e) => t.getUint16(A, e),
  int: (t, A, e) => t.getInt32(A, e),
  uint: (t, A, e) => t.getUint32(A, e),
  float: (t, A, e) => t.getFloat32(A, e),
  double: (t, A, e) => t.getFloat64(A, e)
}, rs = {
  char: (t, A, e, s) => {
    t.setInt8(A, s);
  },
  uchar: (t, A, e, s) => {
    t.setUint8(A, s);
  },
  short: (t, A, e, s) => {
    t.setInt16(A, s, e);
  },
  ushort: (t, A, e, s) => {
    t.setUint16(A, s, e);
  },
  int: (t, A, e, s) => {
    t.setInt32(A, s, e);
  },
  uint: (t, A, e, s) => {
    t.setUint32(A, s, e);
  },
  float: (t, A, e, s) => {
    t.setFloat32(A, s, e);
  },
  double: (t, A, e, s) => {
    t.setFloat64(A, s, e);
  }
}, pt = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
}, te = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
}, iC = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
}, nC = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function gs(t) {
  let A = 0;
  for (; t[`f_rest_${A}`]; )
    A += 1;
  const e = iC[A];
  if (e == null)
    throw new Error(`Unsupported number of SH coefficients: ${A}`);
  return e;
}
const Ur = '(function(){"use strict";let XA;const mi=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&mi.decode();let Qe=null;function ur(){return(Qe===null||Qe.byteLength===0)&&(Qe=new Uint8Array(XA.memory.buffer)),Qe}function dr(n,A){return n=n>>>0,mi.decode(ur().subarray(n,n+A))}function fr(n,A,t){return XA.sort_splats(n,A,t)>>>0}function yr(n,A,t,e,s,i,r,a,g,o,I){return XA.raycast_splats(n,A,t,e,s,i,r,a,g,o,I)}async function pr(n,A){if(typeof Response=="function"&&n instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(n,A)}catch(e){if(n.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n",e);else throw e}const t=await n.arrayBuffer();return await WebAssembly.instantiate(t,A)}else{const t=await WebAssembly.instantiate(n,A);return t instanceof WebAssembly.Instance?{instance:t,module:n}:t}}function wr(){const n={};return n.wbg={},n.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},n.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},n.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},n.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},n.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},n.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},n.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,t,e){return new Float32Array(A,t>>>0,e>>>0)},n.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,t,e){return new Uint32Array(A,t>>>0,e>>>0)},n.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},n.wbg.__wbg_set_10bad9bee0e9c58b=function(A,t,e){A.set(t,e>>>0)},n.wbg.__wbg_set_d23661d19148b229=function(A,t,e){A.set(t,e>>>0)},n.wbg.__wbg_set_f4f1f0daa30696fc=function(A,t,e){A.set(t,e>>>0)},n.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,t,e){return A.subarray(t>>>0,e>>>0)},n.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,t,e){return A.subarray(t>>>0,e>>>0)},n.wbg.__wbindgen_init_externref_table=function(){const A=XA.__wbindgen_export_0,t=A.grow(4);A.set(0,void 0),A.set(t+0,void 0),A.set(t+1,null),A.set(t+2,!0),A.set(t+3,!1)},n.wbg.__wbindgen_memory=function(){return XA.memory},n.wbg.__wbindgen_throw=function(A,t){throw new Error(dr(A,t))},n}function Dr(n,A){return XA=n.exports,Ds.__wbindgen_wasm_module=A,Qe=null,XA.__wbindgen_start(),XA}async function Ds(n){if(XA!==void 0)return XA;typeof n<"u"&&(Object.getPrototypeOf(n)===Object.prototype?{module_or_path:n}=n:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof n>"u"&&(n=new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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",self.location.href));const A=wr();(typeof n=="string"||typeof Request=="function"&&n instanceof Request||typeof URL=="function"&&n instanceof URL)&&(n=fetch(n));const{instance:t,module:e}=await pr(await n,A);return Dr(t,e)}var xi={},mr=function(n,A,t,e,s){var i=new Worker(xi[A]||(xi[A]=URL.createObjectURL(new Blob([n+\';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\'],{type:"text/javascript"}))));return i.onmessage=function(r){var a=r.data,g=a.$e$;if(g){var o=new Error(g[0]);o.code=g[1],o.stack=g[2],s(o,null)}else s(null,a)},i.postMessage(t,e),i},eA=Uint8Array,xt=Uint16Array,Mi=Int32Array,ms=new eA([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),xs=new eA([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Si=new eA([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Fi=function(n,A){for(var t=new xt(31),e=0;e<31;++e)t[e]=A+=1<<n[e-1];for(var s=new Mi(t[30]),e=1;e<30;++e)for(var i=t[e];i<t[e+1];++i)s[i]=i-t[e]<<5|e;return{b:t,r:s}},Ni=Fi(ms,2),Ms=Ni.b,xr=Ni.r;Ms[28]=258,xr[258]=28;for(var Mr=Fi(xs,0),ki=Mr.b,Re=new xt(32768),V=0;V<32768;++V){var ht=(V&43690)>>1|(V&21845)<<1;ht=(ht&52428)>>2|(ht&13107)<<2,ht=(ht&61680)>>4|(ht&3855)<<4,Re[V]=((ht&65280)>>8|(ht&255)<<8)>>1}for(var bt=function(n,A,t){for(var e=n.length,s=0,i=new xt(A);s<e;++s)n[s]&&++i[n[s]-1];var r=new xt(A);for(s=1;s<A;++s)r[s]=r[s-1]+i[s-1]<<1;var a;if(t){a=new xt(1<<A);var g=15-A;for(s=0;s<e;++s)if(n[s])for(var o=s<<4|n[s],I=A-n[s],B=r[n[s]-1]++<<I,Q=B|(1<<I)-1;B<=Q;++B)a[Re[B]>>g]=o}else for(a=new xt(e),s=0;s<e;++s)n[s]&&(a[s]=Re[r[n[s]-1]++]>>15-n[s]);return a},he=new eA(288),V=0;V<144;++V)he[V]=8;for(var V=144;V<256;++V)he[V]=9;for(var V=256;V<280;++V)he[V]=7;for(var V=280;V<288;++V)he[V]=8;for(var Ri=new eA(32),V=0;V<32;++V)Ri[V]=5;var Gi=bt(he,9,1),Ui=bt(Ri,5,1),Ge=function(n){for(var A=n[0],t=1;t<n.length;++t)n[t]>A&&(A=n[t]);return A},LA=function(n,A,t){var e=A/8|0;return(n[e]|n[e+1]<<8)>>(A&7)&t},Ue=function(n,A){var t=A/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(A&7)},Ss=function(n){return(n+7)/8|0},Ct=function(n,A,t){return(A==null||A<0)&&(A=0),(t==null||t>n.length)&&(t=n.length),new eA(n.subarray(A,t))},Li=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],sA=function(n,A,t){var e=new Error(A||Li[n]);if(e.code=n,Error.captureStackTrace&&Error.captureStackTrace(e,sA),!t)throw e;return e},Fs=function(n,A,t,e){var s=n.length,i=e?e.length:0;if(!s||A.f&&!A.l)return t||new eA(0);var r=!t,a=r||A.i!=2,g=A.i;r&&(t=new eA(s*3));var o=function(pA){var MA=t.length;if(pA>MA){var SA=new eA(Math.max(MA*2,pA));SA.set(t),t=SA}},I=A.f||0,B=A.p||0,Q=A.b||0,h=A.l,C=A.d,E=A.m,l=A.n,c=s*8;do{if(!h){I=LA(n,B,1);var u=LA(n,B+1,3);if(B+=3,u)if(u==1)h=Gi,C=Ui,E=9,l=5;else if(u==2){var x=LA(n,B,31)+257,M=LA(n,B+10,15)+4,p=x+LA(n,B+5,31)+1;B+=14;for(var D=new eA(p),F=new eA(19),m=0;m<M;++m)F[Si[m]]=LA(n,B+m*3,7);B+=M*3;for(var S=Ge(F),N=(1<<S)-1,k=bt(F,S,1),m=0;m<p;){var G=k[LA(n,B,N)];B+=G&15;var d=G>>4;if(d<16)D[m++]=d;else{var R=0,L=0;for(d==16?(L=3+LA(n,B,3),B+=2,R=D[m-1]):d==17?(L=3+LA(n,B,7),B+=3):d==18&&(L=11+LA(n,B,127),B+=7);L--;)D[m++]=R}}var W=D.subarray(0,x),_=D.subarray(x);E=Ge(W),l=Ge(_),h=bt(W,E,1),C=bt(_,l,1)}else sA(1);else{var d=Ss(B)+4,y=n[d-4]|n[d-3]<<8,w=d+y;if(w>s){g&&sA(0);break}a&&o(Q+y),t.set(n.subarray(d,w),Q),A.b=Q+=y,A.p=B=w*8,A.f=I;continue}if(B>c){g&&sA(0);break}}a&&o(Q+131072);for(var j=(1<<E)-1,X=(1<<l)-1,$=B;;$=B){var R=h[Ue(n,B)&j],q=R>>4;if(B+=R&15,B>c){g&&sA(0);break}if(R||sA(2),q<256)t[Q++]=q;else if(q==256){$=B,h=null;break}else{var z=q-254;if(q>264){var m=q-257,b=ms[m];z=LA(n,B,(1<<b)-1)+Ms[m],B+=b}var O=C[Ue(n,B)&X],U=O>>4;O||sA(3),B+=O&15;var _=ki[U];if(U>3){var b=xs[U];_+=Ue(n,B)&(1<<b)-1,B+=b}if(B>c){g&&sA(0);break}a&&o(Q+131072);var yA=Q+z;if(Q<_){var dA=i-_,UA=Math.min(_,yA);for(dA+Q<0&&sA(3);Q<UA;++Q)t[Q]=e[dA+Q]}for(;Q<yA;++Q)t[Q]=t[Q-_]}}A.l=h,A.p=$,A.b=Q,A.f=I,h&&(I=1,A.m=E,A.d=C,A.n=l)}while(!I);return Q!=t.length&&r?Ct(t,0,Q):t.subarray(0,Q)},Sr=new eA(0),Fr=function(n,A){var t={};for(var e in n)t[e]=n[e];for(var e in A)t[e]=A[e];return t},bi=function(n,A,t){for(var e=n(),s=n.toString(),i=s.slice(s.indexOf("[")+1,s.lastIndexOf("]")).replace(/\\s+/g,"").split(","),r=0;r<e.length;++r){var a=e[r],g=i[r];if(typeof a=="function"){A+=";"+g+"=";var o=a.toString();if(a.prototype)if(o.indexOf("[native code]")!=-1){var I=o.indexOf(" ",8)+1;A+=o.slice(I,o.indexOf("(",I))}else{A+=o;for(var B in a.prototype)A+=";"+g+".prototype."+B+"="+a.prototype[B].toString()}else A+=o}else t[g]=a}return A},Le=[],Nr=function(n){var A=[];for(var t in n)n[t].buffer&&A.push((n[t]=new n[t].constructor(n[t])).buffer);return A},kr=function(n,A,t,e){if(!Le[t]){for(var s="",i={},r=n.length-1,a=0;a<r;++a)s=bi(n[a],s,i);Le[t]={c:bi(n[r],s,i),e:i}}var g=Fr({},Le[t].e);return mr(Le[t].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+A.toString()+"}",t,g,Nr(g),e)},Rr=function(){return[eA,xt,Mi,ms,xs,Si,Ms,ki,Gi,Ui,Re,Li,bt,Ge,LA,Ue,Ss,Ct,sA,Fs,be,Yi,Ji]},Yi=function(n){return postMessage(n,[n.buffer])},Ji=function(n){return n&&{out:n.size&&new eA(n.size),dictionary:n.dictionary}},Gr=function(n,A,t,e,s,i){var r=kr(t,e,s,function(a,g){r.terminate(),i(a,g)});return r.postMessage([n,A],A.consume?[n.buffer]:[]),function(){r.terminate()}},TA=function(n,A){return n[A]|n[A+1]<<8},CA=function(n,A){return(n[A]|n[A+1]<<8|n[A+2]<<16|n[A+3]<<24)>>>0},Ns=function(n,A){return CA(n,A)+CA(n,A+4)*4294967296},Ur=function(n){(n[0]!=31||n[1]!=139||n[2]!=8)&&sA(6,"invalid gzip data");var A=n[3],t=10;A&4&&(t+=(n[10]|n[11]<<8)+2);for(var e=(A>>3&1)+(A>>4&1);e>0;e-=!n[t++]);return t+(A&2)},ks=function(){function n(A,t){typeof A=="function"&&(t=A,A={}),this.ondata=t;var e=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:e?e.length:0},this.o=new eA(32768),this.p=new eA(0),e&&this.o.set(e)}return n.prototype.e=function(A){if(this.ondata||sA(5),this.d&&sA(4),!this.p.length)this.p=A;else if(A.length){var t=new eA(this.p.length+A.length);t.set(this.p),t.set(A,this.p.length),this.p=t}},n.prototype.c=function(A){this.s.i=+(this.d=A||!1);var t=this.s.b,e=Fs(this.p,this.s,this.o);this.ondata(Ct(e,t,this.s.b),this.d),this.o=Ct(e,this.s.b-32768),this.s.b=this.o.length,this.p=Ct(this.p,this.s.p/8|0),this.s.p&=7},n.prototype.push=function(A,t){this.e(A),this.c(t)},n}();function Lr(n,A,t){return t||(t=A,A={}),typeof t!="function"&&sA(7),Gr(n,A,[Rr],function(e){return Yi(be(e.data[0],Ji(e.data[1])))},1,t)}function be(n,A){return Fs(n,{i:2},A&&A.out,A&&A.dictionary)}var Hi=function(){function n(A,t){this.v=1,this.r=0,ks.call(this,A,t)}return n.prototype.push=function(A,t){if(ks.prototype.e.call(this,A),this.r+=A.length,this.v){var e=this.p.subarray(this.v-1),s=e.length>3?Ur(e):4;if(s>e.length){if(!t)return}else this.v>1&&this.onmember&&this.onmember(this.r-e.length);this.p=e.subarray(s),this.v=0}ks.prototype.c.call(this,t),this.s.f&&!this.s.l&&!t&&(this.v=Ss(this.s.p)+9,this.s={i:0},this.o=new eA(0),this.push(new eA(0),t))},n}(),Rs=typeof TextDecoder<"u"&&new TextDecoder,br=0;try{Rs.decode(Sr,{stream:!0}),br=1}catch{}var Yr=function(n){for(var A="",t=0;;){var e=n[t++],s=(e>127)+(e>223)+(e>239);if(t+s>n.length)return{s:A,r:Ct(n,t-1)};s?s==3?(e=((e&15)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,A+=String.fromCharCode(55296|e>>10,56320|e&1023)):s&1?A+=String.fromCharCode((e&31)<<6|n[t++]&63):A+=String.fromCharCode((e&15)<<12|(n[t++]&63)<<6|n[t++]&63):A+=String.fromCharCode(e)}};function Jr(n,A){if(A){for(var t="",e=0;e<n.length;e+=16384)t+=String.fromCharCode.apply(null,n.subarray(e,e+16384));return t}else{if(Rs)return Rs.decode(n);var s=Yr(n),i=s.s,t=s.r;return t.length&&sA(8),i}}var Ti=function(n,A){return A+30+TA(n,A+26)+TA(n,A+28)},vi=function(n,A,t){var e=TA(n,A+28),s=Jr(n.subarray(A+46,A+46+e),!(TA(n,A+8)&2048)),i=A+46+e,r=CA(n,A+20),a=t&&r==4294967295?Hr(n,i):[r,CA(n,A+24),CA(n,A+42)],g=a[0],o=a[1],I=a[2];return[TA(n,A+10),g,o,s,i+TA(n,A+30)+TA(n,A+32),I]},Hr=function(n,A){for(;TA(n,A)!=1;A+=4+TA(n,A+2));return[Ns(n,A+12),Ns(n,A+4),Ns(n,A+20)]},zi=typeof queueMicrotask=="function"?queueMicrotask:typeof setTimeout=="function"?setTimeout:function(n){n()};function Tr(n,A,t){t||(t=A,A={}),typeof t!="function"&&sA(7);var e=[],s=function(){for(var l=0;l<e.length;++l)e[l]()},i={},r=function(l,c){zi(function(){t(l,c)})};zi(function(){r=t});for(var a=n.length-22;CA(n,a)!=101010256;--a)if(!a||n.length-a>65558)return r(sA(13,0,1),null),s;var g=TA(n,a+8);if(g){var o=g,I=CA(n,a+16),B=I==4294967295||o==65535;if(B){var Q=CA(n,a-12);B=CA(n,Q)==101075792,B&&(o=g=CA(n,Q+32),I=CA(n,Q+48))}for(var h=A&&A.filter,C=function(l){var c=vi(n,I,B),u=c[0],d=c[1],y=c[2],w=c[3],x=c[4],M=c[5],p=Ti(n,M);I=x;var D=function(m,S){m?(s(),r(m,null)):(S&&(i[w]=S),--g||r(null,i))};if(!h||h({name:w,size:d,originalSize:y,compression:u}))if(!u)D(null,Ct(n,p,p+d));else if(u==8){var F=n.subarray(p,p+d);if(y<524288||d>.8*y)try{D(null,be(F,{out:new eA(y)}))}catch(m){D(m,null)}else e.push(Lr(F,{size:y},D))}else D(sA(14,"unknown compression type "+u,1),null);else D(null,null)},E=0;E<o;++E)C(E)}else r(null,{});return s}function vr(n,A){for(var t={},e=n.length-22;CA(n,e)!=101010256;--e)(!e||n.length-e>65558)&&sA(13);var s=TA(n,e+8);if(!s)return{};var i=CA(n,e+16),r=i==4294967295||s==65535;if(r){var a=CA(n,e-12);r=CA(n,a)==101075792,r&&(s=CA(n,a+32),i=CA(n,a+48))}for(var g=A&&A.filter,o=0;o<s;++o){var I=vi(n,i,r),B=I[0],Q=I[1],h=I[2],C=I[3],E=I[4],l=I[5],c=Ti(n,l);i=E,(!g||g({name:C,size:Q,originalSize:h,compression:B}))&&(B?B==8?t[C]=be(n.subarray(c,c+Q),{out:new eA(h)}):sA(14,"unknown compression type "+B):t[C]=Ct(n,c,c+Q))}return t}/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */const qi="172",Gs=0,zr=1,Ki=1,_i=100,Oi=204,Zi=205,Pi=3,qr=0,Wi=300,Xi=1e3,Ce=1001,Vi=1002,Et=1003,ji=1006,Kr=1008,Ye=1009,Mt=1014,_r=1015,Je=1023,Or=1031,Yt=1033,$i="",vA="srgb",An="srgb-linear",tn="linear",Us="srgb",Jt=7680,en=519,sn=35044,Zr="300 es",Ee=2e3,nn=2001;class ce{addEventListener(A,t){this._listeners===void 0&&(this._listeners={});const e=this._listeners;e[A]===void 0&&(e[A]=[]),e[A].indexOf(t)===-1&&e[A].push(t)}hasEventListener(A,t){if(this._listeners===void 0)return!1;const e=this._listeners;return e[A]!==void 0&&e[A].indexOf(t)!==-1}removeEventListener(A,t){if(this._listeners===void 0)return;const s=this._listeners[A];if(s!==void 0){const i=s.indexOf(t);i!==-1&&s.splice(i,1)}}dispatchEvent(A){if(this._listeners===void 0)return;const e=this._listeners[A.type];if(e!==void 0){A.target=this;const s=e.slice(0);for(let i=0,r=s.length;i<r;i++)s[i].call(this,A);A.target=null}}}const EA=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function le(){const n=Math.random()*4294967295|0,A=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0;return(EA[n&255]+EA[n>>8&255]+EA[n>>16&255]+EA[n>>24&255]+"-"+EA[A&255]+EA[A>>8&255]+"-"+EA[A>>16&15|64]+EA[A>>24&255]+"-"+EA[t&63|128]+EA[t>>8&255]+"-"+EA[t>>16&255]+EA[t>>24&255]+EA[e&255]+EA[e>>8&255]+EA[e>>16&255]+EA[e>>24&255]).toLowerCase()}function T(n,A,t){return Math.max(A,Math.min(t,n))}function Pr(n,A){return(n%A+A)%A}function Ls(n,A,t){return(1-t)*n+t*A}function ue(n,A){switch(A.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function wA(n,A){switch(A.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}class DA{constructor(A=0,t=0){DA.prototype.isVector2=!0,this.x=A,this.y=t}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,t){return this.x=A,this.y=t,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const t=this.x,e=this.y,s=A.elements;return this.x=s[0]*t+s[3]*e+s[6],this.y=s[1]*t+s[4]*e+s[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,t){return this.x=T(this.x,A.x,t.x),this.y=T(this.y,A.y,t.y),this}clampScalar(A,t){return this.x=T(this.x,A,t),this.y=T(this.y,A,t),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(T(e,A,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(A){const t=Math.sqrt(this.lengthSq()*A.lengthSq());if(t===0)return Math.PI/2;const e=this.dot(A)/t;return Math.acos(T(e,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const t=this.x-A.x,e=this.y-A.y;return t*t+e*e}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this}rotateAround(A,t){const e=Math.cos(t),s=Math.sin(t),i=this.x-A.x,r=this.y-A.y;return this.x=i*e-r*s+A.x,this.y=i*s+r*e+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class VA{constructor(A,t,e,s,i,r,a,g,o){VA.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,t,e,s,i,r,a,g,o)}set(A,t,e,s,i,r,a,g,o){const I=this.elements;return I[0]=A,I[1]=s,I[2]=a,I[3]=t,I[4]=i,I[5]=g,I[6]=e,I[7]=r,I[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const t=this.elements,e=A.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],this}extractBasis(A,t,e){return A.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),e.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const t=A.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,t){const e=A.elements,s=t.elements,i=this.elements,r=e[0],a=e[3],g=e[6],o=e[1],I=e[4],B=e[7],Q=e[2],h=e[5],C=e[8],E=s[0],l=s[3],c=s[6],u=s[1],d=s[4],y=s[7],w=s[2],x=s[5],M=s[8];return i[0]=r*E+a*u+g*w,i[3]=r*l+a*d+g*x,i[6]=r*c+a*y+g*M,i[1]=o*E+I*u+B*w,i[4]=o*l+I*d+B*x,i[7]=o*c+I*y+B*M,i[2]=Q*E+h*u+C*w,i[5]=Q*l+h*d+C*x,i[8]=Q*c+h*y+C*M,this}multiplyScalar(A){const t=this.elements;return t[0]*=A,t[3]*=A,t[6]*=A,t[1]*=A,t[4]*=A,t[7]*=A,t[2]*=A,t[5]*=A,t[8]*=A,this}determinant(){const A=this.elements,t=A[0],e=A[1],s=A[2],i=A[3],r=A[4],a=A[5],g=A[6],o=A[7],I=A[8];return t*r*I-t*a*o-e*i*I+e*a*g+s*i*o-s*r*g}invert(){const A=this.elements,t=A[0],e=A[1],s=A[2],i=A[3],r=A[4],a=A[5],g=A[6],o=A[7],I=A[8],B=I*r-a*o,Q=a*g-I*i,h=o*i-r*g,C=t*B+e*Q+s*h;if(C===0)return this.set(0,0,0,0,0,0,0,0,0);const E=1/C;return A[0]=B*E,A[1]=(s*o-I*e)*E,A[2]=(a*e-s*r)*E,A[3]=Q*E,A[4]=(I*t-s*g)*E,A[5]=(s*i-a*t)*E,A[6]=h*E,A[7]=(e*g-o*t)*E,A[8]=(r*t-e*i)*E,this}transpose(){let A;const t=this.elements;return A=t[1],t[1]=t[3],t[3]=A,A=t[2],t[2]=t[6],t[6]=A,A=t[5],t[5]=t[7],t[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const t=this.elements;return A[0]=t[0],A[1]=t[3],A[2]=t[6],A[3]=t[1],A[4]=t[4],A[5]=t[7],A[6]=t[2],A[7]=t[5],A[8]=t[8],this}setUvTransform(A,t,e,s,i,r,a){const g=Math.cos(i),o=Math.sin(i);return this.set(e*g,e*o,-e*(g*r+o*a)+r+A,-s*o,s*g,-s*(-o*r+g*a)+a+t,0,0,1),this}scale(A,t){return this.premultiply(bs.makeScale(A,t)),this}rotate(A){return this.premultiply(bs.makeRotation(-A)),this}translate(A,t){return this.premultiply(bs.makeTranslation(A,t)),this}makeTranslation(A,t){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,t,0,0,1),this}makeRotation(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,-e,0,e,t,0,0,0,1),this}makeScale(A,t){return this.set(A,0,0,0,t,0,0,0,1),this}equals(A){const t=this.elements,e=A.elements;for(let s=0;s<9;s++)if(t[s]!==e[s])return!1;return!0}fromArray(A,t=0){for(let e=0;e<9;e++)this.elements[e]=A[e+t];return this}toArray(A=[],t=0){const e=this.elements;return A[t]=e[0],A[t+1]=e[1],A[t+2]=e[2],A[t+3]=e[3],A[t+4]=e[4],A[t+5]=e[5],A[t+6]=e[6],A[t+7]=e[7],A[t+8]=e[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const bs=new VA;function Wr(n){for(let A=n.length-1;A>=0;--A)if(n[A]>=65535)return!0;return!1}function rn(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}const an=new VA().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),gn=new VA().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function Xr(){const n={enabled:!0,workingColorSpace:An,spaces:{},convert:function(s,i,r){return this.enabled===!1||i===r||!i||!r||(this.spaces[i].transfer===Us&&(s.r=tt(s.r),s.g=tt(s.g),s.b=tt(s.b)),this.spaces[i].primaries!==this.spaces[r].primaries&&(s.applyMatrix3(this.spaces[i].toXYZ),s.applyMatrix3(this.spaces[r].fromXYZ)),this.spaces[r].transfer===Us&&(s.r=Ht(s.r),s.g=Ht(s.g),s.b=Ht(s.b))),s},fromWorkingColorSpace:function(s,i){return this.convert(s,this.workingColorSpace,i)},toWorkingColorSpace:function(s,i){return this.convert(s,i,this.workingColorSpace)},getPrimaries:function(s){return this.spaces[s].primaries},getTransfer:function(s){return s===$i?tn:this.spaces[s].transfer},getLuminanceCoefficients:function(s,i=this.workingColorSpace){return s.fromArray(this.spaces[i].luminanceCoefficients)},define:function(s){Object.assign(this.spaces,s)},_getMatrix:function(s,i,r){return s.copy(this.spaces[i].toXYZ).multiply(this.spaces[r].fromXYZ)},_getDrawingBufferColorSpace:function(s){return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(s=this.workingColorSpace){return this.spaces[s].workingColorSpaceConfig.unpackColorSpace}},A=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],e=[.3127,.329];return n.define({[An]:{primaries:A,whitePoint:e,transfer:tn,toXYZ:an,fromXYZ:gn,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:vA},outputColorSpaceConfig:{drawingBufferColorSpace:vA}},[vA]:{primaries:A,whitePoint:e,transfer:Us,toXYZ:an,fromXYZ:gn,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:vA}}}),n}const zA=Xr();function tt(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Ht(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let Tt;class Vr{static getDataURL(A){if(/^data:/i.test(A.src)||typeof HTMLCanvasElement>"u")return A.src;let t;if(A instanceof HTMLCanvasElement)t=A;else{Tt===void 0&&(Tt=rn("canvas")),Tt.width=A.width,Tt.height=A.height;const e=Tt.getContext("2d");A instanceof ImageData?e.putImageData(A,0,0):e.drawImage(A,0,0,A.width,A.height),t=Tt}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(A){if(typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap){const t=rn("canvas");t.width=A.width,t.height=A.height;const e=t.getContext("2d");e.drawImage(A,0,0,A.width,A.height);const s=e.getImageData(0,0,A.width,A.height),i=s.data;for(let r=0;r<i.length;r++)i[r]=tt(i[r]/255)*255;return e.putImageData(s,0,0),t}else if(A.data){const t=A.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(tt(t[e]/255)*255):t[e]=tt(t[e]);return{data:t,width:A.width,height:A.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}let jr=0;class on{constructor(A=null){this.isSource=!0,Object.defineProperty(this,"id",{value:jr++}),this.uuid=le(),this.data=A,this.dataReady=!0,this.version=0}set needsUpdate(A){A===!0&&this.version++}toJSON(A){const t=A===void 0||typeof A=="string";if(!t&&A.images[this.uuid]!==void 0)return A.images[this.uuid];const e={uuid:this.uuid,url:""},s=this.data;if(s!==null){let i;if(Array.isArray(s)){i=[];for(let r=0,a=s.length;r<a;r++)s[r].isDataTexture?i.push(Ys(s[r].image)):i.push(Ys(s[r]))}else i=Ys(s);e.url=i}return t||(A.images[this.uuid]=e),e}}function Ys(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?Vr.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let $r=0;class jA extends ce{constructor(A=jA.DEFAULT_IMAGE,t=jA.DEFAULT_MAPPING,e=Ce,s=Ce,i=ji,r=Kr,a=Je,g=Ye,o=jA.DEFAULT_ANISOTROPY,I=$i){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:$r++}),this.uuid=le(),this.name="",this.source=new on(A),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=e,this.wrapT=s,this.magFilter=i,this.minFilter=r,this.anisotropy=o,this.format=a,this.internalFormat=null,this.type=g,this.offset=new DA(0,0),this.repeat=new DA(1,1),this.center=new DA(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new VA,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=I,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(A=null){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.channel=A.channel,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.colorSpace=A.colorSpace,this.renderTarget=A.renderTarget,this.isRenderTargetTexture=A.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const t=A===void 0||typeof A=="string";if(!t&&A.textures[this.uuid]!==void 0)return A.textures[this.uuid];const e={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(e.userData=this.userData),t||(A.textures[this.uuid]=e),e}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(this.mapping!==Wi)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case Xi:A.x=A.x-Math.floor(A.x);break;case Ce:A.x=A.x<0?0:1;break;case Vi:Math.abs(Math.floor(A.x)%2)===1?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x);break}if(A.y<0||A.y>1)switch(this.wrapT){case Xi:A.y=A.y-Math.floor(A.y);break;case Ce:A.y=A.y<0?0:1;break;case Vi:Math.abs(Math.floor(A.y)%2)===1?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y);break}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){A===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(A){A===!0&&this.pmremVersion++}}jA.DEFAULT_IMAGE=null,jA.DEFAULT_MAPPING=Wi,jA.DEFAULT_ANISOTROPY=1;class fA{constructor(A=0,t=0,e=0,s=1){fA.prototype.isVector4=!0,this.x=A,this.y=t,this.z=e,this.w=s}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,t,e,s){return this.x=A,this.y=t,this.z=e,this.w=s,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=A.w!==void 0?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this.z=A.z+t.z,this.w=A.w+t.w,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this.z+=A.z*t,this.w+=A.w*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this.z=A.z-t.z,this.w=A.w-t.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const t=this.x,e=this.y,s=this.z,i=this.w,r=A.elements;return this.x=r[0]*t+r[4]*e+r[8]*s+r[12]*i,this.y=r[1]*t+r[5]*e+r[9]*s+r[13]*i,this.z=r[2]*t+r[6]*e+r[10]*s+r[14]*i,this.w=r[3]*t+r[7]*e+r[11]*s+r[15]*i,this}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this.w/=A.w,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const t=Math.sqrt(1-A.w*A.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/t,this.y=A.y/t,this.z=A.z/t),this}setAxisAngleFromRotationMatrix(A){let t,e,s,i;const g=A.elements,o=g[0],I=g[4],B=g[8],Q=g[1],h=g[5],C=g[9],E=g[2],l=g[6],c=g[10];if(Math.abs(I-Q)<.01&&Math.abs(B-E)<.01&&Math.abs(C-l)<.01){if(Math.abs(I+Q)<.1&&Math.abs(B+E)<.1&&Math.abs(C+l)<.1&&Math.abs(o+h+c-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const d=(o+1)/2,y=(h+1)/2,w=(c+1)/2,x=(I+Q)/4,M=(B+E)/4,p=(C+l)/4;return d>y&&d>w?d<.01?(e=0,s=.707106781,i=.707106781):(e=Math.sqrt(d),s=x/e,i=M/e):y>w?y<.01?(e=.707106781,s=0,i=.707106781):(s=Math.sqrt(y),e=x/s,i=p/s):w<.01?(e=.707106781,s=.707106781,i=0):(i=Math.sqrt(w),e=M/i,s=p/i),this.set(e,s,i,t),this}let u=Math.sqrt((l-C)*(l-C)+(B-E)*(B-E)+(Q-I)*(Q-I));return Math.abs(u)<.001&&(u=1),this.x=(l-C)/u,this.y=(B-E)/u,this.z=(Q-I)/u,this.w=Math.acos((o+h+c-1)/2),this}setFromMatrixPosition(A){const t=A.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,t){return this.x=T(this.x,A.x,t.x),this.y=T(this.y,A.y,t.y),this.z=T(this.z,A.z,t.z),this.w=T(this.w,A.w,t.w),this}clampScalar(A,t){return this.x=T(this.x,A,t),this.y=T(this.y,A,t),this.z=T(this.z,A,t),this.w=T(this.w,A,t),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(T(e,A,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this.z+=(A.z-this.z)*t,this.w+=(A.w-this.w)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this.z=A.z+(t.z-A.z)*e,this.w=A.w+(t.w-A.w)*e,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this.z=A[t+2],this.w=A[t+3],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A[t+2]=this.z,A[t+3]=this.w,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this.z=A.getZ(t),this.w=A.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Aa extends ce{constructor(A=1,t=1,e={}){super(),this.isRenderTarget=!0,this.width=A,this.height=t,this.depth=1,this.scissor=new fA(0,0,A,t),this.scissorTest=!1,this.viewport=new fA(0,0,A,t);const s={width:A,height:t,depth:1};e=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:ji,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},e);const i=new jA(s,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace);i.flipY=!1,i.generateMipmaps=e.generateMipmaps,i.internalFormat=e.internalFormat,this.textures=[];const r=e.count;for(let a=0;a<r;a++)this.textures[a]=i.clone(),this.textures[a].isRenderTargetTexture=!0,this.textures[a].renderTarget=this;this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=e.depthTexture,this.samples=e.samples}get texture(){return this.textures[0]}set texture(A){this.textures[0]=A}set depthTexture(A){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),A!==null&&(A.renderTarget=this),this._depthTexture=A}get depthTexture(){return this._depthTexture}setSize(A,t,e=1){if(this.width!==A||this.height!==t||this.depth!==e){this.width=A,this.height=t,this.depth=e;for(let s=0,i=this.textures.length;s<i;s++)this.textures[s].image.width=A,this.textures[s].image.height=t,this.textures[s].image.depth=e;this.dispose()}this.viewport.set(0,0,A,t),this.scissor.set(0,0,A,t)}clone(){return new this.constructor().copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.scissor.copy(A.scissor),this.scissorTest=A.scissorTest,this.viewport.copy(A.viewport),this.textures.length=0;for(let e=0,s=A.textures.length;e<s;e++)this.textures[e]=A.textures[e].clone(),this.textures[e].isRenderTargetTexture=!0,this.textures[e].renderTarget=this;const t=Object.assign({},A.texture.image);return this.texture.source=new on(t),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,this.resolveDepthBuffer=A.resolveDepthBuffer,this.resolveStencilBuffer=A.resolveStencilBuffer,A.depthTexture!==null&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class ta extends Aa{constructor(A=1,t=1,e={}){super(A,t,e),this.isWebGLRenderTarget=!0}}class ct extends jA{constructor(A=null,t=1,e=1,s=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:t,height:e,depth:s},this.magFilter=Et,this.minFilter=Et,this.wrapR=Ce,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(A){this.layerUpdates.add(A)}clearLayerUpdates(){this.layerUpdates.clear()}}class In extends ta{constructor(A=1,t=1,e=1,s={}){super(A,t,s),this.isWebGLArrayRenderTarget=!0,this.depth=e,this.texture=new ct(null,A,t,e),this.texture.isRenderTargetTexture=!0}}class gA{constructor(A=0,t=0,e=0,s=1){this.isQuaternion=!0,this._x=A,this._y=t,this._z=e,this._w=s}static slerpFlat(A,t,e,s,i,r,a){let g=e[s+0],o=e[s+1],I=e[s+2],B=e[s+3];const Q=i[r+0],h=i[r+1],C=i[r+2],E=i[r+3];if(a===0){A[t+0]=g,A[t+1]=o,A[t+2]=I,A[t+3]=B;return}if(a===1){A[t+0]=Q,A[t+1]=h,A[t+2]=C,A[t+3]=E;return}if(B!==E||g!==Q||o!==h||I!==C){let l=1-a;const c=g*Q+o*h+I*C+B*E,u=c>=0?1:-1,d=1-c*c;if(d>Number.EPSILON){const w=Math.sqrt(d),x=Math.atan2(w,c*u);l=Math.sin(l*x)/w,a=Math.sin(a*x)/w}const y=a*u;if(g=g*l+Q*y,o=o*l+h*y,I=I*l+C*y,B=B*l+E*y,l===1-a){const w=1/Math.sqrt(g*g+o*o+I*I+B*B);g*=w,o*=w,I*=w,B*=w}}A[t]=g,A[t+1]=o,A[t+2]=I,A[t+3]=B}static multiplyQuaternionsFlat(A,t,e,s,i,r){const a=e[s],g=e[s+1],o=e[s+2],I=e[s+3],B=i[r],Q=i[r+1],h=i[r+2],C=i[r+3];return A[t]=a*C+I*B+g*h-o*Q,A[t+1]=g*C+I*Q+o*B-a*h,A[t+2]=o*C+I*h+a*Q-g*B,A[t+3]=I*C-a*B-g*Q-o*h,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,t,e,s){return this._x=A,this._y=t,this._z=e,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,t=!0){const e=A._x,s=A._y,i=A._z,r=A._order,a=Math.cos,g=Math.sin,o=a(e/2),I=a(s/2),B=a(i/2),Q=g(e/2),h=g(s/2),C=g(i/2);switch(r){case"XYZ":this._x=Q*I*B+o*h*C,this._y=o*h*B-Q*I*C,this._z=o*I*C+Q*h*B,this._w=o*I*B-Q*h*C;break;case"YXZ":this._x=Q*I*B+o*h*C,this._y=o*h*B-Q*I*C,this._z=o*I*C-Q*h*B,this._w=o*I*B+Q*h*C;break;case"ZXY":this._x=Q*I*B-o*h*C,this._y=o*h*B+Q*I*C,this._z=o*I*C+Q*h*B,this._w=o*I*B-Q*h*C;break;case"ZYX":this._x=Q*I*B-o*h*C,this._y=o*h*B+Q*I*C,this._z=o*I*C-Q*h*B,this._w=o*I*B+Q*h*C;break;case"YZX":this._x=Q*I*B+o*h*C,this._y=o*h*B+Q*I*C,this._z=o*I*C-Q*h*B,this._w=o*I*B-Q*h*C;break;case"XZY":this._x=Q*I*B-o*h*C,this._y=o*h*B-Q*I*C,this._z=o*I*C+Q*h*B,this._w=o*I*B+Q*h*C;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,t){const e=t/2,s=Math.sin(e);return this._x=A.x*s,this._y=A.y*s,this._z=A.z*s,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(A){const t=A.elements,e=t[0],s=t[4],i=t[8],r=t[1],a=t[5],g=t[9],o=t[2],I=t[6],B=t[10],Q=e+a+B;if(Q>0){const h=.5/Math.sqrt(Q+1);this._w=.25/h,this._x=(I-g)*h,this._y=(i-o)*h,this._z=(r-s)*h}else if(e>a&&e>B){const h=2*Math.sqrt(1+e-a-B);this._w=(I-g)/h,this._x=.25*h,this._y=(s+r)/h,this._z=(i+o)/h}else if(a>B){const h=2*Math.sqrt(1+a-e-B);this._w=(i-o)/h,this._x=(s+r)/h,this._y=.25*h,this._z=(g+I)/h}else{const h=2*Math.sqrt(1+B-e-a);this._w=(r-s)/h,this._x=(i+o)/h,this._y=(g+I)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(A,t){let e=A.dot(t)+1;return e<Number.EPSILON?(e=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=e):(this._x=0,this._y=-A.z,this._z=A.y,this._w=e)):(this._x=A.y*t.z-A.z*t.y,this._y=A.z*t.x-A.x*t.z,this._z=A.x*t.y-A.y*t.x,this._w=e),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(T(this.dot(A),-1,1)))}rotateTowards(A,t){const e=this.angleTo(A);if(e===0)return this;const s=Math.min(1,t/e);return this.slerp(A,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,t){const e=A._x,s=A._y,i=A._z,r=A._w,a=t._x,g=t._y,o=t._z,I=t._w;return this._x=e*I+r*a+s*o-i*g,this._y=s*I+r*g+i*a-e*o,this._z=i*I+r*o+e*g-s*a,this._w=r*I-e*a-s*g-i*o,this._onChangeCallback(),this}slerp(A,t){if(t===0)return this;if(t===1)return this.copy(A);const e=this._x,s=this._y,i=this._z,r=this._w;let a=r*A._w+e*A._x+s*A._y+i*A._z;if(a<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,a=-a):this.copy(A),a>=1)return this._w=r,this._x=e,this._y=s,this._z=i,this;const g=1-a*a;if(g<=Number.EPSILON){const h=1-t;return this._w=h*r+t*this._w,this._x=h*e+t*this._x,this._y=h*s+t*this._y,this._z=h*i+t*this._z,this.normalize(),this}const o=Math.sqrt(g),I=Math.atan2(o,a),B=Math.sin((1-t)*I)/o,Q=Math.sin(t*I)/o;return this._w=r*B+this._w*Q,this._x=e*B+this._x*Q,this._y=s*B+this._y*Q,this._z=i*B+this._z*Q,this._onChangeCallback(),this}slerpQuaternions(A,t,e){return this.copy(A).slerp(t,e)}random(){const A=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),e=Math.random(),s=Math.sqrt(1-e),i=Math.sqrt(e);return this.set(s*Math.sin(A),s*Math.cos(A),i*Math.sin(t),i*Math.cos(t))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,t=0){return this._x=A[t],this._y=A[t+1],this._z=A[t+2],this._w=A[t+3],this._onChangeCallback(),this}toArray(A=[],t=0){return A[t]=this._x,A[t+1]=this._y,A[t+2]=this._z,A[t+3]=this._w,A}fromBufferAttribute(A,t){return this._x=A.getX(t),this._y=A.getY(t),this._z=A.getZ(t),this._w=A.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class f{constructor(A=0,t=0,e=0){f.prototype.isVector3=!0,this.x=A,this.y=t,this.z=e}set(A,t,e){return e===void 0&&(e=this.z),this.x=A,this.y=t,this.z=e,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this.z=A.z+t.z,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this.z+=A.z*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this.z=A.z-t.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,t){return this.x=A.x*t.x,this.y=A.y*t.y,this.z=A.z*t.z,this}applyEuler(A){return this.applyQuaternion(Bn.setFromEuler(A))}applyAxisAngle(A,t){return this.applyQuaternion(Bn.setFromAxisAngle(A,t))}applyMatrix3(A){const t=this.x,e=this.y,s=this.z,i=A.elements;return this.x=i[0]*t+i[3]*e+i[6]*s,this.y=i[1]*t+i[4]*e+i[7]*s,this.z=i[2]*t+i[5]*e+i[8]*s,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const t=this.x,e=this.y,s=this.z,i=A.elements,r=1/(i[3]*t+i[7]*e+i[11]*s+i[15]);return this.x=(i[0]*t+i[4]*e+i[8]*s+i[12])*r,this.y=(i[1]*t+i[5]*e+i[9]*s+i[13])*r,this.z=(i[2]*t+i[6]*e+i[10]*s+i[14])*r,this}applyQuaternion(A){const t=this.x,e=this.y,s=this.z,i=A.x,r=A.y,a=A.z,g=A.w,o=2*(r*s-a*e),I=2*(a*t-i*s),B=2*(i*e-r*t);return this.x=t+g*o+r*B-a*I,this.y=e+g*I+a*o-i*B,this.z=s+g*B+i*I-r*o,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const t=this.x,e=this.y,s=this.z,i=A.elements;return this.x=i[0]*t+i[4]*e+i[8]*s,this.y=i[1]*t+i[5]*e+i[9]*s,this.z=i[2]*t+i[6]*e+i[10]*s,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,t){return this.x=T(this.x,A.x,t.x),this.y=T(this.y,A.y,t.y),this.z=T(this.z,A.z,t.z),this}clampScalar(A,t){return this.x=T(this.x,A,t),this.y=T(this.y,A,t),this.z=T(this.z,A,t),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(T(e,A,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this.z+=(A.z-this.z)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this.z=A.z+(t.z-A.z)*e,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,t){const e=A.x,s=A.y,i=A.z,r=t.x,a=t.y,g=t.z;return this.x=s*g-i*a,this.y=i*r-e*g,this.z=e*a-s*r,this}projectOnVector(A){const t=A.lengthSq();if(t===0)return this.set(0,0,0);const e=A.dot(this)/t;return this.copy(A).multiplyScalar(e)}projectOnPlane(A){return Js.copy(this).projectOnVector(A),this.sub(Js)}reflect(A){return this.sub(Js.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const t=Math.sqrt(this.lengthSq()*A.lengthSq());if(t===0)return Math.PI/2;const e=this.dot(A)/t;return Math.acos(T(e,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const t=this.x-A.x,e=this.y-A.y,s=this.z-A.z;return t*t+e*e+s*s}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,t,e){const s=Math.sin(t)*A;return this.x=s*Math.sin(e),this.y=Math.cos(t)*A,this.z=s*Math.cos(e),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,t,e){return this.x=A*Math.sin(t),this.y=e,this.z=A*Math.cos(t),this}setFromMatrixPosition(A){const t=A.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(A){const t=this.setFromMatrixColumn(A,0).length(),e=this.setFromMatrixColumn(A,1).length(),s=this.setFromMatrixColumn(A,2).length();return this.x=t,this.y=e,this.z=s,this}setFromMatrixColumn(A,t){return this.fromArray(A.elements,t*4)}setFromMatrix3Column(A,t){return this.fromArray(A.elements,t*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this.z=A[t+2],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A[t+2]=this.z,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this.z=A.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,t=Math.random()*2-1,e=Math.sqrt(1-t*t);return this.x=e*Math.cos(A),this.y=t,this.z=e*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Js=new f,Bn=new gA;class vt{constructor(A=new f(1/0,1/0,1/0),t=new f(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=t}set(A,t){return this.min.copy(A),this.max.copy(t),this}setFromArray(A){this.makeEmpty();for(let t=0,e=A.length;t<e;t+=3)this.expandByPoint(qA.fromArray(A,t));return this}setFromBufferAttribute(A){this.makeEmpty();for(let t=0,e=A.count;t<e;t++)this.expandByPoint(qA.fromBufferAttribute(A,t));return this}setFromPoints(A){this.makeEmpty();for(let t=0,e=A.length;t<e;t++)this.expandByPoint(A[t]);return this}setFromCenterAndSize(A,t){const e=qA.copy(t).multiplyScalar(.5);return this.min.copy(A).sub(e),this.max.copy(A).add(e),this}setFromObject(A,t=!1){return this.makeEmpty(),this.expandByObject(A,t)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,t=!1){A.updateWorldMatrix(!1,!1);const e=A.geometry;if(e!==void 0){const i=e.getAttribute("position");if(t===!0&&i!==void 0&&A.isInstancedMesh!==!0)for(let r=0,a=i.count;r<a;r++)A.isMesh===!0?A.getVertexPosition(r,qA):qA.fromBufferAttribute(i,r),qA.applyMatrix4(A.matrixWorld),this.expandByPoint(qA);else A.boundingBox!==void 0?(A.boundingBox===null&&A.computeBoundingBox(),He.copy(A.boundingBox)):(e.boundingBox===null&&e.computeBoundingBox(),He.copy(e.boundingBox)),He.applyMatrix4(A.matrixWorld),this.union(He)}const s=A.children;for(let i=0,r=s.length;i<r;i++)this.expandByObject(s[i],t);return this}containsPoint(A){return A.x>=this.min.x&&A.x<=this.max.x&&A.y>=this.min.y&&A.y<=this.max.y&&A.z>=this.min.z&&A.z<=this.max.z}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,t){return t.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return A.max.x>=this.min.x&&A.min.x<=this.max.x&&A.max.y>=this.min.y&&A.min.y<=this.max.y&&A.max.z>=this.min.z&&A.min.z<=this.max.z}intersectsSphere(A){return this.clampPoint(A.center,qA),qA.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let t,e;return A.normal.x>0?(t=A.normal.x*this.min.x,e=A.normal.x*this.max.x):(t=A.normal.x*this.max.x,e=A.normal.x*this.min.x),A.normal.y>0?(t+=A.normal.y*this.min.y,e+=A.normal.y*this.max.y):(t+=A.normal.y*this.max.y,e+=A.normal.y*this.min.y),A.normal.z>0?(t+=A.normal.z*this.min.z,e+=A.normal.z*this.max.z):(t+=A.normal.z*this.max.z,e+=A.normal.z*this.min.z),t<=-A.constant&&e>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(de),Te.subVectors(this.max,de),zt.subVectors(A.a,de),qt.subVectors(A.b,de),Kt.subVectors(A.c,de),lt.subVectors(qt,zt),ut.subVectors(Kt,qt),St.subVectors(zt,Kt);let t=[0,-lt.z,lt.y,0,-ut.z,ut.y,0,-St.z,St.y,lt.z,0,-lt.x,ut.z,0,-ut.x,St.z,0,-St.x,-lt.y,lt.x,0,-ut.y,ut.x,0,-St.y,St.x,0];return!Hs(t,zt,qt,Kt,Te)||(t=[1,0,0,0,1,0,0,0,1],!Hs(t,zt,qt,Kt,Te))?!1:(ve.crossVectors(lt,ut),t=[ve.x,ve.y,ve.z],Hs(t,zt,qt,Kt,Te))}clampPoint(A,t){return t.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,qA).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(qA).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(et[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),et[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),et[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),et[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),et[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),et[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),et[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),et[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(et),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const et=[new f,new f,new f,new f,new f,new f,new f,new f],qA=new f,He=new vt,zt=new f,qt=new f,Kt=new f,lt=new f,ut=new f,St=new f,de=new f,Te=new f,ve=new f,Ft=new f;function Hs(n,A,t,e,s){for(let i=0,r=n.length-3;i<=r;i+=3){Ft.fromArray(n,i);const a=s.x*Math.abs(Ft.x)+s.y*Math.abs(Ft.y)+s.z*Math.abs(Ft.z),g=A.dot(Ft),o=t.dot(Ft),I=e.dot(Ft);if(Math.max(-Math.max(g,o,I),Math.min(g,o,I))>a)return!1}return!0}const ea=new vt,fe=new f,Ts=new f;class Qn{constructor(A=new f,t=-1){this.isSphere=!0,this.center=A,this.radius=t}set(A,t){return this.center.copy(A),this.radius=t,this}setFromPoints(A,t){const e=this.center;t!==void 0?e.copy(t):ea.setFromPoints(A).getCenter(e);let s=0;for(let i=0,r=A.length;i<r;i++)s=Math.max(s,e.distanceToSquared(A[i]));return this.radius=Math.sqrt(s),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const t=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=t*t}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,t){const e=this.center.distanceToSquared(A);return t.copy(A),e>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;fe.subVectors(A,this.center);const t=fe.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),s=(e-this.radius)*.5;this.center.addScaledVector(fe,s/e),this.radius+=s}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(this.center.equals(A.center)===!0?this.radius=Math.max(this.radius,A.radius):(Ts.subVectors(A.center,this.center).setLength(A.radius),this.expandByPoint(fe.copy(A.center).add(Ts)),this.expandByPoint(fe.copy(A.center).sub(Ts))),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return new this.constructor().copy(this)}}const st=new f,vs=new f,ze=new f,dt=new f,zs=new f,qe=new f,qs=new f;class sa{constructor(A=new f,t=new f(0,0,-1)){this.origin=A,this.direction=t}set(A,t){return this.origin.copy(A),this.direction.copy(t),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,t){return t.copy(this.origin).addScaledVector(this.direction,A)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,st)),this}closestPointToPoint(A,t){t.subVectors(A,this.origin);const e=t.dot(this.direction);return e<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,e)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const t=st.subVectors(A,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(A):(st.copy(this.origin).addScaledVector(this.direction,t),st.distanceToSquared(A))}distanceSqToSegment(A,t,e,s){vs.copy(A).add(t).multiplyScalar(.5),ze.copy(t).sub(A).normalize(),dt.copy(this.origin).sub(vs);const i=A.distanceTo(t)*.5,r=-this.direction.dot(ze),a=dt.dot(this.direction),g=-dt.dot(ze),o=dt.lengthSq(),I=Math.abs(1-r*r);let B,Q,h,C;if(I>0)if(B=r*g-a,Q=r*a-g,C=i*I,B>=0)if(Q>=-C)if(Q<=C){const E=1/I;B*=E,Q*=E,h=B*(B+r*Q+2*a)+Q*(r*B+Q+2*g)+o}else Q=i,B=Math.max(0,-(r*Q+a)),h=-B*B+Q*(Q+2*g)+o;else Q=-i,B=Math.max(0,-(r*Q+a)),h=-B*B+Q*(Q+2*g)+o;else Q<=-C?(B=Math.max(0,-(-r*i+a)),Q=B>0?-i:Math.min(Math.max(-i,-g),i),h=-B*B+Q*(Q+2*g)+o):Q<=C?(B=0,Q=Math.min(Math.max(-i,-g),i),h=Q*(Q+2*g)+o):(B=Math.max(0,-(r*i+a)),Q=B>0?i:Math.min(Math.max(-i,-g),i),h=-B*B+Q*(Q+2*g)+o);else Q=r>0?-i:i,B=Math.max(0,-(r*Q+a)),h=-B*B+Q*(Q+2*g)+o;return e&&e.copy(this.origin).addScaledVector(this.direction,B),s&&s.copy(vs).addScaledVector(ze,Q),h}intersectSphere(A,t){st.subVectors(A.center,this.origin);const e=st.dot(this.direction),s=st.dot(st)-e*e,i=A.radius*A.radius;if(s>i)return null;const r=Math.sqrt(i-s),a=e-r,g=e+r;return g<0?null:a<0?this.at(g,t):this.at(a,t)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const t=A.normal.dot(this.direction);if(t===0)return A.distanceToPoint(this.origin)===0?0:null;const e=-(this.origin.dot(A.normal)+A.constant)/t;return e>=0?e:null}intersectPlane(A,t){const e=this.distanceToPlane(A);return e===null?null:this.at(e,t)}intersectsPlane(A){const t=A.distanceToPoint(this.origin);return t===0||A.normal.dot(this.direction)*t<0}intersectBox(A,t){let e,s,i,r,a,g;const o=1/this.direction.x,I=1/this.direction.y,B=1/this.direction.z,Q=this.origin;return o>=0?(e=(A.min.x-Q.x)*o,s=(A.max.x-Q.x)*o):(e=(A.max.x-Q.x)*o,s=(A.min.x-Q.x)*o),I>=0?(i=(A.min.y-Q.y)*I,r=(A.max.y-Q.y)*I):(i=(A.max.y-Q.y)*I,r=(A.min.y-Q.y)*I),e>r||i>s||((i>e||isNaN(e))&&(e=i),(r<s||isNaN(s))&&(s=r),B>=0?(a=(A.min.z-Q.z)*B,g=(A.max.z-Q.z)*B):(a=(A.max.z-Q.z)*B,g=(A.min.z-Q.z)*B),e>g||a>s)||((a>e||e!==e)&&(e=a),(g<s||s!==s)&&(s=g),s<0)?null:this.at(e>=0?e:s,t)}intersectsBox(A){return this.intersectBox(A,st)!==null}intersectTriangle(A,t,e,s,i){zs.subVectors(t,A),qe.subVectors(e,A),qs.crossVectors(zs,qe);let r=this.direction.dot(qs),a;if(r>0){if(s)return null;a=1}else if(r<0)a=-1,r=-r;else return null;dt.subVectors(this.origin,A);const g=a*this.direction.dot(qe.crossVectors(dt,qe));if(g<0)return null;const o=a*this.direction.dot(zs.cross(dt));if(o<0||g+o>r)return null;const I=-a*dt.dot(qs);return I<0?null:this.at(I/r,i)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class cA{constructor(A,t,e,s,i,r,a,g,o,I,B,Q,h,C,E,l){cA.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],A!==void 0&&this.set(A,t,e,s,i,r,a,g,o,I,B,Q,h,C,E,l)}set(A,t,e,s,i,r,a,g,o,I,B,Q,h,C,E,l){const c=this.elements;return c[0]=A,c[4]=t,c[8]=e,c[12]=s,c[1]=i,c[5]=r,c[9]=a,c[13]=g,c[2]=o,c[6]=I,c[10]=B,c[14]=Q,c[3]=h,c[7]=C,c[11]=E,c[15]=l,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new cA().fromArray(this.elements)}copy(A){const t=this.elements,e=A.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],this}copyPosition(A){const t=this.elements,e=A.elements;return t[12]=e[12],t[13]=e[13],t[14]=e[14],this}setFromMatrix3(A){const t=A.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(A,t,e){return A.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(A,t,e){return this.set(A.x,t.x,e.x,0,A.y,t.y,e.y,0,A.z,t.z,e.z,0,0,0,0,1),this}extractRotation(A){const t=this.elements,e=A.elements,s=1/_t.setFromMatrixColumn(A,0).length(),i=1/_t.setFromMatrixColumn(A,1).length(),r=1/_t.setFromMatrixColumn(A,2).length();return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t[3]=0,t[4]=e[4]*i,t[5]=e[5]*i,t[6]=e[6]*i,t[7]=0,t[8]=e[8]*r,t[9]=e[9]*r,t[10]=e[10]*r,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(A){const t=this.elements,e=A.x,s=A.y,i=A.z,r=Math.cos(e),a=Math.sin(e),g=Math.cos(s),o=Math.sin(s),I=Math.cos(i),B=Math.sin(i);if(A.order==="XYZ"){const Q=r*I,h=r*B,C=a*I,E=a*B;t[0]=g*I,t[4]=-g*B,t[8]=o,t[1]=h+C*o,t[5]=Q-E*o,t[9]=-a*g,t[2]=E-Q*o,t[6]=C+h*o,t[10]=r*g}else if(A.order==="YXZ"){const Q=g*I,h=g*B,C=o*I,E=o*B;t[0]=Q+E*a,t[4]=C*a-h,t[8]=r*o,t[1]=r*B,t[5]=r*I,t[9]=-a,t[2]=h*a-C,t[6]=E+Q*a,t[10]=r*g}else if(A.order==="ZXY"){const Q=g*I,h=g*B,C=o*I,E=o*B;t[0]=Q-E*a,t[4]=-r*B,t[8]=C+h*a,t[1]=h+C*a,t[5]=r*I,t[9]=E-Q*a,t[2]=-r*o,t[6]=a,t[10]=r*g}else if(A.order==="ZYX"){const Q=r*I,h=r*B,C=a*I,E=a*B;t[0]=g*I,t[4]=C*o-h,t[8]=Q*o+E,t[1]=g*B,t[5]=E*o+Q,t[9]=h*o-C,t[2]=-o,t[6]=a*g,t[10]=r*g}else if(A.order==="YZX"){const Q=r*g,h=r*o,C=a*g,E=a*o;t[0]=g*I,t[4]=E-Q*B,t[8]=C*B+h,t[1]=B,t[5]=r*I,t[9]=-a*I,t[2]=-o*I,t[6]=h*B+C,t[10]=Q-E*B}else if(A.order==="XZY"){const Q=r*g,h=r*o,C=a*g,E=a*o;t[0]=g*I,t[4]=-B,t[8]=o*I,t[1]=Q*B+E,t[5]=r*I,t[9]=h*B-C,t[2]=C*B-h,t[6]=a*I,t[10]=E*B+Q}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(A){return this.compose(ia,A,na)}lookAt(A,t,e){const s=this.elements;return NA.subVectors(A,t),NA.lengthSq()===0&&(NA.z=1),NA.normalize(),ft.crossVectors(e,NA),ft.lengthSq()===0&&(Math.abs(e.z)===1?NA.x+=1e-4:NA.z+=1e-4,NA.normalize(),ft.crossVectors(e,NA)),ft.normalize(),Ke.crossVectors(NA,ft),s[0]=ft.x,s[4]=Ke.x,s[8]=NA.x,s[1]=ft.y,s[5]=Ke.y,s[9]=NA.y,s[2]=ft.z,s[6]=Ke.z,s[10]=NA.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,t){const e=A.elements,s=t.elements,i=this.elements,r=e[0],a=e[4],g=e[8],o=e[12],I=e[1],B=e[5],Q=e[9],h=e[13],C=e[2],E=e[6],l=e[10],c=e[14],u=e[3],d=e[7],y=e[11],w=e[15],x=s[0],M=s[4],p=s[8],D=s[12],F=s[1],m=s[5],S=s[9],N=s[13],k=s[2],G=s[6],R=s[10],L=s[14],W=s[3],_=s[7],j=s[11],X=s[15];return i[0]=r*x+a*F+g*k+o*W,i[4]=r*M+a*m+g*G+o*_,i[8]=r*p+a*S+g*R+o*j,i[12]=r*D+a*N+g*L+o*X,i[1]=I*x+B*F+Q*k+h*W,i[5]=I*M+B*m+Q*G+h*_,i[9]=I*p+B*S+Q*R+h*j,i[13]=I*D+B*N+Q*L+h*X,i[2]=C*x+E*F+l*k+c*W,i[6]=C*M+E*m+l*G+c*_,i[10]=C*p+E*S+l*R+c*j,i[14]=C*D+E*N+l*L+c*X,i[3]=u*x+d*F+y*k+w*W,i[7]=u*M+d*m+y*G+w*_,i[11]=u*p+d*S+y*R+w*j,i[15]=u*D+d*N+y*L+w*X,this}multiplyScalar(A){const t=this.elements;return t[0]*=A,t[4]*=A,t[8]*=A,t[12]*=A,t[1]*=A,t[5]*=A,t[9]*=A,t[13]*=A,t[2]*=A,t[6]*=A,t[10]*=A,t[14]*=A,t[3]*=A,t[7]*=A,t[11]*=A,t[15]*=A,this}determinant(){const A=this.elements,t=A[0],e=A[4],s=A[8],i=A[12],r=A[1],a=A[5],g=A[9],o=A[13],I=A[2],B=A[6],Q=A[10],h=A[14],C=A[3],E=A[7],l=A[11],c=A[15];return C*(+i*g*B-s*o*B-i*a*Q+e*o*Q+s*a*h-e*g*h)+E*(+t*g*h-t*o*Q+i*r*Q-s*r*h+s*o*I-i*g*I)+l*(+t*o*B-t*a*h-i*r*B+e*r*h+i*a*I-e*o*I)+c*(-s*a*I-t*g*B+t*a*Q+s*r*B-e*r*Q+e*g*I)}transpose(){const A=this.elements;let t;return t=A[1],A[1]=A[4],A[4]=t,t=A[2],A[2]=A[8],A[8]=t,t=A[6],A[6]=A[9],A[9]=t,t=A[3],A[3]=A[12],A[12]=t,t=A[7],A[7]=A[13],A[13]=t,t=A[11],A[11]=A[14],A[14]=t,this}setPosition(A,t,e){const s=this.elements;return A.isVector3?(s[12]=A.x,s[13]=A.y,s[14]=A.z):(s[12]=A,s[13]=t,s[14]=e),this}invert(){const A=this.elements,t=A[0],e=A[1],s=A[2],i=A[3],r=A[4],a=A[5],g=A[6],o=A[7],I=A[8],B=A[9],Q=A[10],h=A[11],C=A[12],E=A[13],l=A[14],c=A[15],u=B*l*o-E*Q*o+E*g*h-a*l*h-B*g*c+a*Q*c,d=C*Q*o-I*l*o-C*g*h+r*l*h+I*g*c-r*Q*c,y=I*E*o-C*B*o+C*a*h-r*E*h-I*a*c+r*B*c,w=C*B*g-I*E*g-C*a*Q+r*E*Q+I*a*l-r*B*l,x=t*u+e*d+s*y+i*w;if(x===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const M=1/x;return A[0]=u*M,A[1]=(E*Q*i-B*l*i-E*s*h+e*l*h+B*s*c-e*Q*c)*M,A[2]=(a*l*i-E*g*i+E*s*o-e*l*o-a*s*c+e*g*c)*M,A[3]=(B*g*i-a*Q*i-B*s*o+e*Q*o+a*s*h-e*g*h)*M,A[4]=d*M,A[5]=(I*l*i-C*Q*i+C*s*h-t*l*h-I*s*c+t*Q*c)*M,A[6]=(C*g*i-r*l*i-C*s*o+t*l*o+r*s*c-t*g*c)*M,A[7]=(r*Q*i-I*g*i+I*s*o-t*Q*o-r*s*h+t*g*h)*M,A[8]=y*M,A[9]=(C*B*i-I*E*i-C*e*h+t*E*h+I*e*c-t*B*c)*M,A[10]=(r*E*i-C*a*i+C*e*o-t*E*o-r*e*c+t*a*c)*M,A[11]=(I*a*i-r*B*i-I*e*o+t*B*o+r*e*h-t*a*h)*M,A[12]=w*M,A[13]=(I*E*s-C*B*s+C*e*Q-t*E*Q-I*e*l+t*B*l)*M,A[14]=(C*a*s-r*E*s-C*e*g+t*E*g+r*e*l-t*a*l)*M,A[15]=(r*B*s-I*a*s+I*e*g-t*B*g-r*e*Q+t*a*Q)*M,this}scale(A){const t=this.elements,e=A.x,s=A.y,i=A.z;return t[0]*=e,t[4]*=s,t[8]*=i,t[1]*=e,t[5]*=s,t[9]*=i,t[2]*=e,t[6]*=s,t[10]*=i,t[3]*=e,t[7]*=s,t[11]*=i,this}getMaxScaleOnAxis(){const A=this.elements,t=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],e=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],s=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(t,e,s))}makeTranslation(A,t,e){return A.isVector3?this.set(1,0,0,A.x,0,1,0,A.y,0,0,1,A.z,0,0,0,1):this.set(1,0,0,A,0,1,0,t,0,0,1,e,0,0,0,1),this}makeRotationX(A){const t=Math.cos(A),e=Math.sin(A);return this.set(1,0,0,0,0,t,-e,0,0,e,t,0,0,0,0,1),this}makeRotationY(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,0,e,0,0,1,0,0,-e,0,t,0,0,0,0,1),this}makeRotationZ(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,-e,0,0,e,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,t){const e=Math.cos(t),s=Math.sin(t),i=1-e,r=A.x,a=A.y,g=A.z,o=i*r,I=i*a;return this.set(o*r+e,o*a-s*g,o*g+s*a,0,o*a+s*g,I*a+e,I*g-s*r,0,o*g-s*a,I*g+s*r,i*g*g+e,0,0,0,0,1),this}makeScale(A,t,e){return this.set(A,0,0,0,0,t,0,0,0,0,e,0,0,0,0,1),this}makeShear(A,t,e,s,i,r){return this.set(1,e,i,0,A,1,r,0,t,s,1,0,0,0,0,1),this}compose(A,t,e){const s=this.elements,i=t._x,r=t._y,a=t._z,g=t._w,o=i+i,I=r+r,B=a+a,Q=i*o,h=i*I,C=i*B,E=r*I,l=r*B,c=a*B,u=g*o,d=g*I,y=g*B,w=e.x,x=e.y,M=e.z;return s[0]=(1-(E+c))*w,s[1]=(h+y)*w,s[2]=(C-d)*w,s[3]=0,s[4]=(h-y)*x,s[5]=(1-(Q+c))*x,s[6]=(l+u)*x,s[7]=0,s[8]=(C+d)*M,s[9]=(l-u)*M,s[10]=(1-(Q+E))*M,s[11]=0,s[12]=A.x,s[13]=A.y,s[14]=A.z,s[15]=1,this}decompose(A,t,e){const s=this.elements;let i=_t.set(s[0],s[1],s[2]).length();const r=_t.set(s[4],s[5],s[6]).length(),a=_t.set(s[8],s[9],s[10]).length();this.determinant()<0&&(i=-i),A.x=s[12],A.y=s[13],A.z=s[14],KA.copy(this);const o=1/i,I=1/r,B=1/a;return KA.elements[0]*=o,KA.elements[1]*=o,KA.elements[2]*=o,KA.elements[4]*=I,KA.elements[5]*=I,KA.elements[6]*=I,KA.elements[8]*=B,KA.elements[9]*=B,KA.elements[10]*=B,t.setFromRotationMatrix(KA),e.x=i,e.y=r,e.z=a,this}makePerspective(A,t,e,s,i,r,a=Ee){const g=this.elements,o=2*i/(t-A),I=2*i/(e-s),B=(t+A)/(t-A),Q=(e+s)/(e-s);let h,C;if(a===Ee)h=-(r+i)/(r-i),C=-2*r*i/(r-i);else if(a===nn)h=-r/(r-i),C=-r*i/(r-i);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return g[0]=o,g[4]=0,g[8]=B,g[12]=0,g[1]=0,g[5]=I,g[9]=Q,g[13]=0,g[2]=0,g[6]=0,g[10]=h,g[14]=C,g[3]=0,g[7]=0,g[11]=-1,g[15]=0,this}makeOrthographic(A,t,e,s,i,r,a=Ee){const g=this.elements,o=1/(t-A),I=1/(e-s),B=1/(r-i),Q=(t+A)*o,h=(e+s)*I;let C,E;if(a===Ee)C=(r+i)*B,E=-2*B;else if(a===nn)C=i*B,E=-1*B;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return g[0]=2*o,g[4]=0,g[8]=0,g[12]=-Q,g[1]=0,g[5]=2*I,g[9]=0,g[13]=-h,g[2]=0,g[6]=0,g[10]=E,g[14]=-C,g[3]=0,g[7]=0,g[11]=0,g[15]=1,this}equals(A){const t=this.elements,e=A.elements;for(let s=0;s<16;s++)if(t[s]!==e[s])return!1;return!0}fromArray(A,t=0){for(let e=0;e<16;e++)this.elements[e]=A[e+t];return this}toArray(A=[],t=0){const e=this.elements;return A[t]=e[0],A[t+1]=e[1],A[t+2]=e[2],A[t+3]=e[3],A[t+4]=e[4],A[t+5]=e[5],A[t+6]=e[6],A[t+7]=e[7],A[t+8]=e[8],A[t+9]=e[9],A[t+10]=e[10],A[t+11]=e[11],A[t+12]=e[12],A[t+13]=e[13],A[t+14]=e[14],A[t+15]=e[15],A}}const _t=new f,KA=new cA,ia=new f(0,0,0),na=new f(1,1,1),ft=new f,Ke=new f,NA=new f,hn=new cA,Cn=new gA;class Nt{constructor(A=0,t=0,e=0,s=Nt.DEFAULT_ORDER){this.isEuler=!0,this._x=A,this._y=t,this._z=e,this._order=s}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,t,e,s=this._order){return this._x=A,this._y=t,this._z=e,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,t=this._order,e=!0){const s=A.elements,i=s[0],r=s[4],a=s[8],g=s[1],o=s[5],I=s[9],B=s[2],Q=s[6],h=s[10];switch(t){case"XYZ":this._y=Math.asin(T(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-I,h),this._z=Math.atan2(-r,i)):(this._x=Math.atan2(Q,o),this._z=0);break;case"YXZ":this._x=Math.asin(-T(I,-1,1)),Math.abs(I)<.9999999?(this._y=Math.atan2(a,h),this._z=Math.atan2(g,o)):(this._y=Math.atan2(-B,i),this._z=0);break;case"ZXY":this._x=Math.asin(T(Q,-1,1)),Math.abs(Q)<.9999999?(this._y=Math.atan2(-B,h),this._z=Math.atan2(-r,o)):(this._y=0,this._z=Math.atan2(g,i));break;case"ZYX":this._y=Math.asin(-T(B,-1,1)),Math.abs(B)<.9999999?(this._x=Math.atan2(Q,h),this._z=Math.atan2(g,i)):(this._x=0,this._z=Math.atan2(-r,o));break;case"YZX":this._z=Math.asin(T(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(-I,o),this._y=Math.atan2(-B,i)):(this._x=0,this._y=Math.atan2(a,h));break;case"XZY":this._z=Math.asin(-T(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(Q,o),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-I,h),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,e===!0&&this._onChangeCallback(),this}setFromQuaternion(A,t,e){return hn.makeRotationFromQuaternion(A),this.setFromRotationMatrix(hn,t,e)}setFromVector3(A,t=this._order){return this.set(A.x,A.y,A.z,t)}reorder(A){return Cn.setFromEuler(this),this.setFromQuaternion(Cn,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],A[3]!==void 0&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],t=0){return A[t]=this._x,A[t+1]=this._y,A[t+2]=this._z,A[t+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Nt.DEFAULT_ORDER="XYZ";class ra{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return(this.mask&A.mask)!==0}isEnabled(A){return(this.mask&(1<<A|0))!==0}}let aa=0;const En=new f,Ot=new gA,it=new cA,_e=new f,ye=new f,ga=new f,oa=new gA,cn=new f(1,0,0),ln=new f(0,1,0),un=new f(0,0,1),dn={type:"added"},Ia={type:"removed"},Zt={type:"childadded",child:null},Ks={type:"childremoved",child:null};class mA extends ce{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:aa++}),this.uuid=le(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=mA.DEFAULT_UP.clone();const A=new f,t=new Nt,e=new gA,s=new f(1,1,1);function i(){e.setFromEuler(t,!1)}function r(){t.setFromQuaternion(e,void 0,!1)}t._onChange(i),e._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:e},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new cA},normalMatrix:{value:new VA}}),this.matrix=new cA,this.matrixWorld=new cA,this.matrixAutoUpdate=mA.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=mA.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new ra,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,t){this.quaternion.setFromAxisAngle(A,t)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,t){return Ot.setFromAxisAngle(A,t),this.quaternion.multiply(Ot),this}rotateOnWorldAxis(A,t){return Ot.setFromAxisAngle(A,t),this.quaternion.premultiply(Ot),this}rotateX(A){return this.rotateOnAxis(cn,A)}rotateY(A){return this.rotateOnAxis(ln,A)}rotateZ(A){return this.rotateOnAxis(un,A)}translateOnAxis(A,t){return En.copy(A).applyQuaternion(this.quaternion),this.position.add(En.multiplyScalar(t)),this}translateX(A){return this.translateOnAxis(cn,A)}translateY(A){return this.translateOnAxis(ln,A)}translateZ(A){return this.translateOnAxis(un,A)}localToWorld(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(it.copy(this.matrixWorld).invert())}lookAt(A,t,e){A.isVector3?_e.copy(A):_e.set(A,t,e);const s=this.parent;this.updateWorldMatrix(!0,!1),ye.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?it.lookAt(ye,_e,this.up):it.lookAt(_e,ye,this.up),this.quaternion.setFromRotationMatrix(it),s&&(it.extractRotation(s.matrixWorld),Ot.setFromRotationMatrix(it),this.quaternion.premultiply(Ot.invert()))}add(A){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return A===this?(console.error("THREE.Object3D.add: object can\'t be added as a child of itself.",A),this):(A&&A.isObject3D?(A.removeFromParent(),A.parent=this,this.children.push(A),A.dispatchEvent(dn),Zt.child=A,this.dispatchEvent(Zt),Zt.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(A);return t!==-1&&(A.parent=null,this.children.splice(t,1),A.dispatchEvent(Ia),Ks.child=A,this.dispatchEvent(Ks),Ks.child=null),this}removeFromParent(){const A=this.parent;return A!==null&&A.remove(this),this}clear(){return this.remove(...this.children)}attach(A){return this.updateWorldMatrix(!0,!1),it.copy(this.matrixWorld).invert(),A.parent!==null&&(A.parent.updateWorldMatrix(!0,!1),it.multiply(A.parent.matrixWorld)),A.applyMatrix4(it),A.removeFromParent(),A.parent=this,this.children.push(A),A.updateWorldMatrix(!1,!0),A.dispatchEvent(dn),Zt.child=A,this.dispatchEvent(Zt),Zt.child=null,this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,t){if(this[A]===t)return this;for(let e=0,s=this.children.length;e<s;e++){const r=this.children[e].getObjectByProperty(A,t);if(r!==void 0)return r}}getObjectsByProperty(A,t,e=[]){this[A]===t&&e.push(this);const s=this.children;for(let i=0,r=s.length;i<r;i++)s[i].getObjectsByProperty(A,t,e);return e}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ye,A,ga),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(ye,oa,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return A.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(A){A(this);const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].traverse(A)}traverseVisible(A){if(this.visible===!1)return;A(this);const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].traverseVisible(A)}traverseAncestors(A){const t=this.parent;t!==null&&(A(t),t.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,A=!0);const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].updateMatrixWorld(A)}updateWorldMatrix(A,t){const e=this.parent;if(A===!0&&e!==null&&e.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const s=this.children;for(let i=0,r=s.length;i<r;i++)s[i].updateWorldMatrix(!1,!0)}}toJSON(A){const t=A===void 0||typeof A=="string",e={};t&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},e.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),s.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(s.type="BatchedMesh",s.perObjectFrustumCulled=this.perObjectFrustumCulled,s.sortObjects=this.sortObjects,s.drawRanges=this._drawRanges,s.reservedRanges=this._reservedRanges,s.visibility=this._visibility,s.active=this._active,s.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),s.maxInstanceCount=this._maxInstanceCount,s.maxVertexCount=this._maxVertexCount,s.maxIndexCount=this._maxIndexCount,s.geometryInitialized=this._geometryInitialized,s.geometryCount=this._geometryCount,s.matricesTexture=this._matricesTexture.toJSON(A),this._colorsTexture!==null&&(s.colorsTexture=this._colorsTexture.toJSON(A)),this.boundingSphere!==null&&(s.boundingSphere={center:s.boundingSphere.center.toArray(),radius:s.boundingSphere.radius}),this.boundingBox!==null&&(s.boundingBox={min:s.boundingBox.min.toArray(),max:s.boundingBox.max.toArray()}));function i(a,g){return a[g.uuid]===void 0&&(a[g.uuid]=g.toJSON(A)),g.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=i(A.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const g=a.shapes;if(Array.isArray(g))for(let o=0,I=g.length;o<I;o++){const B=g[o];i(A.shapes,B)}else i(A.shapes,g)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(A.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let g=0,o=this.material.length;g<o;g++)a.push(i(A.materials,this.material[g]));s.material=a}else s.material=i(A.materials,this.material);if(this.children.length>0){s.children=[];for(let a=0;a<this.children.length;a++)s.children.push(this.children[a].toJSON(A).object)}if(this.animations.length>0){s.animations=[];for(let a=0;a<this.animations.length;a++){const g=this.animations[a];s.animations.push(i(A.animations,g))}}if(t){const a=r(A.geometries),g=r(A.materials),o=r(A.textures),I=r(A.images),B=r(A.shapes),Q=r(A.skeletons),h=r(A.animations),C=r(A.nodes);a.length>0&&(e.geometries=a),g.length>0&&(e.materials=g),o.length>0&&(e.textures=o),I.length>0&&(e.images=I),B.length>0&&(e.shapes=B),Q.length>0&&(e.skeletons=Q),h.length>0&&(e.animations=h),C.length>0&&(e.nodes=C)}return e.object=s,e;function r(a){const g=[];for(const o in a){const I=a[o];delete I.metadata,g.push(I)}return g}}clone(A){return new this.constructor().copy(this,A)}copy(A,t=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.animations=A.animations.slice(),this.userData=JSON.parse(JSON.stringify(A.userData)),t===!0)for(let e=0;e<A.children.length;e++){const s=A.children[e];this.add(s.clone())}return this}}mA.DEFAULT_UP=new f(0,1,0),mA.DEFAULT_MATRIX_AUTO_UPDATE=!0,mA.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _A=new f,nt=new f,_s=new f,rt=new f,Pt=new f,Wt=new f,fn=new f,Os=new f,Zs=new f,Ps=new f,Ws=new fA,Xs=new fA,Vs=new fA;class OA{constructor(A=new f,t=new f,e=new f){this.a=A,this.b=t,this.c=e}static getNormal(A,t,e,s){s.subVectors(e,t),_A.subVectors(A,t),s.cross(_A);const i=s.lengthSq();return i>0?s.multiplyScalar(1/Math.sqrt(i)):s.set(0,0,0)}static getBarycoord(A,t,e,s,i){_A.subVectors(s,t),nt.subVectors(e,t),_s.subVectors(A,t);const r=_A.dot(_A),a=_A.dot(nt),g=_A.dot(_s),o=nt.dot(nt),I=nt.dot(_s),B=r*o-a*a;if(B===0)return i.set(0,0,0),null;const Q=1/B,h=(o*g-a*I)*Q,C=(r*I-a*g)*Q;return i.set(1-h-C,C,h)}static containsPoint(A,t,e,s){return this.getBarycoord(A,t,e,s,rt)===null?!1:rt.x>=0&&rt.y>=0&&rt.x+rt.y<=1}static getInterpolation(A,t,e,s,i,r,a,g){return this.getBarycoord(A,t,e,s,rt)===null?(g.x=0,g.y=0,"z"in g&&(g.z=0),"w"in g&&(g.w=0),null):(g.setScalar(0),g.addScaledVector(i,rt.x),g.addScaledVector(r,rt.y),g.addScaledVector(a,rt.z),g)}static getInterpolatedAttribute(A,t,e,s,i,r){return Ws.setScalar(0),Xs.setScalar(0),Vs.setScalar(0),Ws.fromBufferAttribute(A,t),Xs.fromBufferAttribute(A,e),Vs.fromBufferAttribute(A,s),r.setScalar(0),r.addScaledVector(Ws,i.x),r.addScaledVector(Xs,i.y),r.addScaledVector(Vs,i.z),r}static isFrontFacing(A,t,e,s){return _A.subVectors(e,t),nt.subVectors(A,t),_A.cross(nt).dot(s)<0}set(A,t,e){return this.a.copy(A),this.b.copy(t),this.c.copy(e),this}setFromPointsAndIndices(A,t,e,s){return this.a.copy(A[t]),this.b.copy(A[e]),this.c.copy(A[s]),this}setFromAttributeAndIndices(A,t,e,s){return this.a.fromBufferAttribute(A,t),this.b.fromBufferAttribute(A,e),this.c.fromBufferAttribute(A,s),this}clone(){return new this.constructor().copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return _A.subVectors(this.c,this.b),nt.subVectors(this.a,this.b),_A.cross(nt).length()*.5}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return OA.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,t){return OA.getBarycoord(A,this.a,this.b,this.c,t)}getInterpolation(A,t,e,s,i){return OA.getInterpolation(A,this.a,this.b,this.c,t,e,s,i)}containsPoint(A){return OA.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return OA.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,t){const e=this.a,s=this.b,i=this.c;let r,a;Pt.subVectors(s,e),Wt.subVectors(i,e),Os.subVectors(A,e);const g=Pt.dot(Os),o=Wt.dot(Os);if(g<=0&&o<=0)return t.copy(e);Zs.subVectors(A,s);const I=Pt.dot(Zs),B=Wt.dot(Zs);if(I>=0&&B<=I)return t.copy(s);const Q=g*B-I*o;if(Q<=0&&g>=0&&I<=0)return r=g/(g-I),t.copy(e).addScaledVector(Pt,r);Ps.subVectors(A,i);const h=Pt.dot(Ps),C=Wt.dot(Ps);if(C>=0&&h<=C)return t.copy(i);const E=h*o-g*C;if(E<=0&&o>=0&&C<=0)return a=o/(o-C),t.copy(e).addScaledVector(Wt,a);const l=I*C-h*B;if(l<=0&&B-I>=0&&h-C>=0)return fn.subVectors(i,s),a=(B-I)/(B-I+(h-C)),t.copy(s).addScaledVector(fn,a);const c=1/(l+E+Q);return r=E*c,a=Q*c,t.copy(e).addScaledVector(Pt,r).addScaledVector(Wt,a)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}const yn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},yt={h:0,s:0,l:0},Oe={h:0,s:0,l:0};function js(n,A,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(A-n)*6*t:t<1/2?A:t<2/3?n+(A-n)*6*(2/3-t):n}class kt{constructor(A,t,e){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,t,e)}set(A,t,e){if(t===void 0&&e===void 0){const s=A;s&&s.isColor?this.copy(s):typeof s=="number"?this.setHex(s):typeof s=="string"&&this.setStyle(s)}else this.setRGB(A,t,e);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,t=vA){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,zA.toWorkingColorSpace(this,t),this}setRGB(A,t,e,s=zA.workingColorSpace){return this.r=A,this.g=t,this.b=e,zA.toWorkingColorSpace(this,s),this}setHSL(A,t,e,s=zA.workingColorSpace){if(A=Pr(A,1),t=T(t,0,1),e=T(e,0,1),t===0)this.r=this.g=this.b=e;else{const i=e<=.5?e*(1+t):e+t-e*t,r=2*e-i;this.r=js(r,i,A+1/3),this.g=js(r,i,A),this.b=js(r,i,A-1/3)}return zA.toWorkingColorSpace(this,s),this}setStyle(A,t=vA){function e(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let s;if(s=/^(\\w+)\\(([^\\)]*)\\)/.exec(A)){let i;const r=s[1],a=s[2];switch(r){case"rgb":case"rgba":if(i=/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(a))return e(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,t);if(i=/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(a))return e(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,t);break;case"hsl":case"hsla":if(i=/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(a))return e(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(s=/^\\#([A-Fa-f\\d]+)$/.exec(A)){const i=s[1],r=i.length;if(r===3)return this.setRGB(parseInt(i.charAt(0),16)/15,parseInt(i.charAt(1),16)/15,parseInt(i.charAt(2),16)/15,t);if(r===6)return this.setHex(parseInt(i,16),t);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,t);return this}setColorName(A,t=vA){const e=yn[A.toLowerCase()];return e!==void 0?this.setHex(e,t):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=tt(A.r),this.g=tt(A.g),this.b=tt(A.b),this}copyLinearToSRGB(A){return this.r=Ht(A.r),this.g=Ht(A.g),this.b=Ht(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=vA){return zA.fromWorkingColorSpace(lA.copy(this),A),Math.round(T(lA.r*255,0,255))*65536+Math.round(T(lA.g*255,0,255))*256+Math.round(T(lA.b*255,0,255))}getHexString(A=vA){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,t=zA.workingColorSpace){zA.fromWorkingColorSpace(lA.copy(this),t);const e=lA.r,s=lA.g,i=lA.b,r=Math.max(e,s,i),a=Math.min(e,s,i);let g,o;const I=(a+r)/2;if(a===r)g=0,o=0;else{const B=r-a;switch(o=I<=.5?B/(r+a):B/(2-r-a),r){case e:g=(s-i)/B+(s<i?6:0);break;case s:g=(i-e)/B+2;break;case i:g=(e-s)/B+4;break}g/=6}return A.h=g,A.s=o,A.l=I,A}getRGB(A,t=zA.workingColorSpace){return zA.fromWorkingColorSpace(lA.copy(this),t),A.r=lA.r,A.g=lA.g,A.b=lA.b,A}getStyle(A=vA){zA.fromWorkingColorSpace(lA.copy(this),A);const t=lA.r,e=lA.g,s=lA.b;return A!==vA?`color(${A} ${t.toFixed(3)} ${e.toFixed(3)} ${s.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(e*255)},${Math.round(s*255)})`}offsetHSL(A,t,e){return this.getHSL(yt),this.setHSL(yt.h+A,yt.s+t,yt.l+e)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,t){return this.r=A.r+t.r,this.g=A.g+t.g,this.b=A.b+t.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,t){return this.r+=(A.r-this.r)*t,this.g+=(A.g-this.g)*t,this.b+=(A.b-this.b)*t,this}lerpColors(A,t,e){return this.r=A.r+(t.r-A.r)*e,this.g=A.g+(t.g-A.g)*e,this.b=A.b+(t.b-A.b)*e,this}lerpHSL(A,t){this.getHSL(yt),A.getHSL(Oe);const e=Ls(yt.h,Oe.h,t),s=Ls(yt.s,Oe.s,t),i=Ls(yt.l,Oe.l,t);return this.setHSL(e,s,i),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const t=this.r,e=this.g,s=this.b,i=A.elements;return this.r=i[0]*t+i[3]*e+i[6]*s,this.g=i[1]*t+i[4]*e+i[7]*s,this.b=i[2]*t+i[5]*e+i[8]*s,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,t=0){return this.r=A[t],this.g=A[t+1],this.b=A[t+2],this}toArray(A=[],t=0){return A[t]=this.r,A[t+1]=this.g,A[t+2]=this.b,A}fromBufferAttribute(A,t){return this.r=A.getX(t),this.g=A.getY(t),this.b=A.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const lA=new kt;kt.NAMES=yn;let Ba=0;class pn extends ce{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Ba++}),this.uuid=le(),this.name="",this.type="Material",this.blending=Ki,this.side=Gs,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Oi,this.blendDst=Zi,this.blendEquation=_i,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new kt(0,0,0),this.blendAlpha=0,this.depthFunc=Pi,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=en,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Jt,this.stencilZFail=Jt,this.stencilZPass=Jt,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(A!==void 0)for(const t in A){const e=A[t];if(e===void 0){console.warn(`THREE.Material: parameter \'${t}\' has value of undefined.`);continue}const s=this[t];if(s===void 0){console.warn(`THREE.Material: \'${t}\' is not a property of THREE.${this.type}.`);continue}s&&s.isColor?s.set(e):s&&s.isVector3&&e&&e.isVector3?s.copy(e):this[t]=e}}toJSON(A){const t=A===void 0||typeof A=="string";t&&(A={textures:{},images:{}});const e={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),this.roughness!==void 0&&(e.roughness=this.roughness),this.metalness!==void 0&&(e.metalness=this.metalness),this.sheen!==void 0&&(e.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(e.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(e.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(e.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(e.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(e.shininess=this.shininess),this.clearcoat!==void 0&&(e.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(e.dispersion=this.dispersion),this.iridescence!==void 0&&(e.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(e.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(e.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(e.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(e.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.anisotropy!==void 0&&(e.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(e.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(e.anisotropyMap=this.anisotropyMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(A).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(A).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(A).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(A).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(A).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(e.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(e.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(A).uuid,this.combine!==void 0&&(e.combine=this.combine)),this.envMapRotation!==void 0&&(e.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(e.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(e.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(e.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(A).uuid),this.transmission!==void 0&&(e.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(e.transmissionMap=this.transmissionMap.toJSON(A).uuid),this.thickness!==void 0&&(e.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(e.thicknessMap=this.thicknessMap.toJSON(A).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(e.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(e.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(e.size=this.size),this.shadowSide!==null&&(e.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==Ki&&(e.blending=this.blending),this.side!==Gs&&(e.side=this.side),this.vertexColors===!0&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),this.transparent===!0&&(e.transparent=!0),this.blendSrc!==Oi&&(e.blendSrc=this.blendSrc),this.blendDst!==Zi&&(e.blendDst=this.blendDst),this.blendEquation!==_i&&(e.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(e.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(e.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(e.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(e.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(e.blendAlpha=this.blendAlpha),this.depthFunc!==Pi&&(e.depthFunc=this.depthFunc),this.depthTest===!1&&(e.depthTest=this.depthTest),this.depthWrite===!1&&(e.depthWrite=this.depthWrite),this.colorWrite===!1&&(e.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(e.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==en&&(e.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(e.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(e.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Jt&&(e.stencilFail=this.stencilFail),this.stencilZFail!==Jt&&(e.stencilZFail=this.stencilZFail),this.stencilZPass!==Jt&&(e.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(e.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(e.rotation=this.rotation),this.polygonOffset===!0&&(e.polygonOffset=!0),this.polygonOffsetFactor!==0&&(e.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(e.linewidth=this.linewidth),this.dashSize!==void 0&&(e.dashSize=this.dashSize),this.gapSize!==void 0&&(e.gapSize=this.gapSize),this.scale!==void 0&&(e.scale=this.scale),this.dithering===!0&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),this.alphaHash===!0&&(e.alphaHash=!0),this.alphaToCoverage===!0&&(e.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(e.premultipliedAlpha=!0),this.forceSinglePass===!0&&(e.forceSinglePass=!0),this.wireframe===!0&&(e.wireframe=!0),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(e.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(e.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(e.flatShading=!0),this.visible===!1&&(e.visible=!1),this.toneMapped===!1&&(e.toneMapped=!1),this.fog===!1&&(e.fog=!1),Object.keys(this.userData).length>0&&(e.userData=this.userData);function s(i){const r=[];for(const a in i){const g=i[a];delete g.metadata,r.push(g)}return r}if(t){const i=s(A.textures),r=s(A.images);i.length>0&&(e.textures=i),r.length>0&&(e.images=r)}return e}clone(){return new this.constructor().copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.blendColor.copy(A.blendColor),this.blendAlpha=A.blendAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const t=A.clippingPlanes;let e=null;if(t!==null){const s=t.length;e=new Array(s);for(let i=0;i!==s;++i)e[i]=t[i].clone()}return this.clippingPlanes=e,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaHash=A.alphaHash,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.forceSinglePass=A.forceSinglePass,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){A===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class Qa extends pn{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new kt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Nt,this.combine=qr,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapRotation.copy(A.envMapRotation),this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const iA=new f,Ze=new DA;class Xt{constructor(A,t,e=!1){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=t,this.count=A!==void 0?A.length/t:0,this.normalized=e,this.usage=sn,this.updateRanges=[],this.gpuType=_r,this.version=0}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}setUsage(A){return this.usage=A,this}addUpdateRange(A,t){this.updateRanges.push({start:A,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this.gpuType=A.gpuType,this}copyAt(A,t,e){A*=this.itemSize,e*=t.itemSize;for(let s=0,i=this.itemSize;s<i;s++)this.array[A+s]=t.array[e+s];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(this.itemSize===2)for(let t=0,e=this.count;t<e;t++)Ze.fromBufferAttribute(this,t),Ze.applyMatrix3(A),this.setXY(t,Ze.x,Ze.y);else if(this.itemSize===3)for(let t=0,e=this.count;t<e;t++)iA.fromBufferAttribute(this,t),iA.applyMatrix3(A),this.setXYZ(t,iA.x,iA.y,iA.z);return this}applyMatrix4(A){for(let t=0,e=this.count;t<e;t++)iA.fromBufferAttribute(this,t),iA.applyMatrix4(A),this.setXYZ(t,iA.x,iA.y,iA.z);return this}applyNormalMatrix(A){for(let t=0,e=this.count;t<e;t++)iA.fromBufferAttribute(this,t),iA.applyNormalMatrix(A),this.setXYZ(t,iA.x,iA.y,iA.z);return this}transformDirection(A){for(let t=0,e=this.count;t<e;t++)iA.fromBufferAttribute(this,t),iA.transformDirection(A),this.setXYZ(t,iA.x,iA.y,iA.z);return this}set(A,t=0){return this.array.set(A,t),this}getComponent(A,t){let e=this.array[A*this.itemSize+t];return this.normalized&&(e=ue(e,this.array)),e}setComponent(A,t,e){return this.normalized&&(e=wA(e,this.array)),this.array[A*this.itemSize+t]=e,this}getX(A){let t=this.array[A*this.itemSize];return this.normalized&&(t=ue(t,this.array)),t}setX(A,t){return this.normalized&&(t=wA(t,this.array)),this.array[A*this.itemSize]=t,this}getY(A){let t=this.array[A*this.itemSize+1];return this.normalized&&(t=ue(t,this.array)),t}setY(A,t){return this.normalized&&(t=wA(t,this.array)),this.array[A*this.itemSize+1]=t,this}getZ(A){let t=this.array[A*this.itemSize+2];return this.normalized&&(t=ue(t,this.array)),t}setZ(A,t){return this.normalized&&(t=wA(t,this.array)),this.array[A*this.itemSize+2]=t,this}getW(A){let t=this.array[A*this.itemSize+3];return this.normalized&&(t=ue(t,this.array)),t}setW(A,t){return this.normalized&&(t=wA(t,this.array)),this.array[A*this.itemSize+3]=t,this}setXY(A,t,e){return A*=this.itemSize,this.normalized&&(t=wA(t,this.array),e=wA(e,this.array)),this.array[A+0]=t,this.array[A+1]=e,this}setXYZ(A,t,e,s){return A*=this.itemSize,this.normalized&&(t=wA(t,this.array),e=wA(e,this.array),s=wA(s,this.array)),this.array[A+0]=t,this.array[A+1]=e,this.array[A+2]=s,this}setXYZW(A,t,e,s,i){return A*=this.itemSize,this.normalized&&(t=wA(t,this.array),e=wA(e,this.array),s=wA(s,this.array),i=wA(i,this.array)),this.array[A+0]=t,this.array[A+1]=e,this.array[A+2]=s,this.array[A+3]=i,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(A.name=this.name),this.usage!==sn&&(A.usage=this.usage),A}}class ha extends Xt{constructor(A,t,e){super(new Uint16Array(A),t,e)}}class Ca extends Xt{constructor(A,t,e){super(new Uint32Array(A),t,e)}}class Pe extends Xt{constructor(A,t,e){super(new Float32Array(A),t,e)}}let Ea=0;const bA=new cA,$s=new mA,Vt=new f,kA=new vt,pe=new vt,oA=new f;class We extends ce{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ea++}),this.uuid=le(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new(Wr(A)?Ca:ha)(A,1):this.index=A,this}setIndirect(A){return this.indirect=A,this}getIndirect(){return this.indirect}getAttribute(A){return this.attributes[A]}setAttribute(A,t){return this.attributes[A]=t,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return this.attributes[A]!==void 0}addGroup(A,t,e=0){this.groups.push({start:A,count:t,materialIndex:e})}clearGroups(){this.groups=[]}setDrawRange(A,t){this.drawRange.start=A,this.drawRange.count=t}applyMatrix4(A){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(A),t.needsUpdate=!0);const e=this.attributes.normal;if(e!==void 0){const i=new VA().getNormalMatrix(A);e.applyNormalMatrix(i),e.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(A),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(A){return bA.makeRotationFromQuaternion(A),this.applyMatrix4(bA),this}rotateX(A){return bA.makeRotationX(A),this.applyMatrix4(bA),this}rotateY(A){return bA.makeRotationY(A),this.applyMatrix4(bA),this}rotateZ(A){return bA.makeRotationZ(A),this.applyMatrix4(bA),this}translate(A,t,e){return bA.makeTranslation(A,t,e),this.applyMatrix4(bA),this}scale(A,t,e){return bA.makeScale(A,t,e),this.applyMatrix4(bA),this}lookAt(A){return $s.lookAt(A),$s.updateMatrix(),this.applyMatrix4($s.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Vt).negate(),this.translate(Vt.x,Vt.y,Vt.z),this}setFromPoints(A){const t=this.getAttribute("position");if(t===void 0){const e=[];for(let s=0,i=A.length;s<i;s++){const r=A[s];e.push(r.x,r.y,r.z||0)}this.setAttribute("position",new Pe(e,3))}else{const e=Math.min(A.length,t.count);for(let s=0;s<e;s++){const i=A[s];t.setXYZ(s,i.x,i.y,i.z||0)}A.length>t.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),t.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new vt);const A=this.attributes.position,t=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new f(-1/0,-1/0,-1/0),new f(1/0,1/0,1/0));return}if(A!==void 0){if(this.boundingBox.setFromBufferAttribute(A),t)for(let e=0,s=t.length;e<s;e++){const i=t[e];kA.setFromBufferAttribute(i),this.morphTargetsRelative?(oA.addVectors(this.boundingBox.min,kA.min),this.boundingBox.expandByPoint(oA),oA.addVectors(this.boundingBox.max,kA.max),this.boundingBox.expandByPoint(oA)):(this.boundingBox.expandByPoint(kA.min),this.boundingBox.expandByPoint(kA.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Qn);const A=this.attributes.position,t=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new f,1/0);return}if(A){const e=this.boundingSphere.center;if(kA.setFromBufferAttribute(A),t)for(let i=0,r=t.length;i<r;i++){const a=t[i];pe.setFromBufferAttribute(a),this.morphTargetsRelative?(oA.addVectors(kA.min,pe.min),kA.expandByPoint(oA),oA.addVectors(kA.max,pe.max),kA.expandByPoint(oA)):(kA.expandByPoint(pe.min),kA.expandByPoint(pe.max))}kA.getCenter(e);let s=0;for(let i=0,r=A.count;i<r;i++)oA.fromBufferAttribute(A,i),s=Math.max(s,e.distanceToSquared(oA));if(t)for(let i=0,r=t.length;i<r;i++){const a=t[i],g=this.morphTargetsRelative;for(let o=0,I=a.count;o<I;o++)oA.fromBufferAttribute(a,o),g&&(Vt.fromBufferAttribute(A,o),oA.add(Vt)),s=Math.max(s,e.distanceToSquared(oA))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\',this)}}computeTangents(){const A=this.index,t=this.attributes;if(A===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const e=t.position,s=t.normal,i=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Xt(new Float32Array(4*e.count),4));const r=this.getAttribute("tangent"),a=[],g=[];for(let p=0;p<e.count;p++)a[p]=new f,g[p]=new f;const o=new f,I=new f,B=new f,Q=new DA,h=new DA,C=new DA,E=new f,l=new f;function c(p,D,F){o.fromBufferAttribute(e,p),I.fromBufferAttribute(e,D),B.fromBufferAttribute(e,F),Q.fromBufferAttribute(i,p),h.fromBufferAttribute(i,D),C.fromBufferAttribute(i,F),I.sub(o),B.sub(o),h.sub(Q),C.sub(Q);const m=1/(h.x*C.y-C.x*h.y);isFinite(m)&&(E.copy(I).multiplyScalar(C.y).addScaledVector(B,-h.y).multiplyScalar(m),l.copy(B).multiplyScalar(h.x).addScaledVector(I,-C.x).multiplyScalar(m),a[p].add(E),a[D].add(E),a[F].add(E),g[p].add(l),g[D].add(l),g[F].add(l))}let u=this.groups;u.length===0&&(u=[{start:0,count:A.count}]);for(let p=0,D=u.length;p<D;++p){const F=u[p],m=F.start,S=F.count;for(let N=m,k=m+S;N<k;N+=3)c(A.getX(N+0),A.getX(N+1),A.getX(N+2))}const d=new f,y=new f,w=new f,x=new f;function M(p){w.fromBufferAttribute(s,p),x.copy(w);const D=a[p];d.copy(D),d.sub(w.multiplyScalar(w.dot(D))).normalize(),y.crossVectors(x,D);const m=y.dot(g[p])<0?-1:1;r.setXYZW(p,d.x,d.y,d.z,m)}for(let p=0,D=u.length;p<D;++p){const F=u[p],m=F.start,S=F.count;for(let N=m,k=m+S;N<k;N+=3)M(A.getX(N+0)),M(A.getX(N+1)),M(A.getX(N+2))}}computeVertexNormals(){const A=this.index,t=this.getAttribute("position");if(t!==void 0){let e=this.getAttribute("normal");if(e===void 0)e=new Xt(new Float32Array(t.count*3),3),this.setAttribute("normal",e);else for(let Q=0,h=e.count;Q<h;Q++)e.setXYZ(Q,0,0,0);const s=new f,i=new f,r=new f,a=new f,g=new f,o=new f,I=new f,B=new f;if(A)for(let Q=0,h=A.count;Q<h;Q+=3){const C=A.getX(Q+0),E=A.getX(Q+1),l=A.getX(Q+2);s.fromBufferAttribute(t,C),i.fromBufferAttribute(t,E),r.fromBufferAttribute(t,l),I.subVectors(r,i),B.subVectors(s,i),I.cross(B),a.fromBufferAttribute(e,C),g.fromBufferAttribute(e,E),o.fromBufferAttribute(e,l),a.add(I),g.add(I),o.add(I),e.setXYZ(C,a.x,a.y,a.z),e.setXYZ(E,g.x,g.y,g.z),e.setXYZ(l,o.x,o.y,o.z)}else for(let Q=0,h=t.count;Q<h;Q+=3)s.fromBufferAttribute(t,Q+0),i.fromBufferAttribute(t,Q+1),r.fromBufferAttribute(t,Q+2),I.subVectors(r,i),B.subVectors(s,i),I.cross(B),e.setXYZ(Q+0,I.x,I.y,I.z),e.setXYZ(Q+1,I.x,I.y,I.z),e.setXYZ(Q+2,I.x,I.y,I.z);this.normalizeNormals(),e.needsUpdate=!0}}normalizeNormals(){const A=this.attributes.normal;for(let t=0,e=A.count;t<e;t++)oA.fromBufferAttribute(A,t),oA.normalize(),A.setXYZ(t,oA.x,oA.y,oA.z)}toNonIndexed(){function A(a,g){const o=a.array,I=a.itemSize,B=a.normalized,Q=new o.constructor(g.length*I);let h=0,C=0;for(let E=0,l=g.length;E<l;E++){a.isInterleavedBufferAttribute?h=g[E]*a.data.stride+a.offset:h=g[E]*I;for(let c=0;c<I;c++)Q[C++]=o[h++]}return new Xt(Q,I,B)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new We,e=this.index.array,s=this.attributes;for(const a in s){const g=s[a],o=A(g,e);t.setAttribute(a,o)}const i=this.morphAttributes;for(const a in i){const g=[],o=i[a];for(let I=0,B=o.length;I<B;I++){const Q=o[I],h=A(Q,e);g.push(h)}t.morphAttributes[a]=g}t.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let a=0,g=r.length;a<g;a++){const o=r[a];t.addGroup(o.start,o.count,o.materialIndex)}return t}toJSON(){const A={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,this.name!==""&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),this.parameters!==void 0){const g=this.parameters;for(const o in g)g[o]!==void 0&&(A[o]=g[o]);return A}A.data={attributes:{}};const t=this.index;t!==null&&(A.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const e=this.attributes;for(const g in e){const o=e[g];A.data.attributes[g]=o.toJSON(A.data)}const s={};let i=!1;for(const g in this.morphAttributes){const o=this.morphAttributes[g],I=[];for(let B=0,Q=o.length;B<Q;B++){const h=o[B];I.push(h.toJSON(A.data))}I.length>0&&(s[g]=I,i=!0)}i&&(A.data.morphAttributes=s,A.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(A.data.groups=JSON.parse(JSON.stringify(r)));const a=this.boundingSphere;return a!==null&&(A.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),A}clone(){return new this.constructor().copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=A.name;const e=A.index;e!==null&&this.setIndex(e.clone(t));const s=A.attributes;for(const o in s){const I=s[o];this.setAttribute(o,I.clone(t))}const i=A.morphAttributes;for(const o in i){const I=[],B=i[o];for(let Q=0,h=B.length;Q<h;Q++)I.push(B[Q].clone(t));this.morphAttributes[o]=I}this.morphTargetsRelative=A.morphTargetsRelative;const r=A.groups;for(let o=0,I=r.length;o<I;o++){const B=r[o];this.addGroup(B.start,B.count,B.materialIndex)}const a=A.boundingBox;a!==null&&(this.boundingBox=a.clone());const g=A.boundingSphere;return g!==null&&(this.boundingSphere=g.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const wn=new cA,Rt=new sa,Xe=new Qn,Dn=new f,Ve=new f,je=new f,$e=new f,Ai=new f,As=new f,mn=new f,ts=new f;class xn extends mA{constructor(A=new We,t=new Qa){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=t,this.updateMorphTargets()}copy(A,t){return super.copy(A,t),A.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),A.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const s=t[e[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,r=s.length;i<r;i++){const a=s[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}getVertexPosition(A,t){const e=this.geometry,s=e.attributes.position,i=e.morphAttributes.position,r=e.morphTargetsRelative;t.fromBufferAttribute(s,A);const a=this.morphTargetInfluences;if(i&&a){As.set(0,0,0);for(let g=0,o=i.length;g<o;g++){const I=a[g],B=i[g];I!==0&&(Ai.fromBufferAttribute(B,A),r?As.addScaledVector(Ai,I):As.addScaledVector(Ai.sub(t),I))}t.add(As)}return t}raycast(A,t){const e=this.geometry,s=this.material,i=this.matrixWorld;s!==void 0&&(e.boundingSphere===null&&e.computeBoundingSphere(),Xe.copy(e.boundingSphere),Xe.applyMatrix4(i),Rt.copy(A.ray).recast(A.near),!(Xe.containsPoint(Rt.origin)===!1&&(Rt.intersectSphere(Xe,Dn)===null||Rt.origin.distanceToSquared(Dn)>(A.far-A.near)**2))&&(wn.copy(i).invert(),Rt.copy(A.ray).applyMatrix4(wn),!(e.boundingBox!==null&&Rt.intersectsBox(e.boundingBox)===!1)&&this._computeIntersections(A,t,Rt)))}_computeIntersections(A,t,e){let s;const i=this.geometry,r=this.material,a=i.index,g=i.attributes.position,o=i.attributes.uv,I=i.attributes.uv1,B=i.attributes.normal,Q=i.groups,h=i.drawRange;if(a!==null)if(Array.isArray(r))for(let C=0,E=Q.length;C<E;C++){const l=Q[C],c=r[l.materialIndex],u=Math.max(l.start,h.start),d=Math.min(a.count,Math.min(l.start+l.count,h.start+h.count));for(let y=u,w=d;y<w;y+=3){const x=a.getX(y),M=a.getX(y+1),p=a.getX(y+2);s=es(this,c,A,e,o,I,B,x,M,p),s&&(s.faceIndex=Math.floor(y/3),s.face.materialIndex=l.materialIndex,t.push(s))}}else{const C=Math.max(0,h.start),E=Math.min(a.count,h.start+h.count);for(let l=C,c=E;l<c;l+=3){const u=a.getX(l),d=a.getX(l+1),y=a.getX(l+2);s=es(this,r,A,e,o,I,B,u,d,y),s&&(s.faceIndex=Math.floor(l/3),t.push(s))}}else if(g!==void 0)if(Array.isArray(r))for(let C=0,E=Q.length;C<E;C++){const l=Q[C],c=r[l.materialIndex],u=Math.max(l.start,h.start),d=Math.min(g.count,Math.min(l.start+l.count,h.start+h.count));for(let y=u,w=d;y<w;y+=3){const x=y,M=y+1,p=y+2;s=es(this,c,A,e,o,I,B,x,M,p),s&&(s.faceIndex=Math.floor(y/3),s.face.materialIndex=l.materialIndex,t.push(s))}}else{const C=Math.max(0,h.start),E=Math.min(g.count,h.start+h.count);for(let l=C,c=E;l<c;l+=3){const u=l,d=l+1,y=l+2;s=es(this,r,A,e,o,I,B,u,d,y),s&&(s.faceIndex=Math.floor(l/3),t.push(s))}}}}function ca(n,A,t,e,s,i,r,a){let g;if(A.side===zr?g=e.intersectTriangle(r,i,s,!0,a):g=e.intersectTriangle(s,i,r,A.side===Gs,a),g===null)return null;ts.copy(a),ts.applyMatrix4(n.matrixWorld);const o=t.ray.origin.distanceTo(ts);return o<t.near||o>t.far?null:{distance:o,point:ts.clone(),object:n}}function es(n,A,t,e,s,i,r,a,g,o){n.getVertexPosition(a,Ve),n.getVertexPosition(g,je),n.getVertexPosition(o,$e);const I=ca(n,A,t,e,Ve,je,$e,mn);if(I){const B=new f;OA.getBarycoord(mn,Ve,je,$e,B),s&&(I.uv=OA.getInterpolatedAttribute(s,a,g,o,B,new DA)),i&&(I.uv1=OA.getInterpolatedAttribute(i,a,g,o,B,new DA)),r&&(I.normal=OA.getInterpolatedAttribute(r,a,g,o,B,new f),I.normal.dot(e.direction)>0&&I.normal.multiplyScalar(-1));const Q={a,b:g,c:o,normal:new f,materialIndex:0};OA.getNormal(Ve,je,$e,Q.normal),I.face=Q,I.barycoord=B}return I}function la(n){const A={};for(const t in n){A[t]={};for(const e in n[t]){const s=n[t][e];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),A[t][e]=null):A[t][e]=s.clone():Array.isArray(s)?A[t][e]=s.slice():A[t][e]=s}}return A}function ua(n){const A=[];for(let t=0;t<n.length;t++)A.push(n[t].clone());return A}var da=`void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}`,fa=`void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}`;class ya extends pn{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=da,this.fragmentShader=fa,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,A!==void 0&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=la(A.uniforms),this.uniformsGroups=ua(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const t=super.toJSON(A);t.glslVersion=this.glslVersion,t.uniforms={};for(const s in this.uniforms){const r=this.uniforms[s].value;r&&r.isTexture?t.uniforms[s]={type:"t",value:r.toJSON(A).uuid}:r&&r.isColor?t.uniforms[s]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[s]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[s]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[s]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[s]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[s]={type:"m4",value:r.toArray()}:t.uniforms[s]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const e={};for(const s in this.extensions)this.extensions[s]===!0&&(e[s]=!0);return Object.keys(e).length>0&&(t.extensions=e),t}}class Mn extends mA{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new cA,this.projectionMatrix=new cA,this.projectionMatrixInverse=new cA,this.coordinateSystem=Ee}copy(A,t){return super.copy(A,t),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this.coordinateSystem=A.coordinateSystem,this}getWorldDirection(A){return super.getWorldDirection(A).negate()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,t){super.updateWorldMatrix(A,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Sn extends mA{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Nt,this.environmentIntensity=1,this.environmentRotation=new Nt,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(A,t){return super.copy(A,t),A.background!==null&&(this.background=A.background.clone()),A.environment!==null&&(this.environment=A.environment.clone()),A.fog!==null&&(this.fog=A.fog.clone()),this.backgroundBlurriness=A.backgroundBlurriness,this.backgroundIntensity=A.backgroundIntensity,this.backgroundRotation.copy(A.backgroundRotation),this.environmentIntensity=A.environmentIntensity,this.environmentRotation.copy(A.environmentRotation),A.overrideMaterial!==null&&(this.overrideMaterial=A.overrideMaterial.clone()),this.matrixAutoUpdate=A.matrixAutoUpdate,this}toJSON(A){const t=super.toJSON(A);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class pa extends jA{constructor(A=null,t=1,e=1,s,i,r,a,g,o=Et,I=Et,B,Q){super(null,r,a,g,o,I,s,i,B,Q),this.isDataTexture=!0,this.image={data:A,width:t,height:e},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ss extends We{constructor(A=1,t=1,e=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:t,widthSegments:e,heightSegments:s};const i=A/2,r=t/2,a=Math.floor(e),g=Math.floor(s),o=a+1,I=g+1,B=A/a,Q=t/g,h=[],C=[],E=[],l=[];for(let c=0;c<I;c++){const u=c*Q-r;for(let d=0;d<o;d++){const y=d*B-i;C.push(y,-u,0),E.push(0,0,1),l.push(d/a),l.push(1-c/g)}}for(let c=0;c<g;c++)for(let u=0;u<a;u++){const d=u+o*c,y=u+o*(c+1),w=u+1+o*(c+1),x=u+1+o*c;h.push(d,y,x),h.push(y,w,x)}this.setIndex(h),this.setAttribute("position",new Pe(C,3)),this.setAttribute("normal",new Pe(E,3)),this.setAttribute("uv",new Pe(l,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new ss(A.width,A.height,A.widthSegments,A.heightSegments)}}class ti extends ya{constructor(A){super(A),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}const Fn={enabled:!1,files:{},add:function(n,A){this.enabled!==!1&&(this.files[n]=A)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class wa{constructor(A,t,e){const s=this;let i=!1,r=0,a=0,g;const o=[];this.onStart=void 0,this.onLoad=A,this.onProgress=t,this.onError=e,this.itemStart=function(I){a++,i===!1&&s.onStart!==void 0&&s.onStart(I,r,a),i=!0},this.itemEnd=function(I){r++,s.onProgress!==void 0&&s.onProgress(I,r,a),r===a&&(i=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(I){s.onError!==void 0&&s.onError(I)},this.resolveURL=function(I){return g?g(I):I},this.setURLModifier=function(I){return g=I,this},this.addHandler=function(I,B){return o.push(I,B),this},this.removeHandler=function(I){const B=o.indexOf(I);return B!==-1&&o.splice(B,2),this},this.getHandler=function(I){for(let B=0,Q=o.length;B<Q;B+=2){const h=o[B],C=o[B+1];if(h.global&&(h.lastIndex=0),h.test(I))return C}return null}}}const Da=new wa;class ei{constructor(A){this.manager=A!==void 0?A:Da,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(A,t){const e=this;return new Promise(function(s,i){e.load(A,s,t,i)})}parse(){}setCrossOrigin(A){return this.crossOrigin=A,this}setWithCredentials(A){return this.withCredentials=A,this}setPath(A){return this.path=A,this}setResourcePath(A){return this.resourcePath=A,this}setRequestHeader(A){return this.requestHeader=A,this}}ei.DEFAULT_MATERIAL_NAME="__DEFAULT";const at={};class ma extends Error{constructor(A,t){super(A),this.response=t}}class xa extends ei{constructor(A){super(A)}load(A,t,e,s){A===void 0&&(A=""),this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const i=Fn.get(A);if(i!==void 0)return this.manager.itemStart(A),setTimeout(()=>{t&&t(i),this.manager.itemEnd(A)},0),i;if(at[A]!==void 0){at[A].push({onLoad:t,onProgress:e,onError:s});return}at[A]=[],at[A].push({onLoad:t,onProgress:e,onError:s});const r=new Request(A,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,g=this.responseType;fetch(r).then(o=>{if(o.status===200||o.status===0){if(o.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||o.body===void 0||o.body.getReader===void 0)return o;const I=at[A],B=o.body.getReader(),Q=o.headers.get("X-File-Size")||o.headers.get("Content-Length"),h=Q?parseInt(Q):0,C=h!==0;let E=0;const l=new ReadableStream({start(c){u();function u(){B.read().then(({done:d,value:y})=>{if(d)c.close();else{E+=y.byteLength;const w=new ProgressEvent("progress",{lengthComputable:C,loaded:E,total:h});for(let x=0,M=I.length;x<M;x++){const p=I[x];p.onProgress&&p.onProgress(w)}c.enqueue(y),u()}},d=>{c.error(d)})}}});return new Response(l)}else throw new ma(`fetch for "${o.url}" responded with ${o.status}: ${o.statusText}`,o)}).then(o=>{switch(g){case"arraybuffer":return o.arrayBuffer();case"blob":return o.blob();case"document":return o.text().then(I=>new DOMParser().parseFromString(I,a));case"json":return o.json();default:if(a===void 0)return o.text();{const B=/charset="?([^;"\\s]*)"?/i.exec(a),Q=B&&B[1]?B[1].toLowerCase():void 0,h=new TextDecoder(Q);return o.arrayBuffer().then(C=>h.decode(C))}}}).then(o=>{Fn.add(A,o);const I=at[A];delete at[A];for(let B=0,Q=I.length;B<Q;B++){const h=I[B];h.onLoad&&h.onLoad(o)}}).catch(o=>{const I=at[A];if(I===void 0)throw this.manager.itemError(A),o;delete at[A];for(let B=0,Q=I.length;B<Q;B++){const h=I[B];h.onError&&h.onError(o)}this.manager.itemError(A)}).finally(()=>{this.manager.itemEnd(A)}),this.manager.itemStart(A)}setResponseType(A){return this.responseType=A,this}setMimeType(A){return this.mimeType=A,this}}class si{constructor(A,t,e,s){si.prototype.isMatrix2=!0,this.elements=[1,0,0,1],A!==void 0&&this.set(A,t,e,s)}identity(){return this.set(1,0,0,1),this}fromArray(A,t=0){for(let e=0;e<4;e++)this.elements[e]=A[e+t];return this}set(A,t,e,s){const i=this.elements;return i[0]=A,i[2]=t,i[1]=e,i[3]=s,this}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:qi}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=qi);const $A=-12,gt=(9-$A)/254,jt=Math.exp(-30),Ma=11,Sa=11,Z=1<<Ma,pt=1<<Sa,Nn=1,Fa=!0;function $t(n){return n==="int"||n==="ivec2"||n==="ivec3"||n==="ivec4"}function Ae(n){return n==="uint"||n==="uvec2"||n==="uvec3"||n==="uvec4"}function Na(n){return n==="float"||n==="vec2"||n==="vec3"||n==="vec4"}function ka(n){return n==="mat2"||n==="mat2x2"||n==="mat2x3"||n==="mat2x4"||n==="mat3"||n==="mat3x2"||n==="mat3x3"||n==="mat3x4"||n==="mat4"||n==="mat4x2"||n==="mat4x3"||n==="mat4x4"}function is(n){return Na(n)||ka(n)}function te(n){return n==="mat2"||n==="mat2x2"}function ee(n){return n==="mat3"||n==="mat3x3"}function se(n){return n==="mat4"||n==="mat4x4"}function rA(n){return Math.trunc(n).toString()}function aA(n){return`${Math.max(0,Math.trunc(n)).toString()}u`}function K(n){return n===Number.POSITIVE_INFINITY?"INFINITY":n===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(n)?n.toFixed(1):n.toString()}function Gt(n){return n instanceof Ut?n.type:n.dynoOut().type}class Ut{constructor(A){this.__isDynoValue=!0,this.type=A}}class RA extends Ut{constructor(A,t){super(A.outTypes[t]),this.dyno=A,this.key=t}}class ns extends Ut{constructor(A,t){super(A),this.literal=t}getLiteral(){return this.literal}}class Ra extends ns{constructor(A,t){super(A,""),this.value=t}getLiteral(){const{type:A,value:t}=this;switch(A){case"bool":return t?"true":"false";case"uint":return aA(t);case"int":return rA(t);case"float":return K(t);case"bvec2":{const e=t;return`bvec2(${e[0]}, ${e[1]})`}case"uvec2":{if(t instanceof DA)return`uvec2(${aA(t.x)}, ${aA(t.y)})`;const e=t;return`uvec2(${aA(e[0])}, ${aA(e[1])})`}case"ivec2":{if(t instanceof DA)return`ivec2(${rA(t.x)}, ${rA(t.y)})`;const e=t;return`ivec2(${rA(e[0])}, ${rA(e[1])})`}case"vec2":{if(t instanceof DA)return`vec2(${K(t.x)}, ${K(t.y)})`;const e=t;return`vec2(${K(e[0])}, ${K(e[1])})`}case"bvec3":{const e=t;return`bvec3(${e[0]}, ${e[1]}, ${e[2]})`}case"uvec3":{if(t instanceof f)return`uvec3(${aA(t.x)}, ${aA(t.y)}, ${aA(t.z)})`;const e=t;return`uvec3(${aA(e[0])}, ${aA(e[1])}, ${aA(e[2])})`}case"ivec3":{if(t instanceof f)return`ivec3(${rA(t.x)}, ${rA(t.y)}, ${rA(t.z)})`;const e=t;return`ivec3(${rA(e[0])}, ${rA(e[1])}, ${rA(e[2])})`}case"vec3":{if(t instanceof f)return`vec3(${K(t.x)}, ${K(t.y)}, ${K(t.z)})`;const e=t;return`vec3(${K(e[0])}, ${K(e[1])}, ${K(e[2])})`}case"bvec4":{const e=t;return`bvec4(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]})`}case"uvec4":{if(t instanceof fA)return`uvec4(${aA(t.x)}, ${aA(t.y)}, ${aA(t.z)}, ${aA(t.w)})`;const e=t;return`uvec4(${aA(e[0])}, ${aA(e[1])}, ${aA(e[2])}, ${aA(e[3])})`}case"ivec4":{if(t instanceof fA)return`ivec4(${rA(t.x)}, ${rA(t.y)}, ${rA(t.z)}, ${rA(t.w)})`;const e=t;return`ivec4(${rA(e[0])}, ${rA(e[1])}, ${rA(e[2])}, ${rA(e[3])})`}case"vec4":{if(t instanceof fA)return`vec4(${K(t.x)}, ${K(t.y)}, ${K(t.z)}, ${K(t.w)})`;if(t instanceof gA)return`vec4(${K(t.x)}, ${K(t.y)}, ${K(t.z)}, ${K(t.w)})`;const e=t;return`vec4(${K(e[0])}, ${K(e[1])}, ${K(e[2])}, ${K(e[3])})`}case"mat2":case"mat2x2":{const e=t,s=e instanceof si?e.elements:t,i=new Array(4).fill(0).map((r,a)=>K(s[a]));return`${A}(${i.join(", ")})`}case"mat2x3":{const e=t,s=new Array(6).fill(0).map((i,r)=>K(e[r]));return`${A}(${s.join(", ")})`}case"mat2x4":{const e=t,s=new Array(8).fill(0).map((i,r)=>K(e[r]));return`${A}(${s.join(", ")})`}case"mat3":case"mat3x3":{const e=t,s=e instanceof VA?e.elements:t,i=new Array(9).fill(0).map((r,a)=>K(s[a]));return`${A}(${i.join(", ")})`}case"mat3x2":{const e=t,s=new Array(6).fill(0).map((i,r)=>K(e[r]));return`${A}(${s.join(", ")})`}case"mat3x4":{const e=t,s=new Array(12).fill(0).map((i,r)=>K(e[r]));return`${A}(${s.join(", ")})`}case"mat4":case"mat4x4":{const e=t,s=e instanceof cA?e.elements:t,i=new Array(16).fill(0).map((r,a)=>K(s[a]));return`${A}(${i.join(", ")})`}case"mat4x2":{const e=t,s=new Array(8).fill(0).map((i,r)=>K(e[r]));return`${A}(${s.join(", ")})`}case"mat4x3":{const e=t,s=new Array(12).fill(0).map((i,r)=>K(e[r]));return`${A}(${s.join(", ")})`}default:throw new Error(`Type not implemented: ${String(A)}`)}}}function Ga(n,A){return new Ra(n,A)}const kn="    ";class Ua{constructor({indent:A}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=kn,this.indent=A??kn}nextSequence(){return this.sequence++}}class uA{constructor({inTypes:A,outTypes:t,inputs:e,update:s,globals:i,statements:r,generate:a}){this.inTypes=A??{},this.outTypes=t??{},this.inputs=e??{},this.update=s,this.globals=i,this.statements=r,this.generate=a??(({inputs:g,outputs:o,compile:I})=>{var B,Q;return{globals:(B=this.globals)==null?void 0:B.call(this,{inputs:g,outputs:o,compile:I}),statements:(Q=this.statements)==null?void 0:Q.call(this,{inputs:g,outputs:o,compile:I})}})}get outputs(){const A={};for(const t in this.outTypes)A[t]=new RA(this,t);return A}apply(A){return Object.assign(this.inputs,A),this.outputs}compile({inputs:A,outputs:t,compile:e}){const s=[`// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(t).join(", ")})`],i=[];for(const o in t){const I=t[o];I&&!e.declares.has(I)&&(e.declares.add(I),i.push(o))}const{globals:r,statements:a,uniforms:g}=this.generate({inputs:A,outputs:t,compile:e});for(const o of r??[])e.globals.add(o);for(const o in g)e.uniforms[o]=g[o];this.update&&e.updaters.push(this.update);for(const o of i){const I=t[o];I&&(e.uniforms[I]||s.push(`${Rn(I,this.outTypes[o])};`))}return a!=null&&a.length&&(s.push("{"),s.push(...a.map(o=>e.indent+o)),s.push("}")),s}}class La extends uA{constructor({inTypes:A,outTypes:t,inputs:e,update:s,globals:i,construct:r}){super({inTypes:A,outTypes:t,inputs:e,update:s,globals:i,generate:a=>this.generateBlock(a)}),this.construct=r}generateBlock({inputs:A,outputs:t,compile:e}){var C,E;const s={},i={};for(const l in A)A[l]!=null&&(s[l]=new ns(this.inTypes[l],A[l]));for(const l in t)t[l]!=null&&(i[l]=new Ut(this.outTypes[l]));const r={roots:[]},a=this.construct(s,i,r);for(const l of((C=this.globals)==null?void 0:C.call(this,{inputs:A,outputs:t,compile:e}))??[])e.globals.add(l);const g=[],o=new Map;function I(l,c,u){let d=o.get(l);if(!d){d={sequence:e.nextSequence(),outNames:new Map,newOuts:new Set},o.set(l,d);for(const y in l.inputs){let w=l.inputs[y];for(;w;){if(w instanceof Ut){w instanceof RA&&I(w.dyno,w.key);break}w=w.dynoOut()}}g.push(l)}c&&(u||d.newOuts.add(c),d.outNames.set(c,u??`${c}_${d.sequence}`))}for(const l of r.roots)I(l);for(const l in i){let c=(a==null?void 0:a[l])??i[l];for(;c;){if(c instanceof Ut){c instanceof RA&&I(c.dyno,c.key,t[l]);break}c=c.dynoOut()}i[l]=c}const B=[];for(const l of g){const c={},u={};for(const w in l.inputs){let x=l.inputs[w];for(;x;){if(x instanceof Ut){if(x instanceof ns)c[w]=x.getLiteral();else if(x instanceof RA){const M=(E=o.get(x.dyno))==null?void 0:E.outNames.get(x.key);if(!M)throw new Error(`Source not found for ${x.dyno.constructor.name}.${x.key}`);c[w]=M}break}x=x.dynoOut()}}const d=o.get(l)??{outNames:new Map};for(const[w,x]of d.outNames.entries())u[w]=x;const y=l.compile({inputs:c,outputs:u,compile:e});B.push(y)}const Q=[];for(const l in t)i[l]instanceof ns&&Q.push(`${t[l]} = ${i[l].getLiteral()};`);return Q.length>0&&B.push(Q),{statements:B.flatMap((l,c)=>c===0?l:["",...l])}}}function rs(n,A,t,{update:e,globals:s}={}){return new La({inTypes:n,outTypes:A,construct:t,update:e,globals:s})}function ii({inTypes:n,outTypes:A,inputs:t,update:e,globals:s,statements:i,generate:r}){return new uA({inTypes:n,outTypes:A,inputs:t,update:e,globals:s,statements:i,generate:r})}function Rn(n,A,t){const e=typeof A=="string"?A:A.type;if(!e)throw new Error(`Invalid DynoType: ${String(A)}`);return`${e} ${n}${t!=null?`[${t}]`:""}`}function ot(n){var i;let A=!1;const t=n.split(`\n`).map(r=>{const a=r.trimEnd();return A?a:a.length>0?(A=!0,a):null}).filter(r=>r!=null);for(;t.length>0&&t[t.length-1].length===0;)t.pop();if(t.length===0)return[];const e=(i=t[0].match(/^\\s*/))==null?void 0:i[0];if(!e)return t;const s=new RegExp(`^${e}`);return t.map(r=>r.replace(s,""))}function ZA(n){return ot(n).join(`\n`)}class ba extends uA{constructor({a:A,outKey:t,outTypeFunc:e}){const s={a:Gt(A)},i=e(Gt(A)),r={[t]:i};super({inTypes:s,outTypes:r,inputs:{a:A}}),this.outKey=t}dynoOut(){return new RA(this,this.outKey)}}class as extends uA{constructor({a:A,b:t,outKey:e,outTypeFunc:s}){const i={a:Gt(A),b:Gt(t)},r=s(Gt(A),Gt(t)),a={[e]:r};super({inTypes:i,outTypes:a,inputs:{a:A,b:t}}),this.outKey=e}dynoOut(){return new RA(this,this.outKey)}}const ni=new Float32Array(1),Gn=new Uint32Array(ni.buffer);function ie(n){ni[0]=n;const A=Gn[0],t=A>>31&1,e=A>>23&255,s=A&8388607,i=t<<15;if(e===255)return s!==0?i|32767:i|31744;const r=e-127+15;if(r>=31)return i|31744;if(r<=0){if(r<-10)return i;const g=(s|8388608)>>1-r+13;return i|g}const a=s>>13;return i|r<<10|a}function tA(n){const A=n>>15&1,t=n>>10&31,e=n&1023;let s;if(t===0)if(e===0)s=A<<31;else{let i=e,r=-14;for(;(i&1024)===0;)i<<=1,r--;i&=1023;const a=r+127,g=i<<13;s=A<<31|a<<23|g}else if(t===31)e===0?s=A<<31|2139095040:s=A<<31|2143289344;else{const i=t-15+127,r=e<<13;s=A<<31|i<<23|r}return Gn[0]=s,ni[0]}function YA(n){return Math.max(0,Math.min(255,Math.round(n*255)))}function Un(n){const A=[],t=new Set;function e(s){s&&typeof s=="object"&&!t.has(s)&&(t.add(s),s instanceof ArrayBuffer?A.push(s):ArrayBuffer.isView(s)?A.push(s.buffer):Array.isArray(s)?s.forEach(e):Object.values(s).forEach(e))}return e(n),A}function we(n,A,t,e,s,i,r,a,g,o,I,B,Q,h,C,E){const l=YA(h),c=YA(C),u=YA(E),d=YA(Q),y=Hn(new gA(g,o,I,B)),w=y&255,x=y>>>8&255,M=y>>>16&255,p=i<jt?0:Math.min(255,Math.max(1,Math.round((Math.log(i)-$A)/gt)+1)),D=r<jt?0:Math.min(255,Math.max(1,Math.round((Math.log(r)-$A)/gt)+1)),F=a<jt?0:Math.min(255,Math.max(1,Math.round((Math.log(a)-$A)/gt)+1)),m=ie(t),S=ie(e),N=ie(s),k=A*4;n[k]=l|c<<8|u<<16|d<<24,n[k+1]=m|S<<16,n[k+2]=N|w<<16|x<<24,n[k+3]=p|D<<8|F<<16|M<<24}function Ln(n,A,t,e,s){const i=ie(t),r=ie(e),a=ie(s),g=A*4;n[g+1]=i|r<<16,n[g+2]=a|n[g+2]&4294901760}function bn(n,A,t,e,s){const i=t<jt?0:Math.min(255,Math.max(1,Math.round((Math.log(t)-$A)/gt)+1)),r=e<jt?0:Math.min(255,Math.max(1,Math.round((Math.log(e)-$A)/gt)+1)),a=s<jt?0:Math.min(255,Math.max(1,Math.round((Math.log(s)-$A)/gt)+1)),g=A*4;n[g+3]=i|r<<8|a<<16|n[g+3]&4278190080}function Yn(n,A,t,e,s,i){const r=Hn(new gA(t,e,s,i)),a=r&255,g=r>>>8&255,o=r>>>16&255,I=A*4;n[I+2]=n[I+2]&65535|a<<16|g<<24,n[I+3]=n[I+3]&16777215|o<<24}function Ya(n,A,t,e,s,i){const r=YA(t),a=YA(e),g=YA(s),o=YA(i),I=A*4;n[I]=r|a<<8|g<<16|o<<24}function Ja(n,A,t,e,s){const i=YA(t),r=YA(e),a=YA(s),g=A*4;n[g]=i|r<<8|a<<16|n[g]&4278190080}function Ha(n,A,t){const e=YA(t),s=A*4;n[s]=n[s]&16777215|e<<24}const Ta=new f,va=new f,za=new gA,qa=new kt,Ka={center:Ta,scales:va,quaternion:za,color:qa,opacity:0};function Jn(n,A){const t=Ka,e=A*4,s=n[e],i=n[e+1],r=n[e+2],a=n[e+3];t.color.set((s&255)/255,(s>>>8&255)/255,(s>>>16&255)/255),t.opacity=(s>>>24&255)/255,t.center.set(tA(i&65535),tA(i>>>16&65535),tA(r&65535));const g=a&255;t.scales.x=g===0?0:Math.exp($A+(g-1)*gt);const o=a>>>8&255;t.scales.y=o===0?0:Math.exp($A+(o-1)*gt);const I=a>>>16&255;t.scales.z=I===0?0:Math.exp($A+(I-1)*gt);const B=r>>>16&65535|a>>>8&16711680;return Oa(B,t.quaternion),t}function GA(n){const A=Z,t=Math.max(Nn,Math.min(pt,Math.ceil(n/A))),e=Math.ceil(n/(A*t)),s=A*t*e;return{width:A,height:t,depth:e,maxSplats:s}}function gs(n){const A=Z,t=Math.max(Nn,Math.min(pt,Math.ceil(n/A))),e=Math.ceil(n/(A*t));return A*t*e}const _a=ZA(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);function Hn(n){const A=n.clone().normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const t=2*Math.acos(A.w),e=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),s=e<1e-6?new f(1,0,0):new f(A.x,A.y,A.z).divideScalar(e),i=Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z);let r=s.x/i,a=s.y/i;if(s.z<0){const h=r;r=(1-Math.abs(a))*(r>=0?1:-1),a=(1-Math.abs(h))*(a>=0?1:-1)}const g=r*.5+.5,o=a*.5+.5,I=Math.round(g*255),B=Math.round(o*255);return Math.round(t*(255/Math.PI))<<16|B<<8|I}function Oa(n,A){const t=n&255,e=n>>>8&255,s=n>>>16&255,i=t/255,r=e/255;let a=(i-.5)*2,g=(r-.5)*2;const o=1-(Math.abs(a)+Math.abs(g)),I=Math.max(-o,0);a+=a>=0?-I:I,g+=g>=0?-I:I;const B=new f(a,g,o).normalize(),h=s/255*Math.PI*.5,C=Math.sin(h),E=Math.cos(h);return A.set(B.x*C,B.y*C,B.z*C,E),A}function os(n,A,t,e){const s=Math.max(-127,Math.min(127,n*127)),i=Math.max(-127,Math.min(127,A*127)),r=Math.max(-127,Math.min(127,t*127)),a=Math.max(-127,Math.min(127,e*127));return s&255|(i&255)<<8|(r&255)<<16|(a&255)<<24}function Is(n,A,t){const e=A*2;for(let s=0;s<9;++s){const i=Math.max(-63,Math.min(63,t[s]*63))&127,r=s*7,a=r+7,g=Math.floor(r/32),o=r-g*32,I=i<<o&4294967295;if(n[e+g]|=I,a>g*32+32){const B=i>>>32-o&4294967295;n[e+g+1]|=B}}}function Bs(n,A,t){n[A*4+0]=os(t[0],t[1],t[2],t[3]),n[A*4+1]=os(t[4],t[5],t[6],t[7]),n[A*4+2]=os(t[8],t[9],t[10],t[11]),n[A*4+3]=os(t[12],t[13],t[14],0)}function Qs(n,A,t){const e=A*4;for(let s=0;s<21;++s){const i=Math.max(-31,Math.min(31,t[s]*31))&63,r=s*6,a=r+6,g=Math.floor(r/32),o=r-g*32,I=i<<o&4294967295;if(n[e+g]|=I,a>g*32+32){const B=i>>>32-o&4294967295;n[e+g+1]|=B}}}function Za(n,A){const t=[];let e=0,s=null;const i=new Hi((g,o)=>{if(t.push(g),e+=g.length,o||e>=A){const I=new Uint8Array(e);let B=0;for(const Q of t)I.set(Q,B),B+=Q.length;s=I.slice(0,A)}}),r=1024;let a=0;for(;s==null&&a<n.length;){const g=n.slice(a,a+r);i.push(g,!1),a+=r}if(s==null&&(i.push(new Uint8Array,!0),s==null))throw new Error("Failed to decompress partial gzip");return s}class Pa{constructor({fileBytes:A,chunkBytes:t=64*1024}){this.fileBytes=A,this.chunkBytes=t,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new Hi((e,s)=>{this.chunks.push(e),this.totalBytes+=e.length})}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const i=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,i),!1),this.offset=i}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const t=new Uint8Array(this.totalBytes);let e=0;for(const i of this.chunks)t.set(i,e),e+=i.length;const s=t.subarray(0,A);return this.chunks=[t.subarray(A)],this.totalBytes-=A,s}}function Tn(n,A,t){const e=Math.floor(n.length/32);if(e*32!==n.length)throw new Error("Invalid .splat file size");A(e);const s=new Float32Array(n.buffer);for(let i=0;i<e;++i){const r=i*32,a=i*8,g=s[a+0],o=s[a+1],I=s[a+2],B=s[a+3],Q=s[a+4],h=s[a+5],C=n[r+24]/255,E=n[r+25]/255,l=n[r+26]/255,c=n[r+27]/255,u=(n[r+28]-128)/128,d=(n[r+29]-128)/128,y=(n[r+30]-128)/128,w=(n[r+31]-128)/128;t(i,g,o,I,B,Q,h,d,y,w,u,c,C,E,l)}}function Wa(n){let A=0,t=0,e=new Uint32Array(0);return Tn(n,s=>{A=s,t=gs(A),e=new Uint32Array(t*4)},(s,i,r,a,g,o,I,B,Q,h,C,E,l,c,u)=>{we(e,s,i,r,a,g,o,I,B,Q,h,C,E,l,c,u)}),{packedArray:e,numSplats:A}}const hs={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},vn={0:0,1:9,2:24,3:45};function Xa(n,A,t,e){var E;let r=0;const a=new DataView(n.buffer,r,4096);r+=4096;const g=a.getUint8(0),o=a.getUint8(1);if(g!==0||o<1)throw new Error(`Unsupported .ksplat version: ${g}.${o}`);const I=a.getUint32(4,!0);a.getUint32(16,!0);const B=a.getUint16(20,!0);if(B<0||B>2)throw new Error(`Invalid .ksplat compression level: ${B}`);const Q=a.getFloat32(36,!0)||-1.5,h=a.getFloat32(40,!0)||1.5;let C=4096+I*1024;for(let l=0;l<I;++l){let c=function(hA,H){if(B===0)return J.getFloat32(hA+b+H*4,!0);if(B===1)return tA(J.getUint16(hA+b+H*2,!0));const AA=J.getUint8(hA+b+H)/255;return Q+AA*(h-Q)};const u=new DataView(n.buffer,r,1024);r+=1024;const d=u.getUint32(0,!0),y=u.getUint32(4,!0),w=u.getUint32(8,!0),x=u.getUint32(12,!0),M=u.getFloat32(16,!0),p=u.getUint16(20,!0),D=(u.getUint32(24,!0)||((E=hs[B])==null?void 0:E.scaleRange))??1,F=u.getUint32(32,!0),m=F*w,S=u.getUint32(36,!0),N=S*4,k=p*x+N,G=u.getUint16(40,!0),R=vn[G],{bytesPerCenter:L,bytesPerScale:W,bytesPerRotation:_,bytesPerColor:j,bytesPerSphericalHarmonicsComponent:X,scaleOffsetBytes:$,rotationOffsetBytes:q,colorOffsetBytes:z,sphericalHarmonicsOffsetBytes:b}=hs[B],O=L+W+_+j+R*X,U=O*y,yA=U+k,dA=[0,3,6,1,4,7,2,5,8],UA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],pA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],MA=G>=1?new Float32Array(3*3):void 0,SA=G>=2?new Float32Array(5*3):void 0,PA=G>=3?new Float32Array(7*3):void 0,FA=M/2/D,JA=C+N,HA=C+k,J=new DataView(n.buffer,HA,U),QA=new Float32Array(n.buffer,JA,x*3),Y=new Uint32Array(n.buffer,C,S);let Qt=F,Be=m;for(let hA=0;hA<d;++hA){const H=hA*O;let AA;if(hA<m)AA=Math.floor(hA/w);else{const At=Y[Qt-F];hA>=Be+At&&(Qt+=1,Be+=At),AA=Qt}const v=B===0?J.getFloat32(H+0,!0):(J.getUint16(H+0,!0)-D)*FA+QA[3*AA+0],WA=B===0?J.getFloat32(H+4,!0):(J.getUint16(H+2,!0)-D)*FA+QA[3*AA+1],Se=B===0?J.getFloat32(H+8,!0):(J.getUint16(H+4,!0)-D)*FA+QA[3*AA+2],Fe=B===0?J.getFloat32(H+$+0,!0):tA(J.getUint16(H+$+0,!0)),Ne=B===0?J.getFloat32(H+$+4,!0):tA(J.getUint16(H+$+2,!0)),ci=B===0?J.getFloat32(H+$+8,!0):tA(J.getUint16(H+$+4,!0)),li=B===0?J.getFloat32(H+q+0,!0):tA(J.getUint16(H+q+0,!0)),ui=B===0?J.getFloat32(H+q+4,!0):tA(J.getUint16(H+q+2,!0)),di=B===0?J.getFloat32(H+q+8,!0):tA(J.getUint16(H+q+4,!0)),fi=B===0?J.getFloat32(H+q+12,!0):tA(J.getUint16(H+q+6,!0)),yi=J.getUint8(H+z+0)/255,pi=J.getUint8(H+z+1)/255,wi=J.getUint8(H+z+2)/255,Di=J.getUint8(H+z+3)/255;if(t(hA,v,WA,Se,Fe,Ne,ci,ui,di,fi,li,Di,yi,pi,wi),G>=1&&MA){for(const[At,Lt]of dA.entries())MA[At]=c(H,Lt);if(SA)for(const[At,Lt]of UA.entries())SA[At]=c(H,Lt);if(PA)for(const[At,Lt]of pA.entries())PA[At]=c(H,Lt);e==null||e(hA,MA,SA,PA)}}C+=yA}}function Va(n){var c;let e=0;const s=new DataView(n.buffer,e,4096);e+=4096;const i=s.getUint8(0),r=s.getUint8(1);if(i!==0||r<1)throw new Error(`Unsupported .ksplat version: ${i}.${r}`);const a=s.getUint32(4,!0),g=s.getUint32(16,!0),o=s.getUint16(20,!0);if(o<0||o>2)throw new Error(`Invalid .ksplat compression level: ${o}`);const I=s.getFloat32(36,!0)||-1.5,B=s.getFloat32(40,!0)||1.5,Q=g,h=gs(Q),C=new Uint32Array(h*4),E={};let l=4096+a*1024;for(let u=0;u<a;++u){let d=function(AA,v){if(o===0)return Y.getFloat32(AA+U+v*4,!0);if(o===1)return tA(Y.getUint16(AA+U+v*2,!0));const WA=Y.getUint8(AA+U+v)/255;return I+WA*(B-I)};const y=new DataView(n.buffer,e,1024);e+=1024;const w=y.getUint32(0,!0),x=y.getUint32(4,!0),M=y.getUint32(8,!0),p=y.getUint32(12,!0),D=y.getFloat32(16,!0),F=y.getUint16(20,!0),m=(y.getUint32(24,!0)||((c=hs[o])==null?void 0:c.scaleRange))??1,S=y.getUint32(32,!0),N=S*M,k=y.getUint32(36,!0),G=k*4,R=F*p+G,L=y.getUint16(40,!0),W=vn[L],{bytesPerCenter:_,bytesPerScale:j,bytesPerRotation:X,bytesPerColor:$,bytesPerSphericalHarmonicsComponent:q,scaleOffsetBytes:z,rotationOffsetBytes:b,colorOffsetBytes:O,sphericalHarmonicsOffsetBytes:U}=hs[o],yA=_+j+X+$+W*q,dA=yA*x,UA=dA+R,pA=[0,3,6,1,4,7,2,5,8],MA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],SA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],PA=L>=1?new Float32Array(3*3):void 0,FA=L>=2?new Float32Array(5*3):void 0,JA=L>=3?new Float32Array(7*3):void 0,HA=D/2/m,J=l+G,QA=l+R,Y=new DataView(n.buffer,QA,dA),Qt=new Float32Array(n.buffer,J,p*3),Be=new Uint32Array(n.buffer,l,k);let hA=S,H=N;for(let AA=0;AA<w;++AA){const v=AA*yA;let WA;if(AA<N)WA=Math.floor(AA/M);else{const mt=Be[hA-S];AA>=H+mt&&(hA+=1,H+=mt),WA=hA}const Se=o===0?Y.getFloat32(v+0,!0):(Y.getUint16(v+0,!0)-m)*HA+Qt[3*WA+0],Fe=o===0?Y.getFloat32(v+4,!0):(Y.getUint16(v+2,!0)-m)*HA+Qt[3*WA+1],Ne=o===0?Y.getFloat32(v+8,!0):(Y.getUint16(v+4,!0)-m)*HA+Qt[3*WA+2],ci=o===0?Y.getFloat32(v+z+0,!0):tA(Y.getUint16(v+z+0,!0)),li=o===0?Y.getFloat32(v+z+4,!0):tA(Y.getUint16(v+z+2,!0)),ui=o===0?Y.getFloat32(v+z+8,!0):tA(Y.getUint16(v+z+4,!0)),di=o===0?Y.getFloat32(v+b+0,!0):tA(Y.getUint16(v+b+0,!0)),fi=o===0?Y.getFloat32(v+b+4,!0):tA(Y.getUint16(v+b+2,!0)),yi=o===0?Y.getFloat32(v+b+8,!0):tA(Y.getUint16(v+b+4,!0)),pi=o===0?Y.getFloat32(v+b+12,!0):tA(Y.getUint16(v+b+6,!0)),wi=Y.getUint8(v+O+0)/255,Di=Y.getUint8(v+O+1)/255,At=Y.getUint8(v+O+2)/255,Lt=Y.getUint8(v+O+3)/255;if(we(C,AA,Se,Fe,Ne,ci,li,ui,fi,yi,pi,di,Lt,wi,Di,At),L>=1){if(PA){E.sh1||(E.sh1=new Uint32Array(Q*2));for(const[mt,ke]of pA.entries())PA[mt]=d(v,ke);Is(E.sh1,AA,PA)}if(FA){E.sh2||(E.sh2=new Uint32Array(Q*4));for(const[mt,ke]of MA.entries())FA[mt]=d(v,ke);Bs(E.sh2,AA,FA)}if(JA){E.sh3||(E.sh3=new Uint32Array(Q*4));for(const[mt,ke]of SA.entries())JA[mt]=d(v,ke);Qs(E.sh3,AA,JA)}}}l+=UA}return{packedArray:C,numSplats:Q,extra:E}}const xA={type:"Gsplat"},ri={type:"PackedSplats"},ja=(n,A)=>new tg({packedSplats:n,index:A}),$a=(n,A,t,e)=>new eg({packedSplats:n,index:A,base:t,count:e}),Cs=n=>new sg({gsplat:n}),ai=({gsplat:n,flags:A,index:t,center:e,scales:s,quaternion:i,rgba:r,rgb:a,opacity:g,x:o,y:I,z:B,r:Q,g:h,b:C})=>new ig({gsplat:n,flags:A,index:t,center:e,scales:s,quaternion:i,rgba:r,rgb:a,opacity:g,x:o,y:I,z:B,r:Q,g:h,b:C}),Ag=(n,{scale:A,rotate:t,translate:e,recolor:s})=>new ng({gsplat:n,scale:A,rotate:t,translate:e,recolor:s}),It=ZA(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`),gi=ZA(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`),zn=ZA(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);class tg extends uA{constructor({packedSplats:A,index:t}){super({inTypes:{packedSplats:ri,index:"int"},outTypes:{gsplat:xA},inputs:{packedSplats:A,index:t},globals:()=>[It,gi,zn],statements:({inputs:e,outputs:s})=>{const{gsplat:i}=s;if(!i)return[];const{packedSplats:r,index:a}=e;let g;return r&&a?g=ot(`\n            if (readPackedSplat(${r}.texture, ${r}.numSplats, ${a}, ${i})) {\n              bool zeroSize = all(equal(${i}.scales, vec3(0.0, 0.0, 0.0)));\n              ${i}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${i}.flags = 0u;\n            }\n          `):g=[`${i}.flags = 0u;`],g.push(`${i}.index = ${a??"0"};`),g}})}dynoOut(){return new RA(this,"gsplat")}}class eg extends uA{constructor({packedSplats:A,index:t,base:e,count:s}){super({inTypes:{packedSplats:ri,index:"int",base:"int",count:"int"},outTypes:{gsplat:xA},inputs:{packedSplats:A,index:t,base:e,count:s},globals:()=>[It,gi,zn],statements:({inputs:i,outputs:r})=>{const{gsplat:a}=r;if(!a)return[];const{packedSplats:g,index:o,base:I,count:B}=i;let Q;return g&&o&&I&&B?Q=ot(`\n            ${a}.flags = 0u;\n            if ((${o} >= ${I}) && (${o} < (${I} + ${B}))) {\n              if (readPackedSplat(${g}.texture, ${g}.numSplats, ${o}, ${a})) {\n                bool zeroSize = all(equal(${a}.scales, vec3(0.0, 0.0, 0.0)));\n                ${a}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `):Q=[`${a}.flags = 0u;`],Q.push(`${a}.index = ${o??"0"};`),Q}})}dynoOut(){return new RA(this,"gsplat")}}class sg extends uA{constructor({gsplat:A}){super({inTypes:{gsplat:xA},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:A},globals:()=>[It],statements:({inputs:t,outputs:e})=>{const{gsplat:s}=t,{flags:i,active:r,index:a,center:g,scales:o,quaternion:I,rgba:B,rgb:Q,opacity:h,x:C,y:E,z:l,r:c,g:u,b:d}=e;return[i?`${i} = ${s?`${s}.flags`:"0u"};`:null,r?`${r} = isGsplatActive(${s?`${s}.flags`:"0u"});`:null,a?`${a} = ${s?`${s}.index`:"0"};`:null,g?`${g} = ${s?`${s}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,o?`${o} = ${s?`${s}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,I?`${I} = ${s?`${s}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,B?`${B} = ${s?`${s}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,Q?`${Q} = ${s?`${s}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,h?`${h} = ${s?`${s}.rgba.a`:"0.0"};`:null,C?`${C} = ${s?`${s}.center.x`:"0.0"};`:null,E?`${E} = ${s?`${s}.center.y`:"0.0"};`:null,l?`${l} = ${s?`${s}.center.z`:"0.0"};`:null,c?`${c} = ${s?`${s}.rgba.r`:"0.0"};`:null,u?`${u} = ${s?`${s}.rgba.g`:"0.0"};`:null,d?`${d} = ${s?`${s}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class ig extends uA{constructor({gsplat:A,flags:t,index:e,center:s,scales:i,quaternion:r,rgba:a,rgb:g,opacity:o,x:I,y:B,z:Q,r:h,g:C,b:E}){super({inTypes:{gsplat:xA,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:xA},inputs:{gsplat:A,flags:t,index:e,center:s,scales:i,quaternion:r,rgba:a,rgb:g,opacity:o,x:I,y:B,z:Q,r:h,g:C,b:E},globals:()=>[It],statements:({inputs:l,outputs:c})=>{const{gsplat:u}=c;if(!u)return[];const{gsplat:d,flags:y,index:w,center:x,scales:M,quaternion:p,rgba:D,rgb:F,opacity:m,x:S,y:N,z:k,r:G,g:R,b:L}=l;return[`${u}.flags = ${y??(d?`${d}.flags`:"0u")};`,`${u}.index = ${w??(d?`${d}.index`:"0")};`,`${u}.center = ${x??(d?`${d}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${u}.scales = ${M??(d?`${d}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${u}.quaternion = ${p??(d?`${d}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${u}.rgba = ${D??(d?`${d}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,F?`${u}.rgba.rgb = ${F};`:null,m?`${u}.rgba.a = ${m};`:null,S?`${u}.center.x = ${S};`:null,N?`${u}.center.y = ${N};`:null,k?`${u}.center.z = ${k};`:null,G?`${u}.rgba.r = ${G};`:null,R?`${u}.rgba.g = ${R};`:null,L?`${u}.rgba.b = ${L};`:null].filter(Boolean)}})}dynoOut(){return new RA(this,"gsplat")}}ZA(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);class ng extends uA{constructor({gsplat:A,scale:t,rotate:e,translate:s,recolor:i}){super({inTypes:{gsplat:xA,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:xA},inputs:{gsplat:A,scale:t,rotate:e,translate:s,recolor:i},globals:()=>[It],statements:({inputs:r,outputs:a,compile:g})=>{const{gsplat:o}=a;if(!o||!r.gsplat)return[];const{scale:I,rotate:B,translate:Q,recolor:h}=r,C=g.indent;return[`${o} = ${r.gsplat};`,`if (isGsplatActive(${o}.flags)) {`,I?`${C}${o}.center *= ${I};`:null,B?`${C}${o}.center = quatVec(${B}, ${o}.center);`:null,Q?`${C}${o}.center += ${Q};`:null,I?`${C}${o}.scales *= ${I};`:null,B?`${C}${o}.quaternion = quatQuat(${B}, ${o}.quaternion);`:null,h?`${C}${o}.rgba *= ${h};`:null,"}"].filter(Boolean)}})}dynoOut(){return new RA(this,"gsplat")}}const rg=n=>new ag({gsplat:n});class ag extends uA{constructor({gsplat:A}){super({inTypes:{gsplat:xA},inputs:{gsplat:A},globals:()=>[It],statements:({inputs:t,outputs:e})=>{const{output:s}=e;if(!s)return[];const{gsplat:i}=t;return i?ot(`\n            if (isGsplatActive(${i}.flags)) {\n              ${s} = packSplat(${i}.center, ${i}.scales, ${i}.quaternion, ${i}.rgba);\n            } else {\n              ${s} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `):[`${s} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new RA(this,"output")}}class gg extends uA{constructor({rgba8:A}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:A},statements:({inputs:t,outputs:e})=>[`target = ${t.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new RA(this,"rgba8")}}class Bt extends uA{constructor({key:A,type:t,count:e,value:s,update:i,globals:r}){A=A??"value",super({outTypes:{[A]:t},update:()=>{if(i){const a=i(this.value);a!==void 0&&(this.value=a)}this.uniform.value=this.value},generate:({inputs:a,outputs:g})=>{const o=(r==null?void 0:r({inputs:a,outputs:g}))??[],I={},B=g[A];return B&&(o.push(`uniform ${Rn(B,t,e)};`),I[B]=this.uniform),{globals:o,uniforms:I}}}),this.type=t,this.count=e,this.value=s,this.uniform={value:s},this.outKey=A}dynoOut(){return new RA(this,this.outKey)}}class oi extends Bt{constructor({key:A,value:t,update:e}){super({key:A,type:"int",value:t,update:e})}}class Es extends Bt{constructor({key:A,value:t,update:e}){super({key:A,type:"float",value:t,update:e})}}class og extends Bt{constructor({key:A,value:t,update:e}){super({key:A,type:"vec3",value:t,update:e})}}class qn extends Bt{constructor({key:A,value:t,update:e}){super({key:A,type:"vec4",value:t,update:e})}}class Ii extends Bt{constructor({key:A,value:t,update:e}){super({key:A,type:"usampler2DArray",value:t,update:e})}}class Kn{constructor({graph:A,inputs:t,outputs:e,template:s}){this.graph=A,this.template=s,this.inputs=t??{},this.outputs=e??{};const i=new Ua({indent:this.template.indent});for(const a in this.outputs)this.outputs[a]&&i.declares.add(this.outputs[a]);const r=A.compile({inputs:this.inputs,outputs:this.outputs,compile:i});this.shader=s.generate({globals:i.globals,statements:r}),this.uniforms=i.uniforms,this.updaters=i.updaters}prepareMaterial(){return Ig(this)}update(){for(const A of this.updaters)A()}}class _n{constructor(A){const t=A.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m),e=A.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);if(!t||!e)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=A.substring(0,t.index),this.between=A.substring(t.index+t[0].length,e.index),this.after=A.substring(e.index+e[0].length),this.indent=e[1]}generate({globals:A,statements:t}){return this.before+Array.from(A).join(`\n\n`)+this.between+t.map(e=>this.indent+e).join(`\n`)+this.after}}const On=new Map;function Ig(n){let A=On.get(n);return A||(A=new ti({glslVersion:Zr,vertexShader:_a,fragmentShader:n.shader,uniforms:n.uniforms}),On.set(n,A),A)}function Zn(n,A,t="add"){const e=()=>{throw new Error(`Invalid ${t} types: ${n}, ${A}`)};if(n===A)return n;if(n==="int"){if($t(A))return A;e()}if(A==="int"){if($t(n))return n;e()}if(n==="uint"){if(Ae(A))return A;e()}if(A==="uint"){if(Ae(n))return n;e()}if(n==="float"){if(is(A))return A;e()}if(A==="float"){if(is(n))return n;e()}throw new Error(`Invalid ${t} types: ${n}, ${A}`)}function Bg(n,A){return Zn(n,A,"sub")}function Qg(n,A){const t=()=>{throw new Error(`Invalid mul types: ${n}, ${A}`)},e=s=>s;if(n==="int"){if($t(A))return e(A);t()}if(A==="int"){if($t(n))return e(n);t()}if(n==="uint"){if(Ae(A))return e(A);t()}if(A==="uint"){if(Ae(n))return e(n);t()}if(n==="float"){if(is(A))return e(A);t()}if(A==="float"){if(is(n))return e(n);t()}if($t(n)||Ae(n)||$t(A)||Ae(A)){if(n===A)return e(n);t()}if(n==="vec2"){if(A==="vec2"||te(A))return e("vec2");if(A==="mat3x2")return e("vec3");if(A==="mat4x2")return e("vec4");t()}if(n==="vec3"){if(A==="mat2x3")return e("vec2");if(A==="vec3"||ee(A))return e("vec3");if(A==="mat4x3")return e("vec4");t()}if(n==="vec4"){if(A==="mat2x4")return e("vec2");if(A==="mat3x4")return e("vec3");if(A==="vec4"||se(A))return e("vec4");t()}if(A==="vec2"){if(te(n))return e("vec2");if(n==="mat2x3")return e("vec3");if(n==="mat2x4")return e("vec4");t()}if(A==="vec3"){if(n==="mat3x2")return e("vec2");if(ee(n))return e("vec3");if(n==="mat3x4")return e("vec4");t()}if(A==="vec4"){if(n==="mat4x2")return e("vec2");if(n==="mat4x3")return e("vec3");if(se(n))return e("vec4");t()}if(te(n)){if(te(A))return e("mat2");if(A==="mat3x2")return e("mat3x2");if(A==="mat4x2")return e("mat4x2");t()}if(n==="mat2x3"){if(te(A))return e("mat2x3");if(A==="mat3x2")return e("mat3");if(A==="mat4x2")return e("mat4x3");t()}if(n==="mat2x4"){if(te(A))return e("mat2x4");if(A==="mat3x2")return e("mat3x4");if(A==="mat4x2")return e("mat4");t()}if(n==="mat3x2"){if(A==="mat2x3")return e("mat2");if(ee(A))return e("mat3x2");if(A==="mat4x3")return e("mat4x2");t()}if(ee(n)){if(A==="mat2x3")return e("mat2x3");if(ee(A))return e("mat3");if(A==="mat4x3")return e("mat4x3");t()}if(n==="mat3x4"){if(A==="mat2x3")return e("mat2x4");if(ee(A))return e("mat3x4");if(A==="mat4x3")return e("mat4");t()}if(n==="mat4x2"){if(A==="mat2x4")return e("mat2");if(A==="mat3x4")return e("mat3x2");if(se(A))return e("mat4x2");t()}if(n==="mat4x3"){if(A==="mat2x4")return e("mat2x3");if(A==="mat3x4")return e("mat3");if(se(A))return e("mat4x3");t()}if(se(n)){if(A==="mat2x4")return e("mat2x4");if(A==="mat3x4")return e("mat3x4");if(se(A))return e("mat4");t()}throw new Error(`Invalid mul types: ${n}, ${A}`)}const cs=(n,A)=>new Eg({a:n,b:A}),hg=(n,A)=>new cg({a:n,b:A}),Cg=(n,A)=>new lg({a:n,b:A});class Eg extends as{constructor({a:A,b:t}){super({a:A,b:t,outKey:"sum",outTypeFunc:Zn}),this.statements=({inputs:e,outputs:s})=>[`${s.sum} = ${e.a} + ${e.b};`]}}class cg extends as{constructor({a:A,b:t}){super({a:A,b:t,outKey:"difference",outTypeFunc:Bg}),this.statements=({inputs:e,outputs:s})=>[`${s.difference} = ${e.a} - ${e.b};`]}}class lg extends as{constructor({a:A,b:t}){super({a:A,b:t,outKey:"product",outTypeFunc:Qg}),this.statements=({inputs:e,outputs:s})=>[`${s.product} = ${e.a} * ${e.b};`]}}const ug=n=>new fg({a:n}),dg=(n,A)=>new pg({a:n,b:A});class fg extends ba{constructor({a:A}){super({a:A,outTypeFunc:t=>t,outKey:"normalize"}),this.statements=({inputs:t,outputs:e})=>[`${e.normalize} = normalize(${t.a});`]}}function yg(n){if(n==="float")return"vec2";if(n==="vec2")return"vec3";if(n==="vec3")return"vec4";throw new Error("Invalid type")}class pg extends as{constructor({a:A,b:t}){const e=Gt(A),s=yg(e);super({a:A,b:t,outKey:"extend",outTypeFunc:()=>s}),this.statements=({inputs:i,outputs:r})=>[`${r.extend} = ${s}(${i.a}, ${i.b});`]}}const wg=(n,{scale:A,scales:t,rotate:e,translate:s})=>new mg({position:n,scale:A,scales:t,rotate:e,translate:s}).outputs.position,Dg=(n,{scale:A,scales:t,rotate:e})=>new xg({dir:n,scale:A,scales:t,rotate:e}).outputs.dir;class mg extends uA{constructor({position:A,scale:t,scales:e,rotate:s,translate:i}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:A,scale:t,scales:e,rotate:s,translate:i},statements:({inputs:r,outputs:a})=>{const{position:g}=a;if(!g)return[];const{scale:o,scales:I,rotate:B,translate:Q}=r;return[`${g} = ${r.position??"vec3(0.0, 0.0, 0.0)"};`,o?`${g} *= ${o};`:null,I?`${g} *= ${I};`:null,B?`${g} = quatVec(${B}, ${g});`:null,Q?`${g} += ${Q};`:null].filter(Boolean)}})}}class xg extends uA{constructor({dir:A,scale:t,scales:e,rotate:s}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:A,scale:t,scales:e,rotate:s},statements:({inputs:i,outputs:r})=>{const{dir:a}=r;if(!a)return[];const{scale:g,scales:o,rotate:I}=i;return[`${a} = ${i.dir??"vec3(0.0, 0.0, 0.0)"};`,g?`${a} *= ${g};`:null,o?`${a} *= ${o};`:null,I?`${a} = quatVec(${I}, ${a});`:null].filter(Boolean)}})}}var Mg=`precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}`;const P=class P{constructor(A={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new Pn({packedSplats:this}),this.initialized=Promise.resolve(this),this.reinitialize(A)}reinitialize(A){this.isInitialized=!1,A.url||A.fileBytes||A.construct?this.initialized=this.asyncInitialize(A).then(()=>(this.isInitialized=!0,this)):(this.initialize(A),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(A){A.packedArray?(this.packedArray=A.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/Z)*Z,this.numSplats=Math.min(this.maxSplats,A.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=A.maxSplats??0,this.numSplats=0),this.extra=A.extra??{}}async asyncInitialize(A){const{url:t,fileBytes:e,construct:s}=A;if(t){const i=new Pg;i.packedSplats=this,await i.loadAsync(t)}else if(e){const i=await Br({input:e,fileType:A.fileType,pathOrUrl:A.fileName??t});this.initialize(i)}if(s){const i=s(this);i instanceof Promise&&await i}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(A){const t=A<=this.maxSplats?this.maxSplats:Math.max(A,2*this.maxSplats),e=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||t>e){this.maxSplats=GA(t).maxSplats;const s=new Uint32Array(this.maxSplats*4);this.packedArray&&s.set(this.packedArray),this.packedArray=s}return this.packedArray}ensureSplatsSh(A,t){let e,s;if(A===0)return this.ensureSplats(t);if(A===1)e=2,s="sh1";else if(A===2)e=4,s="sh2";else if(A===3)e=4,s="sh3";else throw new Error(`Invalid level: ${A}`);let i=this.extra[s]?this.extra[s].length/e:0;const r=t<=i?i:Math.max(t,2*i);if(!this.extra[s]||r>i){i=GA(r).maxSplats;const a=new Uint32Array(i*e);this.extra[s]&&a.set(this.extra[s]),this.extra[s]=a}return this.extra[s]}getSplat(A){if(!this.packedArray||A>=this.numSplats)throw new Error("Invalid index");return Jn(this.packedArray,A)}setSplat(A,t,e,s,i,r){const a=this.ensureSplats(A+1);we(a,A,t.x,t.y,t.z,e.x,e.y,e.z,s.x,s.y,s.z,s.w,i,r.r,r.g,r.b),this.numSplats=Math.max(this.numSplats,A+1)}pushSplat(A,t,e,s,i){const r=this.ensureSplats(this.numSplats+1);we(r,this.numSplats,A.x,A.y,A.z,t.x,t.y,t.z,e.x,e.y,e.z,e.w,s,i.r,i.g,i.b),++this.numSplats}forEachSplat(A){if(!(!this.packedArray||!this.numSplats))for(let t=0;t<this.numSplats;++t){const e=Jn(this.packedArray,t);A(t,e.center,e.scales,e.quaternion,e.opacity,e.color)}}ensureGenerate(A){if(this.target&&(A??1)<=this.maxSplats)return!1;this.dispose();const t=GA(A??1),{width:e,height:s,depth:i}=t;return this.maxSplats=t.maxSplats,this.target=new In(e,s,i,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:Et,minFilter:Et}),this.target.texture.format=Yt,this.target.texture.type=Mt,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(A){let t=0;const e=A.map(s=>{const i=t,r=Math.ceil(s/Z)*Z;return t+=r,{base:i,count:s}});return{maxSplats:t,mapping:e}}getTexture(){return this.target?this.target.texture:this.source||this.packedArray?this.maybeUpdateSource():P.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:t,depth:e}=this.source.image;this.maxSplats!==A*t*e&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:A,height:t,depth:e}=GA(this.maxSplats);this.source=new ct(this.packedArray,A,t,e),this.source.format=Yt,this.source.type=Mt,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!P.emptySource){const{width:A,height:t,depth:e,maxSplats:s}=GA(1),i=new Uint32Array(s*4);P.emptySource=new ct(i,A,t,e),P.emptySource.format=Yt,P.emptySource.type=Mt,P.emptySource.internalFormat="RGBA32UI",P.emptySource.needsUpdate=!0}return P.emptySource}prepareProgramMaterial(A){let t=P.generatorProgram.get(A);if(!t){const s=rs({index:"int"},{output:"uvec4"},({index:i})=>{A.inputs.index=i;const r=A.outputs.gsplat;return{output:rg(r)}});P.programTemplate||(P.programTemplate=new _n(Mg)),t=new Kn({graph:s,inputs:{index:"index"},outputs:{output:"target"},template:P.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),P.generatorProgram.set(A,t)}const e=t.prepareMaterial();return P.mesh.material=e,{program:t,material:e}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,t){A.setRenderTarget(null),A.xr.enabled=t.xrEnabled,A.autoClear=t.autoClear}generate({generator:A,base:t,count:e,renderer:s}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(t+e>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:i,material:r}=this.prepareProgramMaterial(A);i.update();const a=this.saveRenderState(s),g=Math.ceil((t+e)/Z)*Z,o=Z*pt;for(r.uniforms.targetBase.value=t,r.uniforms.targetCount.value=e;t<g;){const I=Math.floor(t/o);r.uniforms.targetLayer.value=I;const B=I*o,Q=Math.floor((t-B)/Z),h=Math.min(pt,Math.ceil((g-B)/Z));this.target.scissor.set(0,Q,Z,h-Q),s.setRenderTarget(this.target,I),s.xr.enabled=!1,s.autoClear=!1,s.render(P.scene,P.camera),t+=Z*(h-Q)}return this.resetRenderState(s,a),{nextBase:g}}};P.emptySource=null,P.programTemplate=null,P.generatorProgram=new Map,P.geometry=new ss(2,2),P.mesh=new xn(P.geometry,new ti({visible:!1})),P.scene=new Sn().add(P.mesh),P.camera=new Mn;let ne=P;class Pn extends Bt{constructor({packedSplats:A}={}){super({key:"packedSplats",type:ri,globals:()=>[gi],value:{texture:ne.getEmpty(),numSplats:0},update:t=>{var e,s;return t.texture=((e=this.packedSplats)==null?void 0:e.getTexture())??ne.getEmpty(),t.numSplats=((s=this.packedSplats)==null?void 0:s.numSplats)??0,t}}),this.packedSplats=A}}var Sg=`precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}`;const IA=class IA{constructor({renderer:A}={}){this.renderer=A,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(A,t){const s=Math.ceil(Math.max(1,A)/Z)*Z*4;if(t.byteLength>=s)return t;const i=new ArrayBuffer(s);if(t instanceof ArrayBuffer)return i;const r=t.constructor;return new r(i)}ensureCapacity(A){const{width:t,height:e,depth:s,maxSplats:i}=GA(A);(!this.target||i>this.capacity)&&(this.dispose(),this.capacity=i,this.target=new In(t,e,s,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:Et,minFilter:Et}),this.target.texture.format=Je,this.target.texture.type=Ye,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(A){let t=IA.readbackProgram.get(A);if(!t){const s=rs({index:"int"},{rgba8:"vec4"},({index:i})=>(A.inputs.index=i,{rgba8:new gg({rgba8:A.outputs.rgba8})}));IA.programTemplate||(IA.programTemplate=new _n(Sg)),t=new Kn({graph:s,inputs:{index:"index"},outputs:{rgba8:"target"},template:IA.programTemplate}),Object.assign(t.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),IA.readbackProgram.set(A,t)}const e=t.prepareMaterial();return IA.mesh.material=e,{program:t,material:e}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,t){A.setRenderTarget(null),A.xr.enabled=t.xrEnabled,A.autoClear=t.autoClear}process({count:A,material:t}){const e=this.renderer;if(!e)throw new Error("No renderer");if(!this.target)throw new Error("No target");const s=Z*pt;t.uniforms.targetBase.value=0,t.uniforms.targetCount.value=A;let i=0;for(;i<A;){const r=Math.floor(i/s),a=r*s,g=Math.min(pt,Math.ceil((A-a)/Z));t.uniforms.targetLayer.value=r,this.target.scissor.set(0,0,Z,g),e.setRenderTarget(this.target,r),e.xr.enabled=!1,e.autoClear=!1,e.render(IA.scene,IA.camera),i+=Z*g}this.count=A}async read({readback:A}){const t=this.renderer;if(!t)throw new Error("No renderer");if(!this.target)throw new Error("No target");const e=Math.ceil(this.count/Z)*Z;if(A.byteLength<e*4)throw new Error(`Readback buffer too small: ${A.byteLength} < ${e*4}`);const s=new Uint8Array(A instanceof ArrayBuffer?A:A.buffer),i=Z*pt;let r=0;const a=[];for(;r<this.count;){const g=Math.floor(r/i),o=g*i,I=Math.min(pt,Math.ceil((this.count-o)/Z));t.setRenderTarget(this.target,g);const B=Z*I*4,Q=s.subarray(o*4,o*4+B),h=t==null?void 0:t.readRenderTargetPixelsAsync(this.target,0,0,Z,I,Q);a.push(h),r+=Z*I}return Promise.all(a).then(()=>A)}render({reader:A,count:t,renderer:e}){if(this.renderer=e||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(t);const{program:s,material:i}=this.prepareProgramMaterial(A);s.update();const r=this.saveRenderState(this.renderer);this.process({count:t,material:i}),this.resetRenderState(this.renderer,r)}async readback({readback:A}){if(!this.renderer)throw new Error("No renderer");const t=this.saveRenderState(this.renderer),e=this.read({readback:A});return this.resetRenderState(this.renderer,t),e}async renderReadback({reader:A,count:t,renderer:e,readback:s}){if(this.renderer=e||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(t);const{program:i,material:r}=this.prepareProgramMaterial(A);i.update();const a=this.saveRenderState(this.renderer);this.process({count:t,material:r});const g=this.read({readback:s});return this.resetRenderState(this.renderer,a),g}getTexture(){var A;return(A=this.target)==null?void 0:A.texture}};IA.programTemplate=null,IA.readbackProgram=new Map,IA.geometry=new ss(2,2),IA.mesh=new xn(IA.geometry,new ti({visible:!1})),IA.scene=new Sn().add(IA.mesh),IA.camera=new Mn;let Bi=IA;const BA=class BA{constructor(A={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new Bt({key:"rgbaArray",type:Xn,globals:()=>[Vn],value:{texture:BA.getEmpty(),count:0},update:t=>{var e;return t.texture=((e=this.readback)==null?void 0:e.getTexture())??this.source??BA.getEmpty(),t.count=this.count,t}}),A.array?(this.array=A.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/Z)*Z,this.count=Math.min(this.capacity,A.count??Number.POSITIVE_INFINITY)):(this.capacity=A.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(A){var t;if(!this.array||A>(((t=this.array)==null?void 0:t.length)??0)/4){this.capacity=GA(A).maxSplats;const e=new Uint8Array(this.capacity*4);this.array&&e.set(this.array),this.array=e}return this.array}getTexture(){var t;let A=(t=this.readback)==null?void 0:t.getTexture();return(this.source||this.array)&&(A=this.maybeUpdateSource()),A??BA.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:t,depth:e}=this.source.image;this.capacity!==A*t*e&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:A,height:t,depth:e}=GA(this.capacity);this.source=new ct(this.array,A,t,e),this.source.format=Je,this.source.type=Ye,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:A,count:t,renderer:e}){this.readback||(this.readback=new Bi({renderer:e})),this.readback.render({reader:A,count:t,renderer:e}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:A,base:t,count:e,renderer:s}){const{dynoSplats:i,dynoBase:r,dynoCount:a,reader:g}=BA.makeDynos();return i.packedSplats=A,r.value=t,a.value=e,this.render({reader:g,count:e,renderer:s}),this}async read(){if(!this.readback)throw new Error("No readback");return(!this.array||this.array.length<this.count*4)&&(this.array=new Uint8Array(this.capacity*4)),(await this.readback.readback({readback:this.array})).subarray(0,this.count*4)}static getEmpty(){if(!BA.emptySource){const A=new Uint8Array(4);BA.emptySource=new ct(A,1,1,1),BA.emptySource.format=Je,BA.emptySource.type=Ye,BA.emptySource.internalFormat="RGBA8",BA.emptySource.needsUpdate=!0}return BA.emptySource}static makeDynos(){if(!BA.dynos){const A=new Pn,t=new oi({value:0}),e=new oi({value:0}),s=rs({index:"int"},{rgba8:"vec4"},({index:i})=>{if(!i)throw new Error("index is undefined");i=cs(i,t);const r=$a(A,i,t,e);return{rgba8:Cs(r).outputs.rgba}});BA.dynos={dynoSplats:A,dynoBase:t,dynoCount:e,reader:s}}return BA.dynos}};BA.emptySource=null,BA.dynos=null;let Wn=BA;const Xn={type:"RgbaArray"},Vn=ZA(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);function Fg(n,A){return new uA({inTypes:{rgba:Xn,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:n,index:A},globals:()=>[Vn],statements:({inputs:e,outputs:s})=>ot(`\n        if ((index >= 0) && (index < ${e.rgba}.count)) {\n          ${s.rgba} = texelFetch(${e.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${s.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)}).outputs.rgba}function Ng(n){switch(n){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${n}`)}}function kg(n){switch(n){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${n}`)}}class Rg extends mA{constructor(A={}){super();const{type:t,invert:e,opacity:s,color:i,displace:r,radius:a}=A;this.type=t??"sphere",this.invert=e??!1,this.opacity=s??1,this.color=i??new kt(1,1,1),this.displace=r??new f(0,0,0),this.radius=a??0}}const ws=class ws extends mA{constructor(A={}){const{name:t,rgbaBlendMode:e="multiply",sdfSmooth:s=0,softEdge:i=0,invert:r=!1,sdfs:a=null}=A;super(),this.rgbaBlendMode=e,this.sdfSmooth=s,this.softEdge=i,this.invert=r,this.sdfs=a,this.ordering=ws.nextOrdering++,this.name=t??`Edit ${this.ordering}`}addSdf(A){this.sdfs==null&&(this.sdfs=[]),this.sdfs.includes(A)||this.sdfs.push(A)}removeSdf(A){this.sdfs!=null&&(this.sdfs=this.sdfs.filter(t=>t!==A))}};ws.nextOrdering=1;let Qi=ws;class Gg{constructor({maxSdfs:A,maxEdits:t}){this.maxSdfs=Math.max(16,A??0),this.numSdfs=0,this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new Bt({key:"sdfArray",type:jn,globals:()=>[$n],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:e=>(e.numSdfs=this.numSdfs,e.sdfTexture=this.sdfTexture,e)}),this.maxEdits=Math.max(16,t??0),this.numEdits=0,this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new oi({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(A,t){const e=new pa(A,8,t,Yt,Mt);return e.internalFormat="RGBA32UI",e.needsUpdate=!0,e}newEdits(A,t){return new Bt({key:"edits",type:"uvec4",count:t,globals:()=>[Ar],value:A})}ensureCapacity({maxSdfs:A,maxEdits:t}){let e=!1;return A>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(this.maxSdfs*2,A),this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),t>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(this.maxEdits*2,t),this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),e=!0),e}updateEditData(A,t){const e=this.editData[A]!==t;return this.editData[A]=t,e}updateEditFloatData(A,t){re[0]=t;const e=this.editFloatData[A]!==re[0];return e&&(this.editFloatData[A]=re[0]),e}encodeEdit(A,{sdfFirst:t,sdfCount:e,invert:s,rgbaBlendMode:i,softEdge:r,sdfSmooth:a}){const g=A*4;let o=!1;return o=this.updateEditData(g+0,i|(s?256:0))||o,o=this.updateEditData(g+1,t|e<<16)||o,o=this.updateEditFloatData(g+2,r)||o,o=this.updateEditFloatData(g+3,a)||o,o}updateSdfData(A,t){const e=this.sdfData[A]!==t;return this.sdfData[A]=t,e}updateSdfFloatData(A,t){re[0]=t;const e=this.sdfFloatData[A]!==re[0];return e&&(this.sdfFloatData[A]=re[0]),e}encodeSdf(A,{sdfType:t,invert:e,center:s,quaternion:i,scale:r,sizes:a},g){const o=A*32,I=t|(e?256:0);let B=!1;B=this.updateSdfFloatData(o+0,(s==null?void 0:s.x)??0)||B,B=this.updateSdfFloatData(o+1,(s==null?void 0:s.y)??0)||B,B=this.updateSdfFloatData(o+2,(s==null?void 0:s.z)??0)||B,B=this.updateSdfData(o+3,I)||B,B=this.updateSdfFloatData(o+4,(i==null?void 0:i.x)??0)||B,B=this.updateSdfFloatData(o+5,(i==null?void 0:i.y)??0)||B,B=this.updateSdfFloatData(o+6,(i==null?void 0:i.z)??0)||B,B=this.updateSdfFloatData(o+7,(i==null?void 0:i.w)??0)||B,B=this.updateSdfFloatData(o+8,(r==null?void 0:r.x)??0)||B,B=this.updateSdfFloatData(o+9,(r==null?void 0:r.y)??0)||B,B=this.updateSdfFloatData(o+10,(r==null?void 0:r.z)??0)||B,B=this.updateSdfData(o+11,0)||B,B=this.updateSdfFloatData(o+12,(a==null?void 0:a.x)??0)||B,B=this.updateSdfFloatData(o+13,(a==null?void 0:a.y)??0)||B,B=this.updateSdfFloatData(o+14,(a==null?void 0:a.z)??0)||B,B=this.updateSdfFloatData(o+15,(a==null?void 0:a.w)??0)||B;const Q=Math.min(4,g.length);for(let h=0;h<Q;++h){const C=o+16+h*4;B=this.updateSdfFloatData(C+0,g[h].x)||B,B=this.updateSdfFloatData(C+1,g[h].y)||B,B=this.updateSdfFloatData(C+2,g[h].z)||B,B=this.updateSdfFloatData(C+3,g[h].w)||B}return B}update(A){const t=A.reduce((B,{sdfs:Q})=>B+Q.length,0),e=this.ensureCapacity({maxEdits:A.length,maxSdfs:t}),s=[new fA,new fA],i=new f,r=new gA,a=new f,g=new fA;let o=0,I=e;A.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=A.length,this.numEdits=A.length,I=!0);for(const[B,{edit:Q,sdfs:h}]of A.entries()){I=this.encodeEdit(B,{sdfFirst:o,sdfCount:h.length,invert:Q.invert,rgbaBlendMode:kg(Q.rgbaBlendMode),softEdge:Q.softEdge,sdfSmooth:Q.sdfSmooth})||I;let C=!1;for(const E of h)g.set(E.scale.x,E.scale.y,E.scale.z,E.radius),E.scale.setScalar(1),E.updateMatrixWorld(),E.matrixWorld.clone().invert().decompose(i,r,a),E.scale.set(g.x,g.y,g.z),E.updateMatrixWorld(),s[0].set(E.color.r,E.color.g,E.color.b,E.opacity),s[1].set(E.displace.x,E.displace.y,E.displace.z,1),C=this.encodeSdf(o,{sdfType:Ng(E.type),invert:E.invert,center:i,quaternion:r,scale:a,sizes:g},s)||C,o+=1;this.numSdfs=o,C&&(this.sdfTexture.needsUpdate=!0),I||(I=C)}return{updated:I,dynoUpdated:e}}modify(A){return Ug(A,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const jn={type:"SdfArray"},$n=ZA(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`),Ar=ZA(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);function Ug(n,A,t,e){return new uA({inTypes:{gsplat:xA,sdfArray:jn,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:xA},globals:()=>[$n,Ar],inputs:{gsplat:n,sdfArray:A,numEdits:t,rgbaDisplaceEdits:e},statements:({inputs:i,outputs:r})=>{const{sdfArray:a,numEdits:g,rgbaDisplaceEdits:o}=i,{gsplat:I}=r;return ot(`\n        ${I} = ${i.gsplat};\n        if (isGsplatActive(${I}.flags)) {\n          for (int editIndex = 0; editIndex < ${g}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${o}[editIndex], ${a}.sdfTexture, ${a}.numSdfs,\n              ${I}.center, ${I}.rgba\n            );\n          }\n        }\n      `)}}).outputs.gsplat}const re=new Float32Array(1);class ls{constructor(){this.scale=new Es({value:Number.NEGATIVE_INFINITY}),this.rotate=new qn({value:new gA(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new og({value:new f(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(A){return wg(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(A){return Dg(A,{rotate:this.rotate})}applyGsplat(A){return Ag(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(A){const t=new f,e=new gA,s=new f;A.decompose(s,e,t);const i=(t.x+t.y+t.z)/3;let r=!1;return i!==this.scale.value&&(this.scale.value=i,r=!0),s.equals(this.translate.value)||(this.translate.value.copy(s),r=!0),e.equals(this.rotate.value)||(this.rotate.value.copy(e),r=!0),r}update(A){return A.updateMatrixWorld(),this.updateFromMatrix(A.matrixWorld)}}class Lg extends mA{constructor({numSplats:A,generator:t,construct:e,update:s}){if(super(),this.numSplats=A??0,this.generator=t,this.frameUpdate=s,this.version=0,e){const i=e(this);Object.assign(this,i)}}updateVersion(){this.version+=1}set needsUpdate(A){A&&this.updateVersion()}}const Dt=class Dt extends Lg{constructor(A={}){const t=new ls,e=new ls,s=new ls,i=new ls,r=new qn({value:new fA(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),a=new Es({value:0}),g=new Es({value:0}),o={transform:t,viewToWorld:e,worldToView:s,viewToObject:i,recolor:r,time:a,deltaTime:g};if(super({update:({time:I,deltaTime:B,viewToWorld:Q,globalEdits:h})=>this.update({time:I,deltaTime:B,viewToWorld:Q,globalEdits:h})}),this.isInitialized=!1,this.recolor=new kt(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=A.packedSplats??new ne,this.numSplats=this.packedSplats.numSplats,this.editable=A.editable??!0,this.onFrame=A.onFrame,this.context=o,this.objectModifier=A.objectModifier,this.worldModifier=A.worldModifier,this.updateGenerator(),A.url||A.fileBytes||A.constructSplats||A.packedSplats&&!A.packedSplats.isInitialized)this.initialized=this.asyncInitialize(A).then(async()=>{if(this.updateGenerator(),this.isInitialized=!0,A.onLoad){const I=A.onLoad(this);I instanceof Promise&&await I}return this});else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),A.onLoad){const I=A.onLoad(this);I instanceof Promise&&(this.initialized=I.then(()=>this))}}async asyncInitialize(A){const{url:t,fileBytes:e,fileType:s,fileName:i,maxSplats:r,constructSplats:a}=A;if(t||e||a){const g={url:t,fileBytes:e,fileType:s,fileName:i,maxSplats:r,construct:a};this.packedSplats.reinitialize(g)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await Ds(),Dt.isStaticInitialized=!0}pushSplat(A,t,e,s,i){this.packedSplats.pushSplat(A,t,e,s,i)}forEachSplat(A){this.packedSplats.forEachSplat(A)}dispose(){this.packedSplats.dispose()}constructGenerator(A){const{transform:t,viewToObject:e,recolor:s}=A,i=rs({index:"int"},{gsplat:xA},({index:r})=>{if(!r)throw new Error("index is undefined");let a=ja(this.packedSplats.dyno,r);if(this.maxSh>=1){const{sh1Texture:o,sh2Texture:I,sh3Texture:B}=this.ensureShTextures();if(o){const Q=e.translate,{center:h}=Cs(a).outputs,C=ug(hg(h,Q));let E=Hg(a,o,C);this.maxSh>=2&&I&&(E=cs(E,Tg(a,I,C))),this.maxSh>=3&&B&&(E=cs(E,vg(a,B,C)));let{rgba:l}=Cs(a).outputs;l=cs(l,dg(E,Ga("float",0))),a=ai({gsplat:a,rgba:l})}}if(this.splatRgba){const o=Fg(this.splatRgba.dyno,r);a=ai({gsplat:a,rgba:o})}this.skinning&&(a=this.skinning.modify(a)),this.objectModifier&&(a=this.objectModifier.apply({gsplat:a}).gsplat),a=t.applyGsplat(a);const g=Cg(s,Cs(a).outputs.rgba);return a=ai({gsplat:a,rgba:g}),this.rgbaDisplaceEdits&&(a=this.rgbaDisplaceEdits.modify(a)),this.worldModifier&&(a=this.worldModifier.apply({gsplat:a}).gsplat),{gsplat:a}});this.generator=i}updateGenerator(){this.constructGenerator(this.context)}update({time:A,viewToWorld:t,deltaTime:e,globalEdits:s}){var l;this.numSplats=this.packedSplats.numSplats,this.context.time.value=A,this.context.deltaTime.value=e,Dt.dynoTime.value=A;const{transform:i,viewToObject:r,recolor:a}=this.context;let g=i.update(this);this.context.viewToWorld.updateFromMatrix(t)&&this.enableViewToWorld&&(g=!0);const o=t.clone().invert();this.context.worldToView.updateFromMatrix(o)&&this.enableWorldToView&&(g=!0);const Q=new cA().compose(i.translate.value,i.rotate.value,new f().setScalar(i.scale.value)).invert().multiply(t);r.updateFromMatrix(Q)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(g=!0);const h=new fA(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);h.equals(a.value)||(a.value.copy(h),g=!0);const C=this.editable?(this.edits??[]).concat(s):[];this.editable&&!this.edits&&this.traverseVisible(c=>{c instanceof Qi&&C.push(c)}),C.sort((c,u)=>c.ordering-u.ordering);const E=C.map(c=>{if(c.sdfs!=null)return{edit:c,sdfs:c.sdfs};const u=[];return c.traverseVisible(d=>{d instanceof Rg&&u.push(d)}),{edit:c,sdfs:u}});if(E.length>0&&!this.rgbaDisplaceEdits){const c=E.length,u=E.reduce((d,y)=>d+y.sdfs.length,0);this.rgbaDisplaceEdits=new Gg({maxEdits:c,maxSdfs:u}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const c=this.rgbaDisplaceEdits.update(E);g||(g=c.updated),c.dynoUpdated&&this.updateGenerator()}g&&this.updateVersion(),(l=this.onFrame)==null||l.call(this,{mesh:this,time:A,deltaTime:e})}raycast(A,t){if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:e,far:s,ray:i}=A,r=this.matrixWorld.clone().invert(),a=new VA().setFromMatrix4(r),g=i.origin.clone().applyMatrix4(r),o=i.direction.clone().applyMatrix3(a),I=new f;r.decompose(new f,new gA,I),(I.x*I.y*I.z)**(1/3);const Q=yr(g.x,g.y,g.z,o.x,o.y,o.z,e,s,this.packedSplats.numSplats,this.packedSplats.packedArray,!0);for(const h of Q){const C=i.direction.clone().multiplyScalar(h).add(i.origin);t.push({distance:h,point:C,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let A=this.packedSplats.extra.sh1Texture;if(!A){let s=this.packedSplats.extra.sh1;const{width:i,height:r,depth:a,maxSplats:g}=GA(s.length/2);if(s.length<g*2){const I=new Uint32Array(g*2);I.set(s),this.packedSplats.extra.sh1=I,s=I}const o=new ct(s,i,r,a);o.format=Or,o.type=Mt,o.internalFormat="RG32UI",o.needsUpdate=!0,A=new Ii({value:o,key:"sh1"}),this.packedSplats.extra.sh1Texture=A}if(!this.packedSplats.extra.sh2)return{sh1Texture:A};let t=this.packedSplats.extra.sh2Texture;if(!t){let s=this.packedSplats.extra.sh2;const{width:i,height:r,depth:a,maxSplats:g}=GA(s.length/4);if(s.length<g*4){const I=new Uint32Array(g*4);I.set(s),this.packedSplats.extra.sh2=I,s=I}const o=new ct(s,i,r,a);o.format=Yt,o.type=Mt,o.internalFormat="RGBA32UI",o.needsUpdate=!0,t=new Ii({value:o,key:"sh2"}),this.packedSplats.extra.sh2Texture=t}if(!this.packedSplats.extra.sh3)return{sh1Texture:A,sh2Texture:t};let e=this.packedSplats.extra.sh3Texture;if(!e){let s=this.packedSplats.extra.sh3;const{width:i,height:r,depth:a,maxSplats:g}=GA(s.length/4);if(s.length<g*4){const I=new Uint32Array(g*4);I.set(s),this.packedSplats.extra.sh3=I,s=I}const o=new ct(s,i,r,a);o.format=Yt,o.type=Mt,o.internalFormat="RGBA32UI",o.needsUpdate=!0,e=new Ii({value:o,key:"sh3"}),this.packedSplats.extra.sh3Texture=e}return{sh1Texture:A,sh2Texture:t,sh3Texture:e}}};Dt.staticInitialized=Dt.staticInitialize(),Dt.isStaticInitialized=!1,Dt.dynoTime=new Es({value:0});let hi=Dt;const bg=ZA(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`),Yg=ZA(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`),Jg=ZA(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);function Hg(n,A,t){return ii({inTypes:{gsplat:xA,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh1:A,viewDir:t},globals:()=>[It,bg],statements:({inputs:e,outputs:s})=>ot(`\n        if (isGsplatActive(${e.gsplat}.flags)) {\n          ${s.rgb} = evaluateSH1(${e.gsplat}, ${e.sh1}, ${e.viewDir});\n        } else {\n          ${s.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function Tg(n,A,t){return ii({inTypes:{gsplat:xA,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh2:A,viewDir:t},globals:()=>[It,Yg],statements:({inputs:e,outputs:s})=>ot(`\n        if (isGsplatActive(${e.gsplat}.flags)) {\n          ${s.rgb} = evaluateSH2(${e.gsplat}, ${e.sh2}, ${e.viewDir});\n        } else {\n          ${s.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function vg(n,A,t){return ii({inTypes:{gsplat:xA,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:n,sh3:A,viewDir:t},globals:()=>[It,Jg],statements:({inputs:e,outputs:s})=>ot(`\n        if (isGsplatActive(${e.gsplat}.flags)) {\n          ${s.rgb} = evaluateSH3(${e.gsplat}, ${e.sh3}, ${e.viewDir});\n        } else {\n          ${s.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}const Ie=class Ie{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const t=new ReadableStream({start:r=>{r.enqueue(this.fileBytes.slice(0,65536)),r.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const e=`end_header\n`;for(;;){const{value:r,done:a}=await t.read();if(a)throw new Error("Failed to read header");this.header+=r;const g=this.header.indexOf(e);if(g>=0){this.header=this.header.slice(0,g+e.length);break}}const s=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,s),this.elements={};let i=null;this.comments=[],this.header.trim().split(`\n`).forEach((r,a)=>{const g=r.trim();if(a===0){if(g!=="ply")throw new Error("Invalid PLY header");return}if(g.length===0)return;const o=g.split(" ");switch(o[0]){case"format":if(o[1]==="binary_little_endian")this.littleEndian=!0;else if(o[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${o[1]}`);if(o[2]!=="1.0")throw new Error(`Unsupported PLY version: ${o[2]}`);break;case"end_header":break;case"comment":this.comments.push(g.slice(8));break;case"element":{const I=o[1];i={name:I,count:Number.parseInt(o[2]),properties:{}},this.elements[I]=i;break}case"property":if(i==null)throw new Error("Property must be inside an element");o[1]==="list"?i.properties[o[4]]={isList:!0,type:o[3],countType:o[2]}:i.properties[o[2]]={isList:!1,type:o[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let t=0;const e=this.data;if(e==null)throw new Error("No data to parse");for(const s in this.elements){const i=this.elements[s],{count:r,properties:a}=i,g={},o=[];for(const[B,Q]of Object.entries(a))Q.isList?(g[B]=[],o.push(()=>{const h=g[B];h.length=ds[Q.countType](e,t,this.littleEndian),t+=ae[Q.countType];for(let C=0;C<h.length;C++)h[C]=ds[Q.type](e,t,this.littleEndian),t+=ae[Q.type]})):(g[B]=0,o.push(()=>{g[B]=ds[Q.type](e,t,this.littleEndian),t+=ae[Q.type]}));const I=A(i)??(()=>{});for(let B=0;B<r;B++){for(const Q of o)Q();I(B,g)}}}parseSplats(A,t){if(this.elements.vertex==null)throw new Error("No vertex element found");let e=!1;const s=[];let i=0,r=[],a=[],g=[],o,I,B;function Q(){const c=qg[i];r=new Array(3).fill(null).flatMap((u,d)=>[0,1,2].map((y,w)=>`f_rest_${d+w*c/3}`)),a=new Array(5).fill(null).flatMap((u,d)=>[0,1,2].map((y,w)=>`f_rest_${3+d+w*c/3}`)),g=new Array(7).fill(null).flatMap((u,d)=>[0,1,2].map((y,w)=>`f_rest_${8+d+w*c/3}`)),o=i>=1?new Float32Array(3*3):void 0,I=i>=2?new Float32Array(5*3):void 0,B=i>=3?new Float32Array(7*3):void 0}function h(c,u){if(!o)throw new Error("Missing sh1");for(const[d,y]of r.entries())o[d]=u[y]*8/255-4;if(I)for(const[d,y]of a.entries())I[d]=u[y]*8/255-4;if(B)for(const[d,y]of g.entries())B[d]=u[y]*8/255-4;t==null||t(c,o,I,B)}function C(c){const{min_x:u,min_y:d,min_z:y,max_x:w,max_y:x,max_z:M,min_scale_x:p,min_scale_y:D,min_scale_z:F,max_scale_x:m,max_scale_y:S,max_scale_z:N}=c.properties;if(!u||!d||!y||!w||!x||!M||!p||!D||!F||!m||!S||!N)throw new Error("Missing PLY chunk properties");return e=!0,(k,G)=>{const{min_x:R,min_y:L,min_z:W,max_x:_,max_y:j,max_z:X,min_scale_x:$,min_scale_y:q,min_scale_z:z,max_scale_x:b,max_scale_y:O,max_scale_z:U,min_r:yA,min_g:dA,min_b:UA,max_r:pA,max_g:MA,max_b:SA}=G;s.push({min_x:R,min_y:L,min_z:W,max_x:_,max_y:j,max_z:X,min_scale_x:$,min_scale_y:q,min_scale_z:z,max_scale_x:b,max_scale_y:O,max_scale_z:U,min_r:yA,min_g:dA,min_b:UA,max_r:pA,max_g:MA,max_b:SA})}}function E(c){if(t&&c.name==="sh")return i=er(c.properties),Q(),h;if(c.name!=="vertex")return null;const{packed_position:u,packed_rotation:d,packed_scale:y,packed_color:w}=c.properties;if(!u||!d||!y||!w)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const x=Math.sqrt(2);return(M,p)=>{const D=s[M>>>8];if(D==null)throw new Error("Missing PLY chunk");const{min_x:F,min_y:m,min_z:S,max_x:N,max_y:k,max_z:G,min_scale_x:R,min_scale_y:L,min_scale_z:W,max_scale_x:_,max_scale_y:j,max_scale_z:X,min_r:$,min_g:q,min_b:z,max_r:b,max_g:O,max_b:U}=D,{packed_position:yA,packed_rotation:dA,packed_scale:UA,packed_color:pA}=p,MA=(yA>>>21&2047)/2047*(N-F)+F,SA=(yA>>>11&1023)/1023*(k-m)+m,PA=(yA&2047)/2047*(G-S)+S,FA=((dA>>>20&1023)/1023-.5)*x,JA=((dA>>>10&1023)/1023-.5)*x,HA=((dA&1023)/1023-.5)*x,J=Math.sqrt(Math.max(0,1-FA*FA-JA*JA-HA*HA)),QA=dA>>>30,Y=QA===0?FA:QA===1?J:JA,Qt=QA<=1?JA:QA===2?J:HA,Be=QA<=2?HA:J,hA=QA===0?J:FA,H=Math.exp((UA>>>21&2047)/2047*(_-R)+R),AA=Math.exp((UA>>>11&1023)/1023*(j-L)+L),v=Math.exp((UA&2047)/2047*(X-W)+W),WA=(pA>>>24&255)/255*((b??1)-($??0))+($??0),Se=(pA>>>16&255)/255*((O??1)-(q??0))+(q??0),Fe=(pA>>>8&255)/255*((U??1)-(z??0))+(z??0),Ne=(pA&255)/255;A(M,MA,SA,PA,H,AA,v,Y,Qt,Be,hA,Ne,WA,Se,Fe)}}const l=c=>{if(c.name==="chunk")return C(c);if(e)return E(c);if(c.name!=="vertex")return null;const{x:u,y:d,z:y,scale_0:w,scale_1:x,scale_2:M,rot_0:p,rot_1:D,rot_2:F,rot_3:m,opacity:S,f_dc_0:N,f_dc_1:k,f_dc_2:G,red:R,green:L,blue:W,alpha:_}=c.properties;if(!u||!d||!y)throw new Error("Missing PLY properties: x, y, z");const j=w&&x&&M,X=p&&D&&F&&m,$=_!=null?fs[_.type]:1,q=R!=null?fs[R.type]:1,z=L!=null?fs[L.type]:1,b=W!=null?fs[W.type]:1;return i=er(c.properties),Q(),(O,U)=>{const yA=j?Math.exp(U.scale_0):Ie.defaultPointScale,dA=j?Math.exp(U.scale_1):Ie.defaultPointScale,UA=j?Math.exp(U.scale_2):Ie.defaultPointScale,pA=X?U.rot_1:0,MA=X?U.rot_2:0,SA=X?U.rot_3:0,PA=X?U.rot_0:1,FA=S!=null?1/(1+Math.exp(-U.opacity)):_!=null?U.alpha/$:1,JA=N!=null?U.f_dc_0*us+.5:R!=null?U.red/q:1,HA=k!=null?U.f_dc_1*us+.5:L!=null?U.green/z:1,J=G!=null?U.f_dc_2*us+.5:W!=null?U.blue/b:1;if(A(O,U.x,U.y,U.z,yA,dA,UA,pA,MA,SA,PA,FA,JA,HA,J),t&&o){if(o)for(const[QA,Y]of r.entries())o[QA]=U[Y];if(I)for(const[QA,Y]of a.entries())I[QA]=U[Y];if(B)for(const[QA,Y]of g.entries())B[QA]=U[Y];t(O,o,I,B)}}};this.parseData(l)}injectRgba(A){let t=0;const e=this.data;if(e==null)throw new Error("No parsed data");if(A.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const s in this.elements){const i=this.elements[s],{count:r,properties:a}=i,g=[];let o=0;const I=s==="vertex";if(I){for(const B of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!a[B]||a[B].type!=="float")throw new Error(`Can\'t injectRgba due to property: ${B}`)}for(const[B,Q]of Object.entries(a))if(Q.isList)g.push(()=>{const h=ds[Q.countType](e,t,this.littleEndian);t+=ae[Q.countType],t+=h*ae[Q.type]});else{if(I)if(B==="f_dc_0"||B==="f_dc_1"||B==="f_dc_2"){const h=Number.parseInt(B.slice(5));g.push(()=>{const C=(A[o+h]/255-.5)/us;tr[Q.type](e,t,this.littleEndian,C)})}else B==="opacity"&&g.push(()=>{const h=Math.max(-100,Math.min(100,-Math.log(1/(A[o+3]/255)-1)));tr[Q.type](e,t,this.littleEndian,h)});g.push(()=>{t+=ae[Q.type]})}for(let B=0;B<r;B++){for(const Q of g)Q();I&&(o+=4)}}}};Ie.defaultPointScale=.001;let De=Ie;const us=.28209479177387814,ds={char:(n,A,t)=>n.getInt8(A),uchar:(n,A,t)=>n.getUint8(A),short:(n,A,t)=>n.getInt16(A,t),ushort:(n,A,t)=>n.getUint16(A,t),int:(n,A,t)=>n.getInt32(A,t),uint:(n,A,t)=>n.getUint32(A,t),float:(n,A,t)=>n.getFloat32(A,t),double:(n,A,t)=>n.getFloat64(A,t)},tr={char:(n,A,t,e)=>{n.setInt8(A,e)},uchar:(n,A,t,e)=>{n.setUint8(A,e)},short:(n,A,t,e)=>{n.setInt16(A,e,t)},ushort:(n,A,t,e)=>{n.setUint16(A,e,t)},int:(n,A,t,e)=>{n.setInt32(A,e,t)},uint:(n,A,t,e)=>{n.setUint32(A,e,t)},float:(n,A,t,e)=>{n.setFloat32(A,e,t)},double:(n,A,t,e)=>{n.setFloat64(A,e,t)}},ae={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},fs={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},zg={0:0,9:1,24:2,45:3},qg={0:0,1:9,2:24,3:45};function er(n){let A=0;for(;n[`f_rest_${A}`];)A+=1;const t=zg[A];if(t==null)throw new Error(`Unsupported number of SH coefficients: ${A}`);return t}function Kg(n){return new Worker(self.location.href,{name:n==null?void 0:n.name})}class _g{constructor(){this.messages={},this.messageIdNext=0,this.worker=new Kg,this.worker.onmessage=A=>this.onMessage(A)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const A=this.makeMessageId(),t=new Promise((e,s)=>{this.messages[A]={resolve:e,reject:s}});return{id:A,promise:t}}onMessage(A){const{id:t,result:e,error:s}=A.data,i=this.messages[t];i&&(delete this.messages[t],s?i.reject(s):i.resolve(e))}async call(A,t){const{id:e,promise:s}=this.makeMessagePromiseId();return this.worker.postMessage({name:A,args:t,id:e},{transfer:Un(t)}),s}}let sr=4,ys=0;const ir=[],nr=[];async function Og(){const n=ir.shift();if(n)return n;if(ys<sr){const A=new _g;return ys+=1,A}return new Promise(A=>{nr.push(A)})}function Zg(n){if(ys>sr){ys-=1;return}const A=nr.shift();if(A){A(n);return}ir.push(n)}async function ge(n){const A=await Og();try{return await n(A)}finally{Zg(A)}}class Pg extends ei{constructor(A){super(A),this.fileLoader=new xa(A)}load(A,t,e,s){const i=this.manager.resolveURL((this.path??"")+(A??"")),r=new Headers(this.requestHeader),a=this.withCredentials?"include":"same-origin",g=new Request(i,{headers:r,credentials:a});let o=this.fileType;this.manager.itemStart(i),rr(g,e).then(async I=>{const B=[new ProgressEvent("progress",{lengthComputable:!0,loaded:I.byteLength,total:I.byteLength})];function Q(){if(e){const l=B.every(d=>d.lengthComputable||d.loaded===0&&d.total===0),c=B.reduce((d,y)=>d+y.loaded,0),u=B.reduce((d,y)=>d+y.total,0);e(new ProgressEvent("progress",{lengthComputable:l,loaded:c,total:u}))}}const h={},C=[],E=or(I);if(o==="pcsogs"&&E===void 0)throw new Error("Invalid PC SOGS file");if(E!==void 0){o="pcsogs";for(const l of["means","scales","quats","sh0","shN"]){const c=E[l];if(c)for(const u of c.files){const d=new URL(u,i).toString(),y=B.length;B.push(new ProgressEvent("progress")),this.manager.itemStart(d);const w=new Request(d,{headers:r,credentials:a}),x=rr(w,M=>{B[y]=M,Q()}).then(M=>{h[u]=M}).catch(M=>{throw this.manager.itemError(d),M}).finally(()=>{this.manager.itemEnd(d)});C.push(x)}}}if(await Promise.all(C),t){const l=await Br({input:I,extraFiles:h,fileType:o,pathOrUrl:i});this.packedSplats?(this.packedSplats.initialize(l),t(this.packedSplats)):t(new ne(l))}}).catch(I=>{this.manager.itemError(i),s==null||s(I)}).finally(()=>{this.manager.itemEnd(i)})}async loadAsync(A,t){return new Promise((e,s)=>{this.load(A,i=>{e(i)},t,s)})}parse(A){return new hi({packedSplats:A})}}async function rr(n,A){const t=await fetch(n);if(!t.ok)throw new Error(`${t.status} "${t.statusText}" fetching URL: ${n.url}`);if(!t.body)throw new Error(`Response body is null for URL: ${n.url}`);const e=t.body.getReader(),s=Number.parseInt(t.headers.get("Content-Length")||"0"),i=Number.isNaN(s)?0:s;let r=0;const a=[];for(;;){const{done:I,value:B}=await e.read();if(I)break;a.push(B),r+=B.length,A&&A(new ProgressEvent("progress",{lengthComputable:i!==0,loaded:r,total:i}))}const g=new Uint8Array(r);let o=0;for(const I of a)g.set(I,o),o+=I.length;return g.buffer}var me=(n=>(n.PLY="ply",n.SPZ="spz",n.SPLAT="splat",n.KSPLAT="ksplat",n.PCSOGS="pcsogs",n.PCSOGSZIP="pcsogszip",n))(me||{});function ar(n){const A=new DataView(n.buffer);if((A.getUint32(0,!0)&16777215)===7957616)return"ply";if((A.getUint32(0,!0)&16777215)===559903){const t=Za(n,4);return new DataView(t.buffer).getUint32(0,!0)===1347635022?"spz":void 0}if(A.getUint32(0,!0)===67324752)return Ir(n)?"pcsogszip":void 0}function Wg(n){const A=n.split(/[?#]/,1)[0],t=Math.max(A.lastIndexOf("/"),A.lastIndexOf("\\\\")),e=A.slice(t+1),s=e.lastIndexOf(".");return s<=0||s===e.length-1?"":e.slice(s+1).toLowerCase()}function gr(n){const A=Wg(n);if(A==="ply")return"ply";if(A==="spz")return"spz";if(A==="splat")return"splat";if(A==="ksplat")return"ksplat"}function or(n){try{let A;if(typeof n=="string")A=n;else{const e=n instanceof ArrayBuffer?new Uint8Array(n):n;if(e.length>65536)return;A=new TextDecoder().decode(e)}const t=JSON.parse(A);if(!t||typeof t!="object"||Array.isArray(t))return;for(const e of["means","scales","quats","sh0"])if(!t[e]||typeof t[e]!="object"||Array.isArray(t[e])||!t[e].shape||!t[e].files||e!=="quats"&&(!t[e].mins||!t[e].maxs))return;return t}catch{return}}function Ir(n){try{const A=n instanceof ArrayBuffer?new Uint8Array(n):n;let t=null;const e=vr(A,{filter:({name:i})=>i.split(/[\\\\/]/).pop()==="meta.json"?(t=i,!0):!1});if(!t)return;const s=or(e[t]);return s?{name:t,json:s}:void 0}catch{return}}async function Br({input:n,extraFiles:A,fileType:t,pathOrUrl:e}){const s=n instanceof ArrayBuffer?new Uint8Array(n):n;let i=t;switch(t||(i=ar(s),!i&&e&&(i=gr(e))),i){case"ply":{const r=new De({fileBytes:s});await r.parseHeader();const a=r.numSplats,g=GA(a).maxSplats,o={fileBytes:s,packedArray:new Uint32Array(g*4)};return await ge(async I=>{const{packedArray:B,numSplats:Q,extra:h}=await I.call("unpackPly",o);return{packedArray:B,numSplats:Q,extra:h}})}case"spz":return await ge(async r=>{const{packedArray:a,numSplats:g,extra:o}=await r.call("decodeSpz",{fileBytes:s});return{packedArray:a,numSplats:g,extra:o}});case"splat":return await ge(async r=>{const{packedArray:a,numSplats:g}=await r.call("decodeAntiSplat",{fileBytes:s});return{packedArray:a,numSplats:g}});case"ksplat":return await ge(async r=>{const{packedArray:a,numSplats:g,extra:o}=await r.call("decodeKsplat",{fileBytes:s});return{packedArray:a,numSplats:g,extra:o}});case"pcsogs":return await ge(async r=>{const{packedArray:a,numSplats:g,extra:o}=await r.call("decodePcSogs",{fileBytes:s,extraFiles:A});return{packedArray:a,numSplats:g,extra:o}});case"pcsogszip":return await ge(async r=>{const{packedArray:a,numSplats:g,extra:o}=await r.call("decodePcSogsZip",{fileBytes:s});return{packedArray:a,numSplats:g,extra:o}});default:throw new Error(`Unknown splat file type: ${i}`)}}class Xg{constructor({maxSplats:A=1}={}){this.numSplats=0,this.maxSplats=GA(A).maxSplats,this.centers=new Float32Array(this.maxSplats*3),this.scales=new Float32Array(this.maxSplats*3),this.quaternions=new Float32Array(this.maxSplats*4),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(this.maxSplats*3)}pushSplat(){const A=this.numSplats;return this.ensureIndex(A),this.numSplats+=1,A}unpushSplat(A){if(A===this.numSplats-1)this.numSplats-=1;else throw new Error("Cannot unpush splat from non-last position")}ensureCapacity(A){if(A>this.maxSplats){const t=Math.max(A,this.maxSplats*2),e=new Float32Array(t*3),s=new Float32Array(t*3),i=new Float32Array(t*4),r=new Float32Array(t),a=new Float32Array(t*3);if(e.set(this.centers),s.set(this.scales),i.set(this.quaternions),r.set(this.opacities),a.set(this.colors),this.centers=e,this.scales=s,this.quaternions=i,this.opacities=r,this.colors=a,this.sh1){const g=new Float32Array(t*9);g.set(this.sh1),this.sh1=g}if(this.sh2){const g=new Float32Array(t*15);g.set(this.sh2),this.sh2=g}if(this.sh3){const g=new Float32Array(t*21);g.set(this.sh3),this.sh3=g}this.maxSplats=t}}ensureIndex(A){this.ensureCapacity(A+1)}setCenter(A,t,e,s){this.centers[A*3]=t,this.centers[A*3+1]=e,this.centers[A*3+2]=s}setScale(A,t,e,s){this.scales[A*3]=t,this.scales[A*3+1]=e,this.scales[A*3+2]=s}setQuaternion(A,t,e,s,i){this.quaternions[A*4]=t,this.quaternions[A*4+1]=e,this.quaternions[A*4+2]=s,this.quaternions[A*4+3]=i}setOpacity(A,t){this.opacities[A]=t}setColor(A,t,e,s){this.colors[A*3]=t,this.colors[A*3+1]=e,this.colors[A*3+2]=s}setSh1(A,t){this.sh1||(this.sh1=new Float32Array(this.maxSplats*9));for(let e=0;e<9;++e)this.sh1[A*9+e]=t[e]}setSh2(A,t){this.sh2||(this.sh2=new Float32Array(this.maxSplats*15));for(let e=0;e<15;++e)this.sh2[A*15+e]=t[e]}setSh3(A,t){this.sh3||(this.sh3=new Float32Array(this.maxSplats*21));for(let e=0;e<21;++e)this.sh3[A*21+e]=t[e]}}async function Qr(n,A){if(n.quats.encoding!=="quaternion_packed")throw new Error("Unsupported quaternion encoding");const t=n.means.shape[0],e=gs(t),s=new Uint32Array(e*4),i={},r=await Promise.all([xe(A[n.means.files[0]]),xe(A[n.means.files[1]])]);for(let Q=0;Q<t;++Q){const h=Q*4,C=(r[0][h+0]+(r[1][h+0]<<8))/65535,E=(r[0][h+1]+(r[1][h+1]<<8))/65535,l=(r[0][h+2]+(r[1][h+2]<<8))/65535;let c=n.means.mins[0]+(n.means.maxs[0]-n.means.mins[0])*C,u=n.means.mins[1]+(n.means.maxs[1]-n.means.mins[1])*E,d=n.means.mins[2]+(n.means.maxs[2]-n.means.mins[2])*l;c=Math.sign(c)*(Math.exp(Math.abs(c))-1),u=Math.sign(u)*(Math.exp(Math.abs(u))-1),d=Math.sign(d)*(Math.exp(Math.abs(d))-1),Ln(s,Q,c,u,d)}const a=await xe(A[n.scales.files[0]]);for(let Q=0;Q<t;++Q){const h=Q*4,C=a[h+0]/255,E=a[h+1]/255,l=a[h+2]/255,c=n.scales.mins[0]+(n.scales.maxs[0]-n.scales.mins[0])*C,u=n.scales.mins[1]+(n.scales.maxs[1]-n.scales.mins[1])*E,d=n.scales.mins[2]+(n.scales.maxs[2]-n.scales.mins[2])*l;bn(s,Q,Math.exp(c),Math.exp(u),Math.exp(d))}const g=await xe(A[n.quats.files[0]]),o=Math.sqrt(2);for(let Q=0;Q<t;++Q){const h=Q*4,C=(g[h+0]/255-.5)*o,E=(g[h+1]/255-.5)*o,l=(g[h+2]/255-.5)*o,c=Math.sqrt(Math.max(0,1-C*C-E*E-l*l)),u=g[h+3]-252,d=u===0?C:u===1?c:E,y=u<=1?E:u===2?c:l,w=u<=2?l:c;Yn(s,Q,d,y,w,u===0?c:C)}const I=await xe(A[n.sh0.files[0]]),B=.28209479177387814;for(let Q=0;Q<t;++Q){const h=Q*4,C=I[h+0]/255,E=I[h+1]/255,l=I[h+2]/255,c=I[h+3]/255,u=n.sh0.mins[0]+(n.sh0.maxs[0]-n.sh0.mins[0])*C,d=n.sh0.mins[1]+(n.sh0.maxs[1]-n.sh0.mins[1])*E,y=n.sh0.mins[2]+(n.sh0.maxs[2]-n.sh0.mins[2])*l,w=n.sh0.mins[3]+(n.sh0.maxs[3]-n.sh0.mins[3])*c,x=B*u+.5,M=B*d+.5,p=B*y+.5,D=1/(1+Math.exp(-w));Ya(s,Q,x,M,p,D)}if(n.shN){const Q=n.shN.shape[1]>=45,h=n.shN.shape[1]>=24,C=n.shN.shape[1]>=9;C&&(i.sh1=new Uint32Array(t*2)),h&&(i.sh2=new Uint32Array(t*4)),Q&&(i.sh3=new Uint32Array(t*4));const E=new Float32Array(9),l=new Float32Array(15),c=new Float32Array(21),[u,d]=await Promise.all([Ci(A[n.shN.files[0]]),Ci(A[n.shN.files[1]])]);for(let y=0;y<t;++y){const w=y*4,x=d.rgba[w+0]+(d.rgba[w+1]<<8),M=(x&63)*15,D=(x>>>6)*u.width+M;for(let F=0;F<3;++F){if(C)for(let m=0;m<3;++m)E[m*3+F]=n.shN.mins+(n.shN.maxs-n.shN.mins)*u.rgba[(D+m)*4+F]/255;if(h)for(let m=0;m<5;++m)l[m*3+F]=n.shN.mins+(n.shN.maxs-n.shN.mins)*u.rgba[(D+3+m)*4+F]/255;if(Q)for(let m=0;m<7;++m)c[m*3+F]=n.shN.mins+(n.shN.maxs-n.shN.mins)*u.rgba[(D+8+m)*4+F]/255}C&&Is(i.sh1,y,E),h&&Bs(i.sh2,y,l),Q&&Qs(i.sh3,y,c)}}return{packedArray:s,numSplats:t,extra:i}}let ps=null;async function Ci(n){if(!ps&&(ps=new OffscreenCanvas(1,1).getContext("webgl2"),!ps))throw new Error("Failed to create WebGL2 context");const A=new Blob([n]),t=await createImageBitmap(A,{premultiplyAlpha:"none"}),e=ps,s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0);const r=new Uint8Array(t.width*t.height*4);return e.readPixels(0,0,t.width,t.height,e.RGBA,e.UNSIGNED_BYTE,r),e.deleteTexture(s),e.deleteFramebuffer(i),{rgba:r,width:t.width,height:t.height}}async function xe(n){const{rgba:A}=await Ci(n);return A}async function Vg(n){var B;const A=Ir(n);if(!A)throw new Error("Invalid PC SOGS zip file");const{name:t,json:e}=A,s=t.lastIndexOf("/"),i=t.lastIndexOf("\\\\"),r=t.slice(0,Math.max(s,i)+1),a=new Map,g=[...e.means.files,...e.scales.files,...e.quats.files,...e.sh0.files,...((B=e.shN)==null?void 0:B.files)??[]];for(const Q of g)a.set(r+Q,Q);const o=await new Promise((Q,h)=>{Tr(n,{filter:({name:C})=>a.has(C)},(C,E)=>{C?h(C):Q(E)})}),I={};for(const[Q,h]of a.entries())I[h]=o[Q];return await Qr(e,I)}class hr{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new Pa({fileBytes:this.fileBytes});const t=new DataView(this.reader.read(16).buffer);if(t.getUint32(0,!0)!==1347635022)throw new Error("Invalid SPZ file");if(this.version=t.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=t.getUint32(8,!0),this.shDegree=t.getUint8(12),this.fractionalBits=t.getUint8(13),this.flags=t.getUint8(14),this.flagAntiAlias=(this.flags&1)!==0,this.reserved=t.getUint8(15),this.parsed=!1}parseSplats(A,t,e,s,i,r){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,this.version===1){const a=this.reader.read(this.numSplats*3*2),g=new Uint16Array(a.buffer);for(let o=0;o<this.numSplats;o++){const I=o*3,B=tA(g[I]),Q=tA(g[I+1]),h=tA(g[I+2]);A==null||A(o,B,Q,h)}}else if(this.version===2){const a=1<<this.fractionalBits,g=this.reader.read(this.numSplats*3*3);for(let o=0;o<this.numSplats;o++){const I=o*9,B=((g[I+2]<<24|g[I+1]<<16|g[I]<<8)>>8)/a,Q=((g[I+5]<<24|g[I+4]<<16|g[I+3]<<8)>>8)/a,h=((g[I+8]<<24|g[I+7]<<16|g[I+6]<<8)>>8)/a;A==null||A(o,B,Q,h)}}else throw new Error("Unreachable");{const a=this.reader.read(this.numSplats);for(let g=0;g<this.numSplats;g++)t==null||t(g,a[g]/255)}{const a=this.reader.read(this.numSplats*3),g=Er/.15;for(let o=0;o<this.numSplats;o++){const I=o*3,B=(a[I]/255-.5)*g+.5,Q=(a[I+1]/255-.5)*g+.5,h=(a[I+2]/255-.5)*g+.5;e==null||e(o,B,Q,h)}}{const a=this.reader.read(this.numSplats*3);for(let g=0;g<this.numSplats;g++){const o=g*3,I=Math.exp(a[o]/16-10),B=Math.exp(a[o+1]/16-10),Q=Math.exp(a[o+2]/16-10);s==null||s(g,I,B,Q)}}{const a=this.reader.read(this.numSplats*3);for(let g=0;g<this.numSplats;g++){const o=g*3,I=a[o]/127.5-1,B=a[o+1]/127.5-1,Q=a[o+2]/127.5-1,h=Math.sqrt(Math.max(0,1-I*I-B*B-Q*Q));i==null||i(g,I,B,Q,h)}}if(r&&this.shDegree>=1){const a=new Float32Array(9),g=this.shDegree>=2?new Float32Array(5*3):void 0,o=this.shDegree>=3?new Float32Array(7*3):void 0,I=this.reader.read(this.numSplats*Cr[this.shDegree]*3);let B=0;for(let Q=0;Q<this.numSplats;Q++){for(let h=0;h<9;++h)a[h]=(I[B+h]-128)/128;if(B+=9,g){for(let h=0;h<15;++h)g[h]=(I[B+h]-128)/128;B+=15}if(o){for(let h=0;h<21;++h)o[h]=(I[B+h]-128)/128;B+=21}r==null||r(Q,a,g,o)}}}}const Cr={1:3,2:8,3:15},Er=.28209479177387814,jg=1347635022,$g=2,Ao=1;class wt{constructor({numSplats:A,shDegree:t,fractionalBits:e=12,flagAntiAlias:s=!0}){this.clippedCount=0;const i=19+(t>=1?9:0)+(t>=2?15:0)+(t>=3?21:0),r=16+A*i;this.buffer=new ArrayBuffer(r),this.view=new DataView(this.buffer),this.view.setUint32(0,jg,!0),this.view.setUint32(4,$g,!0),this.view.setUint32(8,A,!0),this.view.setUint8(12,t),this.view.setUint8(13,e),this.view.setUint8(14,s?Ao:0),this.view.setUint8(15,0),this.numSplats=A,this.shDegree=t,this.fractionalBits=e,this.fraction=1<<e,this.flagAntiAlias=s}setCenter(A,t,e,s){const i=Math.round(t*this.fraction),r=Math.max(-8388607,Math.min(8388607,i)),a=Math.round(e*this.fraction),g=Math.max(-8388607,Math.min(8388607,a)),o=Math.round(s*this.fraction),I=Math.max(-8388607,Math.min(8388607,o));(i!==r||a!==g||o!==I)&&(this.clippedCount+=1);const h=16+A*9;this.view.setUint8(h,r&255),this.view.setUint8(h+1,r>>8&255),this.view.setUint8(h+2,r>>16&255),this.view.setUint8(h+3,g&255),this.view.setUint8(h+4,g>>8&255),this.view.setUint8(h+5,g>>16&255),this.view.setUint8(h+6,I&255),this.view.setUint8(h+7,I>>8&255),this.view.setUint8(h+8,I>>16&255)}setAlpha(A,t){const e=16+this.numSplats*9+A;this.view.setUint8(e,Math.max(0,Math.min(255,Math.round(t*255))))}static scaleRgb(A){const t=((A-.5)/(Er/.15)+.5)*255;return Math.max(0,Math.min(255,Math.round(t)))}setRgb(A,t,e,s){const i=16+this.numSplats*10+A*3;this.view.setUint8(i,wt.scaleRgb(t)),this.view.setUint8(i+1,wt.scaleRgb(e)),this.view.setUint8(i+2,wt.scaleRgb(s))}setScale(A,t,e,s){const i=16+this.numSplats*13+A*3;this.view.setUint8(i,Math.max(0,Math.min(255,Math.round((Math.log(t)+10)*16)))),this.view.setUint8(i+1,Math.max(0,Math.min(255,Math.round((Math.log(e)+10)*16)))),this.view.setUint8(i+2,Math.max(0,Math.min(255,Math.round((Math.log(s)+10)*16))))}setQuat(A,t,e,s,i){const r=16+this.numSplats*16+A*3,a=i<0;this.view.setUint8(r,Math.max(0,Math.min(255,Math.round(((a?-t:t)+1)*127.5)))),this.view.setUint8(r+1,Math.max(0,Math.min(255,Math.round(((a?-e:e)+1)*127.5)))),this.view.setUint8(r+2,Math.max(0,Math.min(255,Math.round(((a?-s:s)+1)*127.5))))}static quantizeSh(A,t){const e=Math.round(A*128)+128,s=1<<8-t,i=Math.floor((e+s/2)/s)*s;return Math.max(0,Math.min(255,i))}setSh(A,t,e,s){const i=Cr[this.shDegree]||0,r=16+this.numSplats*19+A*i*3;for(let a=0;a<9;++a)this.view.setUint8(r+a,wt.quantizeSh(t[a],5));if(e){const a=r+9;for(let g=0;g<15;++g)this.view.setUint8(a+g,wt.quantizeSh(e[g],4));if(s){const g=a+15;for(let o=0;o<21;++o)this.view.setUint8(g+o,wt.quantizeSh(s[o],4))}}}async finalize(){const A=new Uint8Array(this.buffer),e=new ReadableStream({async start(r){r.enqueue(A),r.close()}}).pipeThrough(new CompressionStream("gzip")),i=await new Response(e).arrayBuffer();return console.log("Compressed",A.length,"bytes to",i.byteLength,"bytes"),new Uint8Array(i)}}async function to(n){var I,B,Q;const A=new Xg,{inputs:t,clipXyz:e,maxSh:s,fractionalBits:i=12,opacityThreshold:r}=n;for(const h of t){let C=function(p){return p.multiplyScalar(d),p.applyQuaternion(y),p.add(w),p},E=function(p){return p.multiplyScalar(d),p},l=function(p){return p.premultiply(y),p},c=function(p){return!x||x.containsPoint(p)},u=function(p){return r!==void 0?p>=r:!0};const d=((I=h.transform)==null?void 0:I.scale)??1,y=new gA().fromArray(((B=h.transform)==null?void 0:B.quaternion)??[0,0,0,1]),w=new f().fromArray(((Q=h.transform)==null?void 0:Q.translate)??[0,0,0]),x=e?new vt(new f().fromArray(e.min),new f().fromArray(e.max)):void 0;let M=h.fileType;switch(M||(M=ar(h.fileBytes),!M&&h.pathOrUrl&&(M=gr(h.pathOrUrl))),M){case me.PLY:{const p=new De({fileBytes:h.fileBytes});await p.parseHeader();let D=null;p.parseSplats((F,m,S,N,k,G,R,L,W,_,j,X,$,q,z)=>{const b=C(new f(m,S,N));if(c(b)&&u(X)){D=A.pushSplat(),A.setCenter(D,b.x,b.y,b.z);const O=E(new f(k,G,R));A.setScale(D,O.x,O.y,O.z);const U=l(new gA(L,W,_,j));A.setQuaternion(D,U.x,U.y,U.z,U.w),A.setOpacity(D,X),A.setColor(D,$,q,z)}else D=null},(F,m,S,N)=>{m&&D!==null&&A.setSh1(D,m),S&&D!==null&&A.setSh2(D,S),N&&D!==null&&A.setSh3(D,N)});break}case me.SPZ:{const p=new hr({fileBytes:h.fileBytes}),D=new Int32Array(p.numSplats);D.fill(-1);const F=new Float32Array(p.numSplats*3),m=new f;p.parseSplats((S,N,k,G)=>{const R=C(new f(N,k,G));F[S*3]=R.x,F[S*3+1]=R.y,F[S*3+2]=R.z},(S,N)=>{m.fromArray(F,S*3),c(m)&&u(N)&&(D[S]=A.pushSplat(),A.setCenter(D[S],m.x,m.y,m.z),A.setOpacity(D[S],N))},(S,N,k,G)=>{D[S]>=0&&A.setColor(D[S],N,k,G)},(S,N,k,G)=>{if(D[S]>=0){const R=E(new f(N,k,G));A.setScale(D[S],R.x,R.y,R.z)}},(S,N,k,G,R)=>{if(D[S]>=0){const L=l(new gA(N,k,G,R));A.setQuaternion(D[S],L.x,L.y,L.z,L.w)}},(S,N,k,G)=>{D[S]>=0&&(A.setSh1(D[S],N),k&&A.setSh2(D[S],k),G&&A.setSh3(D[S],G))});break}case me.SPLAT:Tn(h.fileBytes,p=>{},(p,D,F,m,S,N,k,G,R,L,W,_,j,X,$)=>{const q=C(new f(D,F,m));if(c(q)&&u(_)){const z=A.pushSplat();A.setCenter(z,q.x,q.y,q.z);const b=E(new f(S,N,k));A.setScale(z,b.x,b.y,b.z);const O=l(new gA(G,R,L,W));A.setQuaternion(z,O.x,O.y,O.z,O.w),A.setOpacity(z,_),A.setColor(z,j,X,$)}});break;case me.KSPLAT:{let p=null;Xa(h.fileBytes,D=>{},(D,F,m,S,N,k,G,R,L,W,_,j,X,$,q)=>{const z=C(new f(F,m,S));if(c(z)&&u(j)){p=A.pushSplat(),A.setCenter(p,z.x,z.y,z.z);const b=E(new f(N,k,G));A.setScale(p,b.x,b.y,b.z);const O=l(new gA(R,L,W,_));A.setQuaternion(p,O.x,O.y,O.z,O.w),A.setOpacity(p,j),A.setColor(p,X,$,q)}else p=null},(D,F,m,S)=>{p!==null&&(A.setSh1(p,F),m&&A.setSh2(p,m),S&&A.setSh3(p,S))});break}default:throw new Error(`transcodeSpz not implemented for ${M}`)}}const a=Math.min(s??3,A.sh3?3:A.sh2?2:A.sh1?1:0),g=new wt({numSplats:A.numSplats,shDegree:a,fractionalBits:i,flagAntiAlias:!0});for(let h=0;h<A.numSplats;++h){const C=h*3,E=h*4;g.setCenter(h,A.centers[C],A.centers[C+1],A.centers[C+2]),g.setScale(h,A.scales[C],A.scales[C+1],A.scales[C+2]),g.setQuat(h,A.quaternions[E],A.quaternions[E+1],A.quaternions[E+2],A.quaternions[E+3]),g.setAlpha(h,A.opacities[h]),g.setRgb(h,A.colors[C],A.colors[C+1],A.colors[C+2]),A.sh1&&a>=1&&g.setSh(h,A.sh1.slice(h*9,(h+1)*9),a>=2&&A.sh2?A.sh2.slice(h*15,(h+1)*15):void 0,a>=3&&A.sh3?A.sh3.slice(h*21,(h+1)*21):void 0)}return{fileBytes:await g.finalize(),clippedCount:g.clippedCount}}async function cr(n){const{name:A,args:t,id:e}=n.data;let s,i;try{switch(A){case"unpackPly":{const{packedArray:r,fileBytes:a}=t,g=await eo({packedArray:r,fileBytes:a});s={id:e,numSplats:g.numSplats,packedArray:g.packedArray,extra:g.extra};break}case"decodeSpz":{const{fileBytes:r}=t,a=so(r);s={id:e,numSplats:a.numSplats,packedArray:a.packedArray,extra:a.extra};break}case"decodeAntiSplat":{const{fileBytes:r}=t,a=Wa(r);s={id:e,numSplats:a.numSplats,packedArray:a.packedArray};break}case"decodeKsplat":{const{fileBytes:r}=t,a=Va(r);s={id:e,numSplats:a.numSplats,packedArray:a.packedArray,extra:a.extra};break}case"decodePcSogs":{const{fileBytes:r,extraFiles:a}=t,g=JSON.parse(new TextDecoder().decode(r)),o=await Qr(g,a);s={id:e,numSplats:o.numSplats,packedArray:o.packedArray,extra:o.extra};break}case"decodePcSogsZip":{const{fileBytes:r}=t,a=await Vg(r);s={id:e,numSplats:a.numSplats,packedArray:a.packedArray,extra:a.extra};break}case"sortSplats":{const{maxSplats:r,totalSplats:a,readback:g,ordering:o}=t;s={id:e,readback:g,...io({totalSplats:a,readback:g,ordering:o})};break}case"sortDoubleSplats":{const{numSplats:r,readback:a,ordering:g}=t;s={id:e,readback:a,ordering:g},Fa&&(s={id:e,readback:a,ordering:g,activeSplats:fr(r,a,g)});break}case"transcodeSpz":{const r=t,a=await to(r);s={id:e,fileBytes:a,input:r};break}default:throw new Error(`Unknown name: ${A}`)}}catch(r){i=r}self.postMessage({id:e,result:s,error:i},{transfer:Un(s)})}async function eo({packedArray:n,fileBytes:A}){const t=new De({fileBytes:A});await t.parseHeader();const e=t.numSplats,s={};return t.parseSplats((i,r,a,g,o,I,B,Q,h,C,E,l,c,u,d)=>{we(n,i,r,a,g,o,I,B,Q,h,C,E,l,c,u,d)},(i,r,a,g)=>{r&&(s.sh1||(s.sh1=new Uint32Array(e*2)),Is(s.sh1,i,r)),a&&(s.sh2||(s.sh2=new Uint32Array(e*4)),Bs(s.sh2,i,a)),g&&(s.sh3||(s.sh3=new Uint32Array(e*4)),Qs(s.sh3,i,g))}),{packedArray:n,numSplats:e,extra:s}}function so(n){const A=new hr({fileBytes:n}),t=A.numSplats,e=gs(t),s=new Uint32Array(e*4),i={};return A.parseSplats((r,a,g,o)=>{Ln(s,r,a,g,o)},(r,a)=>{Ha(s,r,a)},(r,a,g,o)=>{Ja(s,r,a,g,o)},(r,a,g,o)=>{bn(s,r,a,g,o)},(r,a,g,o,I)=>{Yn(s,r,a,g,o,I)},(r,a,g,o)=>{a&&(i.sh1||(i.sh1=new Uint32Array(t*2)),Is(i.sh1,r,a)),g&&(i.sh2||(i.sh2=new Uint32Array(t*4)),Bs(i.sh2,r,g)),o&&(i.sh3||(i.sh3=new Uint32Array(t*4)),Qs(i.sh3,r,o))}),{packedArray:s,numSplats:t,extra:i}}const oe=31744,Me=oe+1;let nA=null;function io({totalSplats:n,readback:A,ordering:t}){nA||(nA=new Uint32Array(Me)),nA.fill(0);const e=A.map(g=>new Uint32Array(g.buffer)),s=e[0].length,i=Math.ceil(n/s);let r=0;for(let g=0;g<i;++g){const o=e[g],I=Math.min(o.length,n-r);for(let B=0;B<I;++B){const Q=o[B]&32767;Q<oe&&(nA[Q]+=1)}r+=I}let a=0;for(let g=0;g<Me;++g){const o=a+nA[g];nA[g]=a,a=o}r=0;for(let g=0;g<i;++g){const o=e[g],I=Math.min(o.length,n-r);for(let B=0;B<I;++B){const Q=o[B]&32767;Q<oe&&(t[nA[Q]]=r+B,nA[Q]+=1)}r+=I}if(nA[Me-1]!==a)throw new Error(`Expected ${a} active splats but got ${nA[Me-1]}`);return{activeSplats:a,ordering:t}}function go({numSplats:n,readback:A,ordering:t}){nA||(nA=new Uint32Array(Me)),nA.fill(0);for(let s=0;s<n;++s){const i=A[s];i<oe&&(nA[i]+=1)}let e=0;for(let s=oe-1;s>=0;--s){const i=e+nA[s];nA[s]=e,e=i}for(let s=0;s<n;++s){const i=A[s];i<oe&&(t[nA[i]]=s,nA[i]+=1)}if(nA[0]!==e)throw new Error(`Expected ${e} active splats but got ${nA[0]}`);return{activeSplats:e,ordering:t}}const Ei=[];function lr(n){Ei.push(n)}async function no(){self.addEventListener("message",lr),await Ds(),self.removeEventListener("message",lr),self.addEventListener("message",cr);for(const n of Ei)cr(n);Ei.length=0}no().catch(console.error)})();\n//# sourceMappingURL=worker-iaa6AliJ.js.map\n', os = typeof self < "u" && self.Blob && new Blob([Ur], { type: "text/javascript;charset=utf-8" });
function aC(t) {
  let A;
  try {
    if (A = os && (self.URL || self.webkitURL).createObjectURL(os), !A) throw "";
    const e = new Worker(A, {
      name: t == null ? void 0 : t.name
    });
    return e.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(A);
    }), e;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(Ur),
      {
        name: t == null ? void 0 : t.name
      }
    );
  } finally {
    A && (self.URL || self.webkitURL).revokeObjectURL(A);
  }
}
class rC {
  constructor() {
    this.messages = {}, this.messageIdNext = 0, this.worker = new aC(), this.worker.onmessage = (A) => this.onMessage(A);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const A = this.makeMessageId(), e = new Promise((s, i) => {
      this.messages[A] = { resolve: s, reject: i };
    });
    return { id: A, promise: e };
  }
  onMessage(A) {
    const { id: e, result: s, error: i } = A.data, n = this.messages[e];
    n && (delete this.messages[e], i ? n.reject(i) : n.resolve(s));
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(A, e) {
    const { id: s, promise: i } = this.makeMessagePromiseId();
    return this.worker.postMessage(
      { name: A, args: e, id: s },
      { transfer: Fi(e) }
    ), i;
  }
}
let Lr = 4, Be = 0;
const br = [], vr = [];
async function gC() {
  const t = br.shift();
  if (t)
    return t;
  if (Be < Lr) {
    const A = new rC();
    return Be += 1, A;
  }
  return new Promise((A) => {
    vr.push(A);
  });
}
function oC(t) {
  if (Be > Lr) {
    Be -= 1;
    return;
  }
  const A = vr.shift();
  if (A) {
    A(t);
    return;
  }
  br.push(t);
}
async function Qt(t) {
  const A = await gC();
  try {
    return await t(A);
  } finally {
    oC(A);
  }
}
class IC extends ag {
  constructor(A) {
    super(A), this.fileLoader = new rg(A);
  }
  load(A, e, s, i) {
    const n = this.manager.resolveURL(
      (this.path ?? "") + (A ?? "")
    ), a = new Headers(this.requestHeader), r = this.withCredentials ? "include" : "same-origin", g = new Request(n, { headers: a, credentials: r });
    let I = this.fileType;
    this.manager.itemStart(n), Is(g, s).then(async (Q) => {
      const o = [
        new ProgressEvent("progress", {
          lengthComputable: !0,
          loaded: Q.byteLength,
          total: Q.byteLength
        })
      ];
      function C() {
        if (s) {
          const h = o.every((d) => d.lengthComputable || d.loaded === 0 && d.total === 0), u = o.reduce((d, y) => d + y.loaded, 0), p = o.reduce((d, y) => d + y.total, 0);
          s(
            new ProgressEvent("progress", {
              lengthComputable: h,
              loaded: u,
              total: p
            })
          );
        }
      }
      const E = {}, l = [], c = As(Q);
      if (I === "pcsogs" && c === void 0)
        throw new Error("Invalid PC SOGS file");
      if (c !== void 0) {
        I = "pcsogs";
        for (const h of ["means", "scales", "quats", "sh0", "shN"]) {
          const u = c[h];
          if (u)
            for (const p of u.files) {
              const d = new URL(p, n).toString(), y = o.length;
              o.push(new ProgressEvent("progress")), this.manager.itemStart(d);
              const D = new Request(d, { headers: a, credentials: r }), S = Is(D, (m) => {
                o[y] = m, C();
              }).then((m) => {
                E[p] = m;
              }).catch((m) => {
                throw this.manager.itemError(d), m;
              }).finally(() => {
                this.manager.itemEnd(d);
              });
              l.push(S);
            }
        }
      }
      if (await Promise.all(l), e) {
        const h = await Tr({
          input: Q,
          extraFiles: E,
          fileType: I,
          pathOrUrl: n
        });
        this.packedSplats ? (this.packedSplats.initialize(h), e(this.packedSplats)) : e(new KA(h));
      }
    }).catch((Q) => {
      this.manager.itemError(n), i == null || i(Q);
    }).finally(() => {
      this.manager.itemEnd(n);
    });
  }
  async loadAsync(A, e) {
    return new Promise((s, i) => {
      this.load(
        A,
        (n) => {
          s(n);
        },
        e,
        i
      );
    });
  }
  parse(A) {
    return new ZA({ packedSplats: A });
  }
}
async function Is(t, A) {
  const e = await fetch(t);
  if (!e.ok)
    throw new Error(
      `${e.status} "${e.statusText}" fetching URL: ${t.url}`
    );
  if (!e.body)
    throw new Error(`Response body is null for URL: ${t.url}`);
  const s = e.body.getReader(), i = Number.parseInt(
    e.headers.get("Content-Length") || "0"
  ), n = Number.isNaN(i) ? 0 : i;
  let a = 0;
  const r = [];
  for (; ; ) {
    const { done: Q, value: o } = await s.read();
    if (Q)
      break;
    r.push(o), a += o.length, A && A(
      new ProgressEvent("progress", {
        lengthComputable: n !== 0,
        loaded: a,
        total: n
      })
    );
  }
  const g = new Uint8Array(a);
  let I = 0;
  for (const Q of r)
    g.set(Q, I), I += Q.length;
  return g.buffer;
}
var vt = /* @__PURE__ */ ((t) => (t.PLY = "ply", t.SPZ = "spz", t.SPLAT = "splat", t.KSPLAT = "ksplat", t.PCSOGS = "pcsogs", t.PCSOGSZIP = "pcsogszip", t))(vt || {});
function Yr(t) {
  const A = new DataView(t.buffer);
  if ((A.getUint32(0, !0) & 16777215) === 7957616)
    return "ply";
  if ((A.getUint32(0, !0) & 16777215) === 559903) {
    const e = Yi(t, 4);
    return new DataView(e.buffer).getUint32(0, !0) === 1347635022 ? "spz" : void 0;
  }
  if (A.getUint32(0, !0) === 67324752)
    return BC(t) ? "pcsogszip" : void 0;
}
function QC(t) {
  const A = t.split(/[?#]/, 1)[0], e = Math.max(
    A.lastIndexOf("/"),
    A.lastIndexOf("\\")
  ), s = A.slice(e + 1), i = s.lastIndexOf(".");
  return i <= 0 || i === s.length - 1 ? "" : s.slice(i + 1).toLowerCase();
}
function Jr(t) {
  const A = QC(t);
  if (A === "ply")
    return "ply";
  if (A === "spz")
    return "spz";
  if (A === "splat")
    return "splat";
  if (A === "ksplat")
    return "ksplat";
}
function CE(t) {
  return As(t) !== void 0;
}
function As(t) {
  try {
    let A;
    if (typeof t == "string")
      A = t;
    else {
      const s = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
      if (s.length > 65536)
        return;
      A = new TextDecoder().decode(s);
    }
    const e = JSON.parse(A);
    if (!e || typeof e != "object" || Array.isArray(e))
      return;
    for (const s of ["means", "scales", "quats", "sh0"])
      if (!e[s] || typeof e[s] != "object" || Array.isArray(e[s]) || !e[s].shape || !e[s].files || s !== "quats" && (!e[s].mins || !e[s].maxs))
        return;
    return e;
  } catch {
    return;
  }
}
function BC(t) {
  try {
    const A = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
    let e = null;
    const s = mg(A, {
      filter: ({ name: n }) => n.split(/[\\/]/).pop() === "meta.json" ? (e = n, !0) : !1
    });
    if (!e)
      return;
    const i = As(s[e]);
    return i ? { name: e, json: i } : void 0;
  } catch {
    return;
  }
}
async function Tr({
  input: t,
  extraFiles: A,
  fileType: e,
  pathOrUrl: s
}) {
  const i = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
  let n = e;
  switch (e || (n = Yr(i), !n && s && (n = Jr(s))), n) {
    case "ply": {
      const a = new Qe({ fileBytes: i });
      await a.parseHeader();
      const r = a.numSplats, g = mA(r).maxSplats, I = { fileBytes: i, packedArray: new Uint32Array(g * 4) };
      return await Qt(async (Q) => {
        const { packedArray: o, numSplats: C, extra: E } = await Q.call(
          "unpackPly",
          I
        );
        return { packedArray: o, numSplats: C, extra: E };
      });
    }
    case "spz":
      return await Qt(async (a) => {
        const { packedArray: r, numSplats: g, extra: I } = await a.call(
          "decodeSpz",
          {
            fileBytes: i
          }
        );
        return { packedArray: r, numSplats: g, extra: I };
      });
    case "splat":
      return await Qt(async (a) => {
        const { packedArray: r, numSplats: g } = await a.call(
          "decodeAntiSplat",
          {
            fileBytes: i
          }
        );
        return { packedArray: r, numSplats: g };
      });
    case "ksplat":
      return await Qt(async (a) => {
        const { packedArray: r, numSplats: g, extra: I } = await a.call(
          "decodeKsplat",
          { fileBytes: i }
        );
        return { packedArray: r, numSplats: g, extra: I };
      });
    case "pcsogs":
      return await Qt(async (a) => {
        const { packedArray: r, numSplats: g, extra: I } = await a.call(
          "decodePcSogs",
          { fileBytes: i, extraFiles: A }
        );
        return { packedArray: r, numSplats: g, extra: I };
      });
    case "pcsogszip":
      return await Qt(async (a) => {
        const { packedArray: r, numSplats: g, extra: I } = await a.call(
          "decodePcSogsZip",
          { fileBytes: i }
        );
        return { packedArray: r, numSplats: g, extra: I };
      });
    default:
      throw new Error(`Unknown splat file type: ${n}`);
  }
}
class CC {
  constructor({ maxSplats: A = 1 } = {}) {
    this.numSplats = 0, this.maxSplats = mA(A).maxSplats, this.centers = new Float32Array(this.maxSplats * 3), this.scales = new Float32Array(this.maxSplats * 3), this.quaternions = new Float32Array(this.maxSplats * 4), this.opacities = new Float32Array(this.maxSplats), this.colors = new Float32Array(this.maxSplats * 3);
  }
  pushSplat() {
    const A = this.numSplats;
    return this.ensureIndex(A), this.numSplats += 1, A;
  }
  unpushSplat(A) {
    if (A === this.numSplats - 1)
      this.numSplats -= 1;
    else
      throw new Error("Cannot unpush splat from non-last position");
  }
  ensureCapacity(A) {
    if (A > this.maxSplats) {
      const e = Math.max(A, this.maxSplats * 2), s = new Float32Array(e * 3), i = new Float32Array(e * 3), n = new Float32Array(e * 4), a = new Float32Array(e), r = new Float32Array(e * 3);
      if (s.set(this.centers), i.set(this.scales), n.set(this.quaternions), a.set(this.opacities), r.set(this.colors), this.centers = s, this.scales = i, this.quaternions = n, this.opacities = a, this.colors = r, this.sh1) {
        const g = new Float32Array(e * 9);
        g.set(this.sh1), this.sh1 = g;
      }
      if (this.sh2) {
        const g = new Float32Array(e * 15);
        g.set(this.sh2), this.sh2 = g;
      }
      if (this.sh3) {
        const g = new Float32Array(e * 21);
        g.set(this.sh3), this.sh3 = g;
      }
      this.maxSplats = e;
    }
  }
  ensureIndex(A) {
    this.ensureCapacity(A + 1);
  }
  setCenter(A, e, s, i) {
    this.centers[A * 3] = e, this.centers[A * 3 + 1] = s, this.centers[A * 3 + 2] = i;
  }
  setScale(A, e, s, i) {
    this.scales[A * 3] = e, this.scales[A * 3 + 1] = s, this.scales[A * 3 + 2] = i;
  }
  setQuaternion(A, e, s, i, n) {
    this.quaternions[A * 4] = e, this.quaternions[A * 4 + 1] = s, this.quaternions[A * 4 + 2] = i, this.quaternions[A * 4 + 3] = n;
  }
  setOpacity(A, e) {
    this.opacities[A] = e;
  }
  setColor(A, e, s, i) {
    this.colors[A * 3] = e, this.colors[A * 3 + 1] = s, this.colors[A * 3 + 2] = i;
  }
  setSh1(A, e) {
    this.sh1 || (this.sh1 = new Float32Array(this.maxSplats * 9));
    for (let s = 0; s < 9; ++s)
      this.sh1[A * 9 + s] = e[s];
  }
  setSh2(A, e) {
    this.sh2 || (this.sh2 = new Float32Array(this.maxSplats * 15));
    for (let s = 0; s < 15; ++s)
      this.sh2[A * 15 + s] = e[s];
  }
  setSh3(A, e) {
    this.sh3 || (this.sh3 = new Float32Array(this.maxSplats * 21));
    for (let s = 0; s < 21; ++s)
      this.sh3[A * 21 + s] = e[s];
  }
}
var EC = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;
const eA = class eA {
  constructor(A = {}) {
    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new ts({ packedSplats: this }), this.initialized = Promise.resolve(this), this.reinitialize(A);
  }
  reinitialize(A) {
    this.isInitialized = !1, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));
  }
  initialize(A) {
    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / W) * W, this.numSplats = Math.min(
      this.maxSplats,
      A.numSplats ?? Number.POSITIVE_INFINITY
    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};
  }
  async asyncInitialize(A) {
    const { url: e, fileBytes: s, construct: i } = A;
    if (e) {
      const n = new IC();
      n.packedSplats = this, await n.loadAsync(e);
    } else if (s) {
      const n = await Tr({
        input: s,
        fileType: A.fileType,
        pathOrUrl: A.fileName ?? e
      });
      this.initialize(n);
    }
    if (i) {
      const n = i(this);
      n instanceof Promise && await n;
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(A) {
    const e = A <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(A, 2 * this.maxSplats)
    ), s = this.packedArray ? this.packedArray.length / 4 : 0;
    if (!this.packedArray || e > s) {
      this.maxSplats = mA(e).maxSplats;
      const i = new Uint32Array(this.maxSplats * 4);
      this.packedArray && i.set(this.packedArray), this.packedArray = i;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(A, e) {
    let s, i;
    if (A === 0)
      return this.ensureSplats(e);
    if (A === 1)
      s = 2, i = "sh1";
    else if (A === 2)
      s = 4, i = "sh2";
    else if (A === 3)
      s = 4, i = "sh3";
    else
      throw new Error(`Invalid level: ${A}`);
    let n = this.extra[i] ? this.extra[i].length / s : 0;
    const a = e <= n ? n : Math.max(e, 2 * n);
    if (!this.extra[i] || a > n) {
      n = mA(a).maxSplats;
      const r = new Uint32Array(n * s);
      this.extra[i] && r.set(this.extra[i]), this.extra[i] = r;
    }
    return this.extra[i];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(A) {
    if (!this.packedArray || A >= this.numSplats)
      throw new Error("Invalid index");
    return Le(this.packedArray, A);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(A, e, s, i, n, a) {
    const r = this.ensureSplats(A + 1);
    Ue(
      r,
      A,
      e.x,
      e.y,
      e.z,
      s.x,
      s.y,
      s.z,
      i.x,
      i.y,
      i.z,
      i.w,
      n,
      a.r,
      a.g,
      a.b
    ), this.numSplats = Math.max(this.numSplats, A + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(A, e, s, i, n) {
    const a = this.ensureSplats(this.numSplats + 1);
    Ue(
      a,
      this.numSplats,
      A.x,
      A.y,
      A.z,
      e.x,
      e.y,
      e.z,
      s.x,
      s.y,
      s.z,
      s.w,
      i,
      n.r,
      n.g,
      n.b
    ), ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(A) {
    if (!(!this.packedArray || !this.numSplats))
      for (let e = 0; e < this.numSplats; ++e) {
        const s = Le(this.packedArray, e);
        A(
          e,
          s.center,
          s.scales,
          s.quaternion,
          s.opacity,
          s.color
        );
      }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(A) {
    if (this.target && (A ?? 1) <= this.maxSplats)
      return !1;
    this.dispose();
    const e = mA(A ?? 1), { width: s, height: i, depth: n } = e;
    return this.maxSplats = e.maxSplats, this.target = new B.WebGLArrayRenderTarget(s, i, n, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: B.NearestFilter,
      minFilter: B.NearestFilter
    }), this.target.texture.format = B.RGBAIntegerFormat, this.target.texture.type = B.UnsignedIntType, this.target.texture.internalFormat = "RGBA32UI", this.target.scissorTest = !0, !0;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(A) {
    let e = 0;
    const s = A.map((i) => {
      const n = e, a = Math.ceil(i / W) * W;
      return e += a, { base: n, count: i };
    });
    return { maxSplats: e, mapping: s };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : eA.getEmpty();
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray)
      throw new Error("No packed splats");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: e, depth: s } = this.source.image;
        this.maxSplats !== A * e * s && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));
      else {
        const { width: A, height: e, depth: s } = mA(this.maxSplats);
        this.source = new B.DataArrayTexture(
          this.packedArray,
          A,
          e,
          s
        ), this.source.format = B.RGBAIntegerFormat, this.source.type = B.UnsignedIntType, this.source.internalFormat = "RGBA32UI", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!eA.emptySource) {
      const { width: A, height: e, depth: s, maxSplats: i } = mA(1), n = new Uint32Array(i * 4);
      eA.emptySource = new B.DataArrayTexture(
        n,
        A,
        e,
        s
      ), eA.emptySource.format = B.RGBAIntegerFormat, eA.emptySource.type = B.UnsignedIntType, eA.emptySource.internalFormat = "RGBA32UI", eA.emptySource.needsUpdate = !0;
    }
    return eA.emptySource;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let e = eA.generatorProgram.get(A);
    if (!e) {
      const i = kA(
        { index: "int" },
        { output: "uvec4" },
        ({ index: n }) => {
          A.inputs.index = n;
          const a = A.outputs.gsplat;
          return { output: zs(a) };
        }
      );
      eA.programTemplate || (eA.programTemplate = new Xe(
        EC
      )), e = new Ze({
        graph: i,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: eA.programTemplate
      }), Object.assign(e.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), eA.generatorProgram.set(A, e);
    }
    const s = e.prepareMaterial();
    return eA.mesh.material = s, { program: e, material: s };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, e) {
    A.setRenderTarget(null), A.xr.enabled = e.xrEnabled, A.autoClear = e.autoClear;
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator: A,
    base: e,
    count: s,
    renderer: i
  }) {
    if (!this.target)
      throw new Error("Target must be initialized with ensureSplats");
    if (e + s > this.maxSplats)
      throw new Error("Base + count exceeds maxSplats");
    const { program: n, material: a } = this.prepareProgramMaterial(A);
    n.update();
    const r = this.saveRenderState(i), g = Math.ceil((e + s) / W) * W, I = W * it;
    for (a.uniforms.targetBase.value = e, a.uniforms.targetCount.value = s; e < g; ) {
      const Q = Math.floor(e / I);
      a.uniforms.targetLayer.value = Q;
      const o = Q * I, C = Math.floor((e - o) / W), E = Math.min(
        it,
        Math.ceil((g - o) / W)
      );
      this.target.scissor.set(
        0,
        C,
        W,
        E - C
      ), i.setRenderTarget(this.target, Q), i.xr.enabled = !1, i.autoClear = !1, i.render(eA.scene, eA.camera), e += W * (E - C);
    }
    return this.resetRenderState(i, r), { nextBase: g };
  }
};
eA.emptySource = null, eA.programTemplate = null, eA.generatorProgram = /* @__PURE__ */ new Map(), eA.geometry = new B.PlaneGeometry(2, 2), eA.mesh = new B.Mesh(
  eA.geometry,
  new B.RawShaderMaterial({ visible: !1 })
), eA.scene = new B.Scene().add(eA.mesh), eA.camera = new B.Camera();
let KA = eA;
class ts extends G {
  constructor({ packedSplats: A } = {}) {
    super({
      key: "packedSplats",
      type: Pt,
      globals: () => [he],
      value: {
        texture: KA.getEmpty(),
        numSplats: 0
      },
      update: (e) => {
        var s, i;
        return e.texture = ((s = this.packedSplats) == null ? void 0 : s.getTexture()) ?? KA.getEmpty(), e.numSplats = ((i = this.packedSplats) == null ? void 0 : i.numSplats) ?? 0, e;
      }
    }), this.packedSplats = A;
  }
}
class Te extends B.InstancedBufferGeometry {
  constructor(A, e) {
    super(), this.ordering = A, this.setAttribute("position", new B.BufferAttribute(cC, 3)), this.setIndex(new B.BufferAttribute(hC, 1)), this._maxInstanceCount = A.length, this.instanceCount = e, this.attribute = new B.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(B.DynamicDrawUsage), this.setAttribute("splatIndex", this.attribute);
  }
  update(A, e) {
    this.ordering = A, this.attribute.array = A, this.instanceCount = e, this.attribute.addUpdateRange(0, e), this.attribute.needsUpdate = !0;
  }
}
const cC = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]), hC = new Uint16Array([0, 1, 2, 0, 2, 3]), st = class st {
  constructor(A) {
    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback = new Uint16Array(0), this.spark = A.spark, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new B.Matrix4(), A.target) {
      const { width: e, height: s, doubleBuffer: i } = A.target, n = Math.max(1, Math.min(4, A.target.superXY ?? 1));
      if (this.superXY = n, e * n > 8192 || s * n > 8192)
        throw new Error("Target size too large");
      this.target = new B.WebGLRenderTarget(
        e * n,
        s * n,
        {
          format: B.RGBAFormat,
          type: B.UnsignedByteType,
          colorSpace: B.SRGBColorSpace
        }
      ), i && (this.back = new B.WebGLRenderTarget(
        e * n,
        s * n,
        {
          format: B.RGBAFormat,
          type: B.UnsignedByteType,
          colorSpace: B.SRGBColorSpace
        }
      )), this.encodeLinear = !0;
    }
    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.orderingFreelist = new Ni({
      allocate: (e) => new Uint32Array(e),
      valid: (e, s) => e.length === s
    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);
  }
  // Call this when you are done with the SparkViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var A;
    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.spark.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.spark.releaseAccumulator(this.pending.accumulator), this.pending = null);
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached SparkRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(A) {
    !this.autoUpdate && A ? this.spark.autoViewpoints.push(this) : this.autoUpdate && !A && (this.spark.autoViewpoints = this.spark.autoViewpoints.filter(
      (e) => e !== this
    )), this.autoUpdate = A;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene: A,
    camera: e,
    viewToWorld: s,
    update: i,
    forceOrigin: n
  }) {
    var r;
    for (s ? this.viewToWorld = s : (this.camera = e ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); i ?? !0; ) {
      const g = n ? this.viewToWorld : void 0;
      if (this.spark.updateInternal({ scene: A, originToWorld: g }))
        break;
      await new Promise((Q) => setTimeout(Q, 10));
    }
    const a = this.spark.active;
    a !== ((r = this.display) == null ? void 0 : r.accumulator) && (this.spark.active.refCount += 1), await this.sortUpdate({ accumulator: a, viewToWorld: this.viewToWorld });
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene: A,
    camera: e
  }) {
    var i;
    const s = this.back ?? this.target;
    if (!s)
      throw new Error("Must initialize SparkViewpoint with target");
    if (e = e ?? this.camera, !e)
      throw new Error("Must provide camera");
    if (e instanceof B.PerspectiveCamera) {
      const n = new B.PerspectiveCamera().copy(e, !1);
      n.aspect = s.width / s.height, n.updateProjectionMatrix(), e = n;
    }
    this.viewToWorld = e.matrixWorld.clone();
    try {
      this.spark.renderer.setRenderTarget(s), this.spark.prepareViewpoint(this), this.spark.renderer.render(A, e);
    } finally {
      this.spark.prepareViewpoint(this.spark.defaultView), this.spark.renderer.setRenderTarget(null);
    }
    s !== this.target && ([this.target, this.back] = [this.back, this.target]), (i = this.onTextureUpdated) == null || i.call(this, s.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target)
      throw new Error("Must initialize SparkViewpoint with target");
    const { width: A, height: e } = this.target, s = A * e * 4;
    (!this.superPixels || this.superPixels.length < s) && (this.superPixels = new Uint8Array(s)), await this.spark.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      A,
      e,
      this.superPixels
    );
    const { superXY: i } = this;
    if (i === 1)
      return this.superPixels;
    const n = A / i, a = e / i, r = n * a * 4;
    (!this.pixels || this.pixels.length < r) && (this.pixels = new Uint8Array(r));
    const { superPixels: g, pixels: I } = this, Q = i * i;
    for (let o = 0; o < a; o++) {
      const C = o * n;
      for (let E = 0; E < n; E++) {
        const l = E * i;
        let c = 0, h = 0, u = 0, p = 0;
        for (let y = 0; y < i; y++) {
          const D = (o * i + y) * this.target.width;
          for (let S = 0; S < i; S++) {
            const m = (D + l + S) * 4;
            c += g[m], h += g[m + 1], u += g[m + 2], p += g[m + 3];
          }
        }
        const d = (C + E) * 4;
        I[d] = c / Q, I[d + 1] = h / Q, I[d + 2] = u / Q, I[d + 3] = p / Q;
      }
    }
    return I;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its SparkRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene: A,
    camera: e,
    viewToWorld: s,
    update: i,
    forceOrigin: n
  }) {
    return await this.prepare({ scene: A, camera: e, viewToWorld: s, update: i, forceOrigin: n }), this.renderTarget({ scene: A, camera: e }), this.readTarget();
  }
  // This is called automatically by SparkRenderer, there is no need to call it!
  // The method cannot be private because then SparkRenderer would
  // not be able to call it.
  autoPoll({ accumulator: A }) {
    var n, a, r, g;
    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());
    let e = !1, s = !1;
    if (!this.display)
      e = !0;
    else if (A) {
      e = !0;
      const { mappingVersion: I } = this.display.accumulator;
      A.mappingVersion === I && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A, s = !0);
    }
    const i = ((n = this.sorting) == null ? void 0 : n.viewToWorld) ?? ((a = this.display) == null ? void 0 : a.viewToWorld);
    i && !ge({
      matrix1: this.viewToWorld,
      matrix2: i,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    }) && (e = !0), e && (A && (A.refCount += 1), A && ((r = this.pending) != null && r.accumulator) && this.pending.accumulator !== ((g = this.display) == null ? void 0 : g.accumulator) && this.spark.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld, displayed: s }, this.driveSort());
  }
  async driveSort() {
    var A;
    for (; ; ) {
      if (this.sorting || !this.pending)
        return;
      const { viewToWorld: e, displayed: s } = this.pending;
      let i = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);
      if (i || (i = this.spark.active, i.refCount += 1), this.pending = null, !i)
        throw new Error("No accumulator to sort");
      this.sorting = { viewToWorld: e }, await this.sortUpdate({ accumulator: i, viewToWorld: e, displayed: s }), this.sorting = null;
    }
  }
  async sortUpdate({
    accumulator: A,
    viewToWorld: e,
    displayed: s = !1
  }) {
    if (this.sortingCheck)
      throw new Error("Only one sort at a time");
    this.sortingCheck = !0, A = A ?? this.spark.active;
    const { numSplats: i, maxSplats: n } = A.splats;
    let a = 0, r = this.orderingFreelist.alloc(n);
    if (i > 0) {
      const {
        reader: g,
        doubleSortReader: I,
        dynoSortRadial: Q,
        dynoOrigin: o,
        dynoDirection: C,
        dynoDepthBias: E,
        dynoSort360: l,
        dynoSplats: c
      } = st.makeSorter(), h = Math.ceil(n / 2);
      this.readback = g.ensureBuffer(h, this.readback);
      const u = A.toWorld.clone().invert(), p = e.clone().premultiply(u);
      Q.value = this.sort360 ? !0 : this.sortRadial, o.value.set(0, 0, 0).applyMatrix4(p), C.value.set(0, 0, -1).applyMatrix4(p).sub(o.value).normalize(), E.value = this.depthBias ?? 1, l.value = this.sort360 ?? !1, c.packedSplats = A.splats, await g.renderReadback({
        renderer: this.spark.renderer,
        reader: I,
        count: Math.ceil(i / 2),
        readback: this.readback
      });
      const d = await Qt(async (y) => y.call("sortDoubleSplats", {
        numSplats: i,
        readback: this.readback,
        ordering: r
      }));
      this.readback = d.readback, r = d.ordering, a = d.activeSplats;
    }
    this.updateDisplay({
      accumulator: A,
      viewToWorld: e,
      ordering: r,
      activeSplats: a,
      displayed: s
    }), this.sortingCheck = !1;
  }
  updateDisplay({
    accumulator: A,
    viewToWorld: e,
    ordering: s,
    activeSplats: i,
    displayed: n = !1
  }) {
    if (!this.display)
      this.display = {
        accumulator: A,
        viewToWorld: e,
        geometry: new Te(s, i)
      };
    else {
      !n && A !== this.display.accumulator && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = e;
      const a = this.display.geometry.ordering;
      a.length === s.length ? this.display.geometry.update(s, i) : (this.display.geometry.dispose(), this.display.geometry = new Te(s, i)), this.orderingFreelist.free(a);
    }
    this.spark.viewpoint === this && this.spark.prepareViewpoint(this);
  }
  static makeSorter() {
    if (!st.dynos) {
      const A = new re({ value: !0 }), e = new Mt({ value: new B.Vector3() }), s = new Mt({ value: new B.Vector3() }), i = new Ct({ value: 1 }), n = new re({ value: !1 }), a = new ts(), r = new oe(), g = kA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: I }) => {
          if (!I)
            throw new Error("No index");
          const Q = {
            sortRadial: A,
            sortOrigin: e,
            sortDirection: s,
            sortDepthBias: i,
            sort360: n
          }, o = BA(I, q("int", 2)), C = Ht(a, o), E = Qs({ gsplat: C, ...Q }), l = Ht(
            a,
            fA(o, q("int", 1))
          ), c = Qs({ gsplat: l, ...Q }), h = qA({
            vectorType: "vec2",
            x: E,
            y: c
          });
          return { rgba8: zn(Kn(h)) };
        }
      );
      st.dynos = {
        dynoSortRadial: A,
        dynoOrigin: e,
        dynoDirection: s,
        dynoDepthBias: i,
        dynoSort360: n,
        dynoSplats: a,
        reader: r,
        doubleSortReader: g
      };
    }
    return st.dynos;
  }
};
st.EMPTY_TEXTURE = new B.Texture(), st.dynos = null;
let Ce = st;
const lC = EA(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function Qs({
  gsplat: t,
  sortRadial: A,
  sortOrigin: e,
  sortDirection: s,
  sortDepthBias: i,
  sort360: n
}) {
  return Vt({
    inTypes: {
      gsplat: j,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [FA, lC],
    inputs: {
      gsplat: t,
      sortRadial: A,
      sortOrigin: e,
      sortDirection: s,
      sortDepthBias: i,
      sort360: n
    },
    statements: ({ inputs: a, outputs: r }) => {
      const {
        gsplat: g,
        sortRadial: I,
        sortOrigin: Q,
        sortDirection: o,
        sortDepthBias: C,
        sort360: E
      } = a;
      return UA(`
        ${r.metric} = computeSort(${g}, ${I}, ${Q}, ${o}, ${C}, ${E});
      `);
    }
  }).outputs.metric;
}
class Fe {
  constructor() {
    this.splats = new KA(), this.toWorld = new B.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;
  }
  ensureGenerate(A) {
    this.splats.ensureGenerate(A) && (this.mapping = []);
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer: A,
    modifier: e,
    generators: s,
    forceUpdate: i,
    originToWorld: n
  }) {
    const a = this.mapping.reduce((I, Q) => (I.set(Q.node, Q), I), /* @__PURE__ */ new Map());
    let r = 0, g = 0;
    for (const { node: I, generator: Q, version: o, base: C, count: E } of s) {
      const l = a.get(I);
      if ((i || Q !== (l == null ? void 0 : l.generator) || o !== (l == null ? void 0 : l.version) || C !== (l == null ? void 0 : l.base) || E !== (l == null ? void 0 : l.count)) && Q && E > 0) {
        const c = e.apply(Q);
        try {
          this.splats.generate({
            generator: c,
            base: C,
            count: E,
            renderer: A
          });
        } catch (h) {
          I.generator = void 0, I.generatorError = h;
        }
        r += 1;
      }
      g = Math.max(g, C + E);
    }
    return this.splats.numSplats = g, this.toWorld = n, this.mapping = s, r !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(A) {
    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: e, base: s, count: i }, n) => {
      const {
        node: a,
        base: r,
        count: g
      } = A.mapping[n];
      return e === a && s === r && i === g;
    });
  }
}
var uC = `const float LN_SCALE_MIN = -12.0;
const float LN_SCALE_MAX = 9.0;
const float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; 

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

const float MAX_PIXEL_RADIUS = 512.0;
const float MIN_ALPHA = 0.5 * (1.0 / 255.0); 
const float MAX_STDDEV = sqrt(8.0);

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    rgba = vec4(uRgba) / 255.0;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),
        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),
        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`, dC = `precision highp float;
precision highp int;

#include <splatDefines>

uniform float near;
uniform float far;
uniform bool encodeLinear;
uniform float maxStdDev;
uniform bool disableFalloff;
uniform float falloff;

uniform bool splatTexEnable;
uniform sampler3D splatTexture;
uniform mat2 splatTexMul;
uniform vec2 splatTexAdd;
uniform float splatTexNear;
uniform float splatTexFar;
uniform float splatTexMid;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;

void main() {
    vec4 rgba = vRgba;

    float z = dot(vSplatUv, vSplatUv);
    if (!splatTexEnable) {
        if (z > (maxStdDev * maxStdDev)) {
            discard;
        }
    } else {
        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;
        float ndcZ = vNdc.z;
        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));
        float clampedFar = max(splatTexFar, splatTexNear);
        float clampedDepth = clamp(depth, splatTexNear, clampedFar);
        float logDepth = log2(clampedDepth + 1.0);
        float logNear = log2(splatTexNear + 1.0);
        float logFar = log2(clampedFar + 1.0);

        float texZ;
        if (splatTexMid > 0.0) {
            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);
            float logMid = log2(clampedMid + 1.0);
            texZ = (clampedDepth <= clampedMid) ?
                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :
                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);
        } else {
            texZ = (logDepth - logNear) / (logFar - logNear);
        }

        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));
        rgba *= modulate;
    }

    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);

    if (rgba.a < MIN_ALPHA) {
        discard;
    }
    if (encodeLinear) {
        rgba.rgb = srgbToLinear(rgba.rgb);
    }
    fragColor = rgba;
}`, pC = `precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float focalDistance;
uniform float apertureAngle;
uniform float clipXY;
uniform float focalAdjustment;

uniform usampler2DArray packedSplats;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }
    if (splatIndex == 0xffffffffu) {
        
        return;
    }

    ivec3 texCoord = ivec3(
        splatIndex & SPLAT_TEX_WIDTH_MASK,
        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
        splatIndex >> SPLAT_TEX_LAYER_BITS
    );
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplat(packed, center, scales, quaternion, rgba);

    if (rgba.a < MIN_ALPHA) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 scaledRenderSize = renderSize * focalAdjustment;
    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);
    float invZ = 1.0 / viewCenter.z;
    vec2 J1 = focal * invZ;
    vec2 J2 = -(J1 * viewCenter.xy) * invZ;
    mat3 J = mat3(
        J1.x, 0.0, J2.x,
        0.0, J1.y, J2.y,
        0.0, 0.0, 0.0
    );

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    float fullBlurAmount = blurAmount;
    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {
        float focusRadius = MAX_PIXEL_RADIUS;
        if (viewCenter.z < 0.0) {
            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);
            float apertureRadius = focal.x * tan(0.5 * apertureAngle);
            focusRadius = focusBlur * apertureRadius;
        }
        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(MAX_PIXEL_RADIUS));
    }

    
    float detOrig = a * d - b * b;
    a += fullBlurAmount;
    d += fullBlurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < MIN_ALPHA) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;
let Ne = null;
function yC() {
  return Ne || (B.ShaderChunk.splatDefines = uC, Ne = {
    splatVertex: pC,
    splatFragment: dC
  }), Ne;
}
const Bs = 5;
let He = !1, qe = !1, Hr;
function wC(t) {
  let A = !1;
  return t instanceof ZA ? !0 : (t.traverse((e) => {
    A = A || e instanceof ZA;
  }), A);
}
const qr = B.Scene.prototype.add;
B.Scene.prototype.add = function(t) {
  return He = He || wC(t), qe = qe || t instanceof Ee, qr.call(this, t), this;
};
const DC = B.Scene.prototype.onBeforeRender;
B.Scene.prototype.onBeforeRender = function(t) {
  if (He) {
    if (!qe) {
      const A = Hr || new Ee({ renderer: t });
      this.add(A);
    }
    B.Scene.prototype.onBeforeRender = DC, B.Scene.prototype.add = qr;
  }
};
const rA = class rA extends B.Mesh {
  constructor(A) {
    const e = rA.makeUniforms(), s = yC(), i = new B.ShaderMaterial({
      glslVersion: B.GLSL3,
      vertexShader: s.splatVertex,
      fragmentShader: s.splatFragment,
      uniforms: e,
      transparent: !0,
      blending: B.NormalBlending,
      depthTest: !0,
      depthWrite: !1,
      side: B.DoubleSide
    });
    super(Cs, i), this.splatTexture = null, this.autoViewpoints = [], this.rotateToAccumulator = new Zt({ value: new B.Quaternion() }), this.translateToAccumulator = new Mt({ value: new B.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.pendingUpdate = null, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = i, this.uniforms = e;
    const n = kA(
      { gsplat: j },
      { gsplat: j },
      ({ gsplat: a }) => {
        if (!a)
          throw new Error("gsplat not defined");
        return a = Oe(a, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        }), { gsplat: a };
      }
    );
    this.modifier = new WB(n), this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.enable2DGS = A.enable2DGS ?? !1, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.focalDistance = A.focalDistance ?? 0, this.apertureAngle = A.apertureAngle ?? 0, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.focalAdjustment = A.focalAdjustment ?? 1, this.active = new Fe(), this.accumulatorCount = 1, this.freeAccumulators = [];
    for (let a = 0; a < 1; ++a)
      this.freeAccumulators.push(new Fe()), this.accumulatorCount += 1;
    this.defaultView = new Ce({
      ...A.view,
      autoUpdate: !0,
      spark: this
    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? ki(A.clock) : new B.Clock(), Hr = this;
  }
  static makeUniforms() {
    return {
      // Size of render viewport in pixels
      renderSize: { value: new B.Vector2() },
      // Near and far plane distances
      near: { value: 0.1 },
      far: { value: 1e3 },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new B.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new B.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: !1 },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Depth-of-field distance to focal plane
      focalDistance: { value: 0 },
      // Full-width angle of aperture opening (in radians)
      apertureAngle: { value: 0 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Debug renderSize scale factor
      focalAdjustment: { value: 1 },
      // Enable splat texture rendering
      splatTexEnable: { value: !1 },
      // Splat texture to render
      splatTexture: { type: "t", value: rA.EMPTY_SPLAT_TEXTURE },
      // Splat texture UV transform (multiply)
      splatTexMul: { value: new B.Matrix2() },
      // Splat texture UV transform (add)
      splatTexAdd: { value: new B.Vector2() },
      // Splat texture near plane distance
      splatTexNear: { value: 0.1 },
      // Splat texture far plane distance
      splatTexFar: { value: 1e3 },
      // Splat texture mid plane distance, or 0.0 to disable
      splatTexMid: { value: 0 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: KA.getEmpty() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: !1 },
      // Debug flag that alternates each frame
      debugFlag: { value: !1 }
    };
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < Bs;
  }
  maybeAllocAccumulator() {
    let A = this.freeAccumulators.pop();
    if (A === void 0) {
      if (this.accumulatorCount >= Bs)
        return null;
      A = new Fe(), this.accumulatorCount += 1;
    }
    return A.refCount = 1, A;
  }
  releaseAccumulator(A) {
    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);
  }
  newViewpoint(A) {
    return new Ce({ ...A, spark: this });
  }
  onBeforeRender(A, e, s) {
    var E, l;
    const i = this.time ?? this.clock.getElapsedTime(), n = i - (this.viewpoint.lastTime ?? i);
    this.viewpoint.lastTime = i;
    const a = A.info.render.frame, r = a !== this.lastFrame;
    this.lastFrame = a;
    const g = this.viewpoint;
    if (g === this.defaultView) {
      if (r)
        if (!A.xr.isPresenting)
          this.defaultView.viewToWorld = s.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];
        else {
          const c = A.xr.getCamera().cameras;
          this.defaultCameras = c.map((h) => h.matrixWorld), this.defaultView.viewToWorld = fC(this.defaultCameras) ?? new B.Matrix4();
        }
      this.autoUpdate && this.update({ scene: e, viewToWorld: this.defaultView.viewToWorld });
    }
    if (r && (this.uniforms.time.value = i, this.uniforms.deltaTime.value = n, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1), g.target)
      this.uniforms.renderSize.value.set(
        g.target.width,
        g.target.height
      );
    else {
      const c = A.getDrawingBufferSize(
        this.uniforms.renderSize.value
      );
      if (c.x === 1 && c.y === 1) {
        const h = (E = A.xr.getSession()) == null ? void 0 : E.renderState.baseLayer;
        h && (c.x = h.framebufferWidth, c.y = h.framebufferHeight);
      }
    }
    const I = s;
    if (this.uniforms.near.value = I.near, this.uniforms.far.value = I.far, this.uniforms.encodeLinear.value = g.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.focalDistance.value = this.focalDistance, this.uniforms.apertureAngle.value = this.apertureAngle, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY, this.uniforms.focalAdjustment.value = this.focalAdjustment, this.splatTexture) {
      const { enable: c, texture: h, multiply: u, add: p, near: d, far: y, mid: D } = this.splatTexture;
      c && h ? (this.uniforms.splatTexEnable.value = !0, this.uniforms.splatTexture.value = h, u ? this.uniforms.splatTexMul.value.fromArray(u.elements) : this.uniforms.splatTexMul.value.set(
        0.5 / this.maxStdDev,
        0,
        0,
        0.5 / this.maxStdDev
      ), this.uniforms.splatTexAdd.value.set((p == null ? void 0 : p.x) ?? 0.5, (p == null ? void 0 : p.y) ?? 0.5), this.uniforms.splatTexNear.value = d ?? this.uniforms.near.value, this.uniforms.splatTexFar.value = y ?? this.uniforms.far.value, this.uniforms.splatTexMid.value = D ?? 0) : (this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = rA.EMPTY_SPLAT_TEXTURE);
    } else
      this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = rA.EMPTY_SPLAT_TEXTURE;
    const Q = ((l = g.display) == null ? void 0 : l.accumulator.toWorld) ?? new B.Matrix4(), o = s.matrixWorld.clone().invert();
    Q.clone().premultiply(o).decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new B.Vector3()
    );
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(A) {
    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {
      const { accumulator: e, geometry: s } = this.viewpoint.display;
      this.uniforms.numSplats.value = e.splats.numSplats, this.uniforms.packedSplats.value = e.splats.getTexture(), this.geometry = s;
    } else
      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = KA.getEmpty(), this.geometry = Cs;
  }
  // If spark.autoUpdate is false then you must manually call
  // spark.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene: A,
    viewToWorld: e
  }) {
    const s = this.matrixWorld.clone();
    this.preUpdate ? this.updateInternal({ scene: A, originToWorld: s, viewToWorld: e }) : (this.pendingUpdate = {
      scene: A,
      originToWorld: s
    }, setTimeout(() => {
      if (this.pendingUpdate) {
        const { scene: i, originToWorld: n } = this.pendingUpdate;
        this.pendingUpdate = null, this.updateInternal({ scene: i, originToWorld: n, viewToWorld: e });
      }
    }, 1));
  }
  updateInternal({
    scene: A,
    originToWorld: e,
    viewToWorld: s
  }) {
    var l;
    if (!this.canAllocAccumulator())
      return !1;
    e || (e = this.active.toWorld), s = s ?? e.clone();
    const i = this.time ?? this.clock.getElapsedTime(), n = i - (this.lastUpdateTime ?? i);
    this.lastUpdateTime = i;
    const a = this.active.mapping.reduce((c, h) => (c.set(h.node, h), c), /* @__PURE__ */ new Map()), { generators: r, visibleGenerators: g, globalEdits: I } = this.compileScene(A);
    for (const c of r)
      (l = c.frameUpdate) == null || l.call(c, {
        object: c,
        time: i,
        deltaTime: n,
        viewToWorld: s,
        globalEdits: I
      });
    const Q = new Set(g.map((c) => c.uuid));
    for (const c of r) {
      const h = a.get(c), p = c.generator && Q.has(c.uuid) ? c.numSplats : 0;
      (c.generator !== (h == null ? void 0 : h.generator) || p !== (h == null ? void 0 : h.count)) && c.updateVersion();
    }
    const C = !ge({
      matrix1: e,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    }) || r.length !== a.size || r.some((c) => {
      var h;
      return c.version !== ((h = a.get(c)) == null ? void 0 : h.version);
    });
    let E = null;
    if (C) {
      if (E = this.maybeAllocAccumulator(), !E)
        throw new Error("Unreachable");
      const c = !ge({
        matrix1: e,
        matrix2: this.active.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      }), u = g.map((m, f) => {
        const w = a.get(m);
        return w ? (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [m.version - w.version, w.base, m]
        ) : [Number.POSITIVE_INFINITY, m.version, m];
      }).sort((m, f) => m[0] !== f[0] ? m[0] - f[0] : m[1] - f[1]).map(([m, f, w]) => w), p = u.map((m) => m.numSplats), { maxSplats: d, mapping: y } = E.splats.generateMapping(p), D = u.map((m, f) => {
        const { base: w, count: R } = y[f];
        return {
          node: m,
          generator: m.generator,
          version: m.version,
          base: w,
          count: R
        };
      });
      e.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new B.Vector3()
      ), E.ensureGenerate(d), E.generateSplats({
        renderer: this.renderer,
        modifier: this.modifier,
        generators: D,
        forceUpdate: c,
        originToWorld: e
      }), E.splatsVersion = this.active.splatsVersion + 1;
      const S = E.hasCorrespondence(this.active);
      E.mappingVersion = this.active.mappingVersion + (S ? 0 : 1), this.releaseAccumulator(this.active), this.active = E, this.prepareViewpoint();
    }
    return setTimeout(() => {
      for (const c of this.autoViewpoints)
        c.autoPoll({ accumulator: E ?? void 0 });
    }, 1), !0;
  }
  compileScene(A) {
    const e = [];
    A.traverse((n) => {
      n instanceof Kt && e.push(n);
    });
    const s = [];
    A.traverseVisible((n) => {
      n instanceof Kt && s.push(n);
    });
    const i = /* @__PURE__ */ new Set();
    return A.traverseVisible((n) => {
      if (n instanceof Ie) {
        let a = n.parent;
        for (; a != null && !(a instanceof ZA); )
          a = a.parent;
        a == null && i.add(n);
      }
    }), {
      generators: e,
      visibleGenerators: s,
      globalEdits: Array.from(i)
    };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  async renderEnvMap({
    renderer: A,
    scene: e,
    worldCenter: s,
    size: i = 256,
    near: n = 0.1,
    far: a = 1e3,
    hideObjects: r = [],
    update: g = !1
  }) {
    var E, l;
    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !rA.cubeRender || rA.cubeRender.target.width !== i || rA.cubeRender.near !== n || rA.cubeRender.far !== a) {
      rA.cubeRender && rA.cubeRender.target.dispose();
      const c = new B.WebGLCubeRenderTarget(i, {
        format: B.RGBAFormat,
        generateMipmaps: !0,
        minFilter: B.LinearMipMapLinearFilter
      }), h = new B.CubeCamera(n, a, c);
      rA.cubeRender = { target: c, camera: h, near: n, far: a };
    }
    rA.pmrem || (rA.pmrem = new B.PMREMGenerator(A ?? this.renderer));
    const I = new B.Matrix4().setPosition(s);
    await ((E = this.envViewpoint) == null ? void 0 : E.prepare({ scene: e, viewToWorld: I, update: g }));
    const { target: Q, camera: o } = rA.cubeRender;
    o.position.copy(s);
    const C = /* @__PURE__ */ new Map();
    for (const c of r)
      C.set(c, c.visible), c.visible = !1;
    this.prepareViewpoint(this.envViewpoint), o.update(A ?? this.renderer, e), this.prepareViewpoint(this.defaultView);
    for (const [c, h] of C.entries())
      c.visible = h;
    return (l = rA.pmrem) == null ? void 0 : l.fromCubemap(Q.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(A, e) {
    A.traverse((s) => {
      if (s instanceof B.Mesh)
        if (Array.isArray(s.material))
          for (const i of s.material)
            i instanceof B.MeshStandardMaterial && (i.envMap = e);
        else
          s.material instanceof B.MeshStandardMaterial && (s.material.envMap = e);
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator: A,
    rgba: e
  }) {
    const s = this.active.mapping.find(({ node: i }) => i === A);
    if (!s)
      throw new Error("Generator not found");
    return e = e ?? new Je(), e.fromPackedSplats({
      packedSplats: this.active.splats,
      base: s.base,
      count: s.count,
      renderer: this.renderer
    }), e;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator: A,
    rgba: e
  }) {
    return e = this.getRgba({ generator: A, rgba: e }), e.read();
  }
};
rA.cubeRender = null, rA.pmrem = null, rA.EMPTY_SPLAT_TEXTURE = new B.Data3DTexture();
let Ee = rA;
const Cs = new Te(new Uint32Array(1), 0);
kA(
  { packedSplats: Pt, index: "int" },
  { gsplat: j },
  ({ packedSplats: t, index: A }) => {
    if (!t || !A)
      throw new Error("Invalid input");
    return { gsplat: Ht(t, A) };
  }
);
function fC(t) {
  if (t.length === 0)
    return null;
  const A = new B.Vector3(), e = new B.Quaternion(), s = new B.Vector3(), i = [], n = [];
  for (const a of t)
    a.decompose(A, e, s), i.push(A), n.push(e);
  return new B.Matrix4().compose(
    Ri(i),
    Ui(n),
    new B.Vector3(1, 1, 1)
  );
}
function mC(t, A, e) {
  const s = Math.floor(t.length / 32);
  if (s * 32 !== t.length)
    throw new Error("Invalid .splat file size");
  const i = new Float32Array(t.buffer);
  for (let n = 0; n < s; ++n) {
    const a = n * 32, r = n * 8, g = i[r + 0], I = i[r + 1], Q = i[r + 2], o = i[r + 3], C = i[r + 4], E = i[r + 5], l = t[a + 24] / 255, c = t[a + 25] / 255, h = t[a + 26] / 255, u = t[a + 27] / 255, p = (t[a + 28] - 128) / 128, d = (t[a + 29] - 128) / 128, y = (t[a + 30] - 128) / 128, D = (t[a + 31] - 128) / 128;
    e(
      n,
      g,
      I,
      Q,
      o,
      C,
      E,
      d,
      y,
      D,
      p,
      u,
      l,
      c,
      h
    );
  }
}
const Es = {
  0: {
    bytesPerCenter: 12,
    bytesPerScale: 12,
    bytesPerRotation: 16,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 4,
    scaleOffsetBytes: 12,
    rotationOffsetBytes: 24,
    colorOffsetBytes: 40,
    sphericalHarmonicsOffsetBytes: 44,
    scaleRange: 1
  },
  1: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 2,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  },
  2: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 1,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  }
}, xC = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function SC(t, A, e, s) {
  var c;
  let a = 0;
  const r = new DataView(t.buffer, a, 4096);
  a += 4096;
  const g = r.getUint8(0), I = r.getUint8(1);
  if (g !== 0 || I < 1)
    throw new Error(
      `Unsupported .ksplat version: ${g}.${I}`
    );
  const Q = r.getUint32(4, !0);
  r.getUint32(16, !0);
  const o = r.getUint16(20, !0);
  if (o < 0 || o > 2)
    throw new Error(`Invalid .ksplat compression level: ${o}`);
  const C = r.getFloat32(36, !0) || -1.5, E = r.getFloat32(40, !0) || 1.5;
  let l = 4096 + Q * 1024;
  for (let h = 0; h < Q; ++h) {
    let u = function(MA, T) {
      if (o === 0)
        return Y.getFloat32(
          MA + V + T * 4,
          !0
        );
      if (o === 1)
        return DA(
          Y.getUint16(
            MA + V + T * 2,
            !0
          )
        );
      const OA = Y.getUint8(MA + V + T) / 255;
      return C + OA * (E - C);
    };
    const p = new DataView(t.buffer, a, 1024);
    a += 1024;
    const d = p.getUint32(0, !0), y = p.getUint32(4, !0), D = p.getUint32(8, !0), S = p.getUint32(12, !0), m = p.getFloat32(16, !0), f = p.getUint16(20, !0), w = (p.getUint32(24, !0) || ((c = Es[o]) == null ? void 0 : c.scaleRange)) ?? 1, R = p.getUint32(32, !0), M = R * D, x = p.getUint32(36, !0), L = x * 4, N = f * S + L, k = p.getUint16(40, !0), U = xC[k], {
      bytesPerCenter: v,
      bytesPerScale: AA,
      bytesPerRotation: z,
      bytesPerColor: sA,
      bytesPerSphericalHarmonicsComponent: tA,
      scaleOffsetBytes: P,
      rotationOffsetBytes: J,
      colorOffsetBytes: Z,
      sphericalHarmonicsOffsetBytes: V
    } = Es[o], X = v + AA + z + sA + U * tA, b = X * y, dA = b + N, oA = [0, 3, 6, 1, 4, 7, 2, 5, 8], pA = [
      9,
      14,
      19,
      10,
      15,
      20,
      11,
      16,
      21,
      12,
      17,
      22,
      13,
      18,
      23
    ], yA = [
      24,
      31,
      38,
      25,
      32,
      39,
      26,
      33,
      40,
      27,
      34,
      41,
      28,
      35,
      42,
      29,
      36,
      43,
      30,
      37,
      44
    ], xA = k >= 1 ? new Float32Array(3 * 3) : void 0, cA = k >= 2 ? new Float32Array(5 * 3) : void 0, LA = k >= 3 ? new Float32Array(7 * 3) : void 0, SA = m / 2 / w, XA = l + L, WA = l + N, Y = new DataView(
      t.buffer,
      WA,
      b
    ), uA = new Float32Array(
      t.buffer,
      XA,
      S * 3
    ), _A = new Uint32Array(
      t.buffer,
      l,
      x
    );
    let Rt = R, Wt = M;
    for (let MA = 0; MA < d; ++MA) {
      const T = MA * X;
      let OA;
      if (MA < M)
        OA = Math.floor(MA / D);
      else {
        const jA = _A[Rt - R];
        MA >= Wt + jA && (Rt += 1, Wt += jA), OA = Rt;
      }
      const de = o === 0 ? Y.getFloat32(T + 0, !0) : (Y.getUint16(T + 0, !0) - w) * SA + uA[3 * OA + 0], pe = o === 0 ? Y.getFloat32(T + 4, !0) : (Y.getUint16(T + 2, !0) - w) * SA + uA[3 * OA + 1], ye = o === 0 ? Y.getFloat32(T + 8, !0) : (Y.getUint16(T + 4, !0) - w) * SA + uA[3 * OA + 2], we = o === 0 ? Y.getFloat32(T + P + 0, !0) : DA(Y.getUint16(T + P + 0, !0)), De = o === 0 ? Y.getFloat32(T + P + 4, !0) : DA(Y.getUint16(T + P + 2, !0)), Wr = o === 0 ? Y.getFloat32(T + P + 8, !0) : DA(Y.getUint16(T + P + 4, !0)), jr = o === 0 ? Y.getFloat32(T + J + 0, !0) : DA(
        Y.getUint16(T + J + 0, !0)
      ), $r = o === 0 ? Y.getFloat32(T + J + 4, !0) : DA(
        Y.getUint16(T + J + 2, !0)
      ), Ag = o === 0 ? Y.getFloat32(T + J + 8, !0) : DA(
        Y.getUint16(T + J + 4, !0)
      ), tg = o === 0 ? Y.getFloat32(T + J + 12, !0) : DA(
        Y.getUint16(T + J + 6, !0)
      ), eg = Y.getUint8(T + Z + 0) / 255, sg = Y.getUint8(T + Z + 1) / 255, ig = Y.getUint8(T + Z + 2) / 255, ng = Y.getUint8(T + Z + 3) / 255;
      if (e(
        MA,
        de,
        pe,
        ye,
        we,
        De,
        Wr,
        $r,
        Ag,
        tg,
        jr,
        ng,
        eg,
        sg,
        ig
      ), k >= 1 && xA) {
        for (const [jA, Ut] of oA.entries())
          xA[jA] = u(T, Ut);
        if (cA)
          for (const [jA, Ut] of pA.entries())
            cA[jA] = u(T, Ut);
        if (LA)
          for (const [jA, Ut] of yA.entries())
            LA[jA] = u(T, Ut);
        s == null || s(MA, xA, cA, LA);
      }
    }
    l += dA;
  }
}
class MC {
  constructor({ fileBytes: A }) {
    this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A, this.reader = new Ji({ fileBytes: this.fileBytes });
    const e = new DataView(this.reader.read(16).buffer);
    if (e.getUint32(0, !0) !== 1347635022)
      throw new Error("Invalid SPZ file");
    if (this.version = e.getUint32(4, !0), this.version < 1 || this.version > 2)
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    this.numSplats = e.getUint32(8, !0), this.shDegree = e.getUint8(12), this.fractionalBits = e.getUint8(13), this.flags = e.getUint8(14), this.flagAntiAlias = (this.flags & 1) !== 0, this.reserved = e.getUint8(15), this.parsed = !1;
  }
  parseSplats(A, e, s, i, n, a) {
    if (this.parsed)
      throw new Error("SPZ file already parsed");
    if (this.parsed = !0, this.version === 1) {
      const r = this.reader.read(this.numSplats * 3 * 2), g = new Uint16Array(r.buffer);
      for (let I = 0; I < this.numSplats; I++) {
        const Q = I * 3, o = DA(g[Q]), C = DA(g[Q + 1]), E = DA(g[Q + 2]);
        A == null || A(I, o, C, E);
      }
    } else if (this.version === 2) {
      const r = 1 << this.fractionalBits, g = this.reader.read(this.numSplats * 3 * 3);
      for (let I = 0; I < this.numSplats; I++) {
        const Q = I * 9, o = ((g[Q + 2] << 24 | g[Q + 1] << 16 | g[Q] << 8) >> 8) / r, C = ((g[Q + 5] << 24 | g[Q + 4] << 16 | g[Q + 3] << 8) >> 8) / r, E = ((g[Q + 8] << 24 | g[Q + 7] << 16 | g[Q + 6] << 8) >> 8) / r;
        A == null || A(I, o, C, E);
      }
    } else
      throw new Error("Unreachable");
    {
      const r = this.reader.read(this.numSplats);
      for (let g = 0; g < this.numSplats; g++)
        e == null || e(g, r[g] / 255);
    }
    {
      const r = this.reader.read(this.numSplats * 3), g = zr / 0.15;
      for (let I = 0; I < this.numSplats; I++) {
        const Q = I * 3, o = (r[Q] / 255 - 0.5) * g + 0.5, C = (r[Q + 1] / 255 - 0.5) * g + 0.5, E = (r[Q + 2] / 255 - 0.5) * g + 0.5;
        s == null || s(I, o, C, E);
      }
    }
    {
      const r = this.reader.read(this.numSplats * 3);
      for (let g = 0; g < this.numSplats; g++) {
        const I = g * 3, Q = Math.exp(r[I] / 16 - 10), o = Math.exp(r[I + 1] / 16 - 10), C = Math.exp(r[I + 2] / 16 - 10);
        i == null || i(g, Q, o, C);
      }
    }
    {
      const r = this.reader.read(this.numSplats * 3);
      for (let g = 0; g < this.numSplats; g++) {
        const I = g * 3, Q = r[I] / 127.5 - 1, o = r[I + 1] / 127.5 - 1, C = r[I + 2] / 127.5 - 1, E = Math.sqrt(
          Math.max(0, 1 - Q * Q - o * o - C * C)
        );
        n == null || n(g, Q, o, C, E);
      }
    }
    if (a && this.shDegree >= 1) {
      const r = new Float32Array(9), g = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0, I = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0, Q = this.reader.read(
        this.numSplats * Kr[this.shDegree] * 3
      );
      let o = 0;
      for (let C = 0; C < this.numSplats; C++) {
        for (let E = 0; E < 9; ++E)
          r[E] = (Q[o + E] - 128) / 128;
        if (o += 9, g) {
          for (let E = 0; E < 15; ++E)
            g[E] = (Q[o + E] - 128) / 128;
          o += 15;
        }
        if (I) {
          for (let E = 0; E < 21; ++E)
            I[E] = (Q[o + E] - 128) / 128;
          o += 21;
        }
        a == null || a(C, r, g, I);
      }
    }
  }
}
const Kr = { 1: 3, 2: 8, 3: 15 }, zr = 0.28209479177387814, FC = 1347635022, NC = 2, kC = 1;
class tt {
  constructor({
    numSplats: A,
    shDegree: e,
    fractionalBits: s = 12,
    flagAntiAlias: i = !0
  }) {
    this.clippedCount = 0;
    const n = 19 + (e >= 1 ? 9 : 0) + (e >= 2 ? 15 : 0) + (e >= 3 ? 21 : 0), a = 16 + A * n;
    this.buffer = new ArrayBuffer(a), this.view = new DataView(this.buffer), this.view.setUint32(0, FC, !0), this.view.setUint32(4, NC, !0), this.view.setUint32(8, A, !0), this.view.setUint8(12, e), this.view.setUint8(13, s), this.view.setUint8(14, i ? kC : 0), this.view.setUint8(15, 0), this.numSplats = A, this.shDegree = e, this.fractionalBits = s, this.fraction = 1 << s, this.flagAntiAlias = i;
  }
  setCenter(A, e, s, i) {
    const n = Math.round(e * this.fraction), a = Math.max(-8388607, Math.min(8388607, n)), r = Math.round(s * this.fraction), g = Math.max(-8388607, Math.min(8388607, r)), I = Math.round(i * this.fraction), Q = Math.max(-8388607, Math.min(8388607, I));
    (n !== a || r !== g || I !== Q) && (this.clippedCount += 1);
    const E = 16 + A * 9;
    this.view.setUint8(E, a & 255), this.view.setUint8(E + 1, a >> 8 & 255), this.view.setUint8(E + 2, a >> 16 & 255), this.view.setUint8(E + 3, g & 255), this.view.setUint8(E + 4, g >> 8 & 255), this.view.setUint8(E + 5, g >> 16 & 255), this.view.setUint8(E + 6, Q & 255), this.view.setUint8(E + 7, Q >> 8 & 255), this.view.setUint8(E + 8, Q >> 16 & 255);
  }
  setAlpha(A, e) {
    const s = 16 + this.numSplats * 9 + A;
    this.view.setUint8(
      s,
      Math.max(0, Math.min(255, Math.round(e * 255)))
    );
  }
  static scaleRgb(A) {
    const e = ((A - 0.5) / (zr / 0.15) + 0.5) * 255;
    return Math.max(0, Math.min(255, Math.round(e)));
  }
  setRgb(A, e, s, i) {
    const n = 16 + this.numSplats * 10 + A * 3;
    this.view.setUint8(n, tt.scaleRgb(e)), this.view.setUint8(n + 1, tt.scaleRgb(s)), this.view.setUint8(n + 2, tt.scaleRgb(i));
  }
  setScale(A, e, s, i) {
    const n = 16 + this.numSplats * 13 + A * 3;
    this.view.setUint8(
      n,
      Math.max(0, Math.min(255, Math.round((Math.log(e) + 10) * 16)))
    ), this.view.setUint8(
      n + 1,
      Math.max(0, Math.min(255, Math.round((Math.log(s) + 10) * 16)))
    ), this.view.setUint8(
      n + 2,
      Math.max(0, Math.min(255, Math.round((Math.log(i) + 10) * 16)))
    );
  }
  setQuat(A, e, s, i, n) {
    const a = 16 + this.numSplats * 16 + A * 3, r = n < 0;
    this.view.setUint8(
      a,
      Math.max(
        0,
        Math.min(255, Math.round(((r ? -e : e) + 1) * 127.5))
      )
    ), this.view.setUint8(
      a + 1,
      Math.max(
        0,
        Math.min(255, Math.round(((r ? -s : s) + 1) * 127.5))
      )
    ), this.view.setUint8(
      a + 2,
      Math.max(
        0,
        Math.min(255, Math.round(((r ? -i : i) + 1) * 127.5))
      )
    );
  }
  static quantizeSh(A, e) {
    const s = Math.round(A * 128) + 128, i = 1 << 8 - e, n = Math.floor((s + i / 2) / i) * i;
    return Math.max(0, Math.min(255, n));
  }
  setSh(A, e, s, i) {
    const n = Kr[this.shDegree] || 0, a = 16 + this.numSplats * 19 + A * n * 3;
    for (let r = 0; r < 9; ++r)
      this.view.setUint8(a + r, tt.quantizeSh(e[r], 5));
    if (s) {
      const r = a + 9;
      for (let g = 0; g < 15; ++g)
        this.view.setUint8(r + g, tt.quantizeSh(s[g], 4));
      if (i) {
        const g = r + 15;
        for (let I = 0; I < 21; ++I)
          this.view.setUint8(g + I, tt.quantizeSh(i[I], 4));
      }
    }
  }
  async finalize() {
    const A = new Uint8Array(this.buffer), s = new ReadableStream({
      async start(a) {
        a.enqueue(A), a.close();
      }
    }).pipeThrough(new CompressionStream("gzip")), n = await new Response(s).arrayBuffer();
    return console.log(
      "Compressed",
      A.length,
      "bytes to",
      n.byteLength,
      "bytes"
    ), new Uint8Array(n);
  }
}
async function EE(t) {
  var Q, o, C;
  const A = new CC(), {
    inputs: e,
    clipXyz: s,
    maxSh: i,
    fractionalBits: n = 12,
    opacityThreshold: a
  } = t;
  for (const E of e) {
    let l = function(f) {
      return f.multiplyScalar(d), f.applyQuaternion(y), f.add(D), f;
    }, c = function(f) {
      return f.multiplyScalar(d), f;
    }, h = function(f) {
      return f.premultiply(y), f;
    }, u = function(f) {
      return !S || S.containsPoint(f);
    }, p = function(f) {
      return a !== void 0 ? f >= a : !0;
    };
    const d = ((Q = E.transform) == null ? void 0 : Q.scale) ?? 1, y = new B.Quaternion().fromArray(
      ((o = E.transform) == null ? void 0 : o.quaternion) ?? [0, 0, 0, 1]
    ), D = new B.Vector3().fromArray(
      ((C = E.transform) == null ? void 0 : C.translate) ?? [0, 0, 0]
    ), S = s ? new B.Box3(
      new B.Vector3().fromArray(s.min),
      new B.Vector3().fromArray(s.max)
    ) : void 0;
    let m = E.fileType;
    switch (m || (m = Yr(E.fileBytes), !m && E.pathOrUrl && (m = Jr(E.pathOrUrl))), m) {
      case vt.PLY: {
        const f = new Qe({ fileBytes: E.fileBytes });
        await f.parseHeader();
        let w = null;
        f.parseSplats(
          (R, M, x, L, N, k, U, v, AA, z, sA, tA, P, J, Z) => {
            const V = l(new B.Vector3(M, x, L));
            if (u(V) && p(tA)) {
              w = A.pushSplat(), A.setCenter(w, V.x, V.y, V.z);
              const X = c(
                new B.Vector3(N, k, U)
              );
              A.setScale(w, X.x, X.y, X.z);
              const b = h(
                new B.Quaternion(v, AA, z, sA)
              );
              A.setQuaternion(
                w,
                b.x,
                b.y,
                b.z,
                b.w
              ), A.setOpacity(w, tA), A.setColor(w, P, J, Z);
            } else
              w = null;
          },
          (R, M, x, L) => {
            M && w !== null && A.setSh1(w, M), x && w !== null && A.setSh2(w, x), L && w !== null && A.setSh3(w, L);
          }
        );
        break;
      }
      case vt.SPZ: {
        const f = new MC({ fileBytes: E.fileBytes }), w = new Int32Array(f.numSplats);
        w.fill(-1);
        const R = new Float32Array(f.numSplats * 3), M = new B.Vector3();
        f.parseSplats(
          (x, L, N, k) => {
            const U = l(new B.Vector3(L, N, k));
            R[x * 3] = U.x, R[x * 3 + 1] = U.y, R[x * 3 + 2] = U.z;
          },
          (x, L) => {
            M.fromArray(R, x * 3), u(M) && p(L) && (w[x] = A.pushSplat(), A.setCenter(w[x], M.x, M.y, M.z), A.setOpacity(w[x], L));
          },
          (x, L, N, k) => {
            w[x] >= 0 && A.setColor(w[x], L, N, k);
          },
          (x, L, N, k) => {
            if (w[x] >= 0) {
              const U = c(
                new B.Vector3(L, N, k)
              );
              A.setScale(w[x], U.x, U.y, U.z);
            }
          },
          (x, L, N, k, U) => {
            if (w[x] >= 0) {
              const v = h(
                new B.Quaternion(L, N, k, U)
              );
              A.setQuaternion(
                w[x],
                v.x,
                v.y,
                v.z,
                v.w
              );
            }
          },
          (x, L, N, k) => {
            w[x] >= 0 && (A.setSh1(w[x], L), N && A.setSh2(w[x], N), k && A.setSh3(w[x], k));
          }
        );
        break;
      }
      case vt.SPLAT:
        mC(
          E.fileBytes,
          (f) => {
          },
          (f, w, R, M, x, L, N, k, U, v, AA, z, sA, tA, P) => {
            const J = l(new B.Vector3(w, R, M));
            if (u(J) && p(z)) {
              const Z = A.pushSplat();
              A.setCenter(Z, J.x, J.y, J.z);
              const V = c(
                new B.Vector3(x, L, N)
              );
              A.setScale(Z, V.x, V.y, V.z);
              const X = h(
                new B.Quaternion(k, U, v, AA)
              );
              A.setQuaternion(
                Z,
                X.x,
                X.y,
                X.z,
                X.w
              ), A.setOpacity(Z, z), A.setColor(Z, sA, tA, P);
            }
          }
        );
        break;
      case vt.KSPLAT: {
        let f = null;
        SC(
          E.fileBytes,
          (w) => {
          },
          (w, R, M, x, L, N, k, U, v, AA, z, sA, tA, P, J) => {
            const Z = l(new B.Vector3(R, M, x));
            if (u(Z) && p(sA)) {
              f = A.pushSplat(), A.setCenter(f, Z.x, Z.y, Z.z);
              const V = c(
                new B.Vector3(L, N, k)
              );
              A.setScale(f, V.x, V.y, V.z);
              const X = h(
                new B.Quaternion(U, v, AA, z)
              );
              A.setQuaternion(
                f,
                X.x,
                X.y,
                X.z,
                X.w
              ), A.setOpacity(f, sA), A.setColor(f, tA, P, J);
            } else
              f = null;
          },
          (w, R, M, x) => {
            f !== null && (A.setSh1(f, R), M && A.setSh2(f, M), x && A.setSh3(f, x));
          }
        );
        break;
      }
      default:
        throw new Error(`transcodeSpz not implemented for ${m}`);
    }
  }
  const r = Math.min(
    i ?? 3,
    A.sh3 ? 3 : A.sh2 ? 2 : A.sh1 ? 1 : 0
  ), g = new tt({
    numSplats: A.numSplats,
    shDegree: r,
    fractionalBits: n,
    flagAntiAlias: !0
  });
  for (let E = 0; E < A.numSplats; ++E) {
    const l = E * 3, c = E * 4;
    g.setCenter(
      E,
      A.centers[l],
      A.centers[l + 1],
      A.centers[l + 2]
    ), g.setScale(
      E,
      A.scales[l],
      A.scales[l + 1],
      A.scales[l + 2]
    ), g.setQuat(
      E,
      A.quaternions[c],
      A.quaternions[c + 1],
      A.quaternions[c + 2],
      A.quaternions[c + 3]
    ), g.setAlpha(E, A.opacities[E]), g.setRgb(
      E,
      A.colors[l],
      A.colors[l + 1],
      A.colors[l + 2]
    ), A.sh1 && r >= 1 && g.setSh(
      E,
      A.sh1.slice(E * 9, (E + 1) * 9),
      r >= 2 && A.sh2 ? A.sh2.slice(E * 15, (E + 1) * 15) : void 0,
      r >= 3 && A.sh3 ? A.sh3.slice(E * 21, (E + 1) * 21) : void 0
    );
  }
  return { fileBytes: await g.finalize(), clippedCount: g.clippedCount };
}
class cE {
  constructor(A) {
    this.mesh = A.mesh, this.numSplats = A.numSplats ?? this.mesh.numSplats;
    const { width: e, height: s, depth: i, maxSplats: n } = mA(this.numSplats);
    this.skinData = new Uint16Array(n * 4), this.skinTexture = new B.DataArrayTexture(
      this.skinData,
      e,
      s,
      i
    ), this.skinTexture.format = B.RGBAIntegerFormat, this.skinTexture.type = B.UnsignedShortType, this.skinTexture.internalFormat = "RGBA16UI", this.skinTexture.needsUpdate = !0, this.numBones = A.numBones ?? 256, this.boneData = new Float32Array(this.numBones * 16), this.boneTexture = new B.DataTexture(
      this.boneData,
      4,
      this.numBones,
      B.RGBAFormat,
      B.FloatType
    ), this.boneTexture.internalFormat = "RGBA32F", this.boneTexture.needsUpdate = !0, this.uniform = new G({
      key: "skinning",
      type: _r,
      globals: () => [Or],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(A) {
    return RC(A, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(A, e, s) {
    const i = A * 16;
    this.boneData[i + 0] = e.x, this.boneData[i + 1] = e.y, this.boneData[i + 2] = e.z, this.boneData[i + 3] = e.w, this.boneData[i + 4] = s.x, this.boneData[i + 5] = s.y, this.boneData[i + 6] = s.z, this.boneData[i + 7] = 0, this.boneData[i + 8] = 0, this.boneData[i + 9] = 0, this.boneData[i + 10] = 0, this.boneData[i + 11] = 1, this.boneData[i + 12] = 0, this.boneData[i + 13] = 0, this.boneData[i + 14] = 0, this.boneData[i + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(A, e, s) {
    const i = A * 16, n = new B.Quaternion(
      this.boneData[i + 0],
      this.boneData[i + 1],
      this.boneData[i + 2],
      this.boneData[i + 3]
    ), a = new B.Vector3(
      this.boneData[i + 4],
      this.boneData[i + 5],
      this.boneData[i + 6]
    ), r = n.clone().invert(), g = s.clone().sub(a);
    g.applyQuaternion(r), r.multiply(e);
    const I = new B.Quaternion(
      g.x,
      g.y,
      g.z,
      0
    ).multiply(n);
    this.boneData[i + 8] = r.x, this.boneData[i + 9] = r.y, this.boneData[i + 10] = r.z, this.boneData[i + 11] = r.w, this.boneData[i + 12] = 0.5 * I.x, this.boneData[i + 13] = 0.5 * I.y, this.boneData[i + 14] = 0.5 * I.z, this.boneData[i + 15] = 0.5 * I.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(A, e, s) {
    const i = A * 4;
    this.skinData[i + 0] = Math.min(255, Math.max(0, Math.round(s.x * 255))) + (e.x << 8), this.skinData[i + 1] = Math.min(255, Math.max(0, Math.round(s.y * 255))) + (e.y << 8), this.skinData[i + 2] = Math.min(255, Math.max(0, Math.round(s.z * 255))) + (e.z << 8), this.skinData[i + 3] = Math.min(255, Math.max(0, Math.round(s.w * 255))) + (e.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = !0, this.mesh.needsUpdate = !0;
  }
}
const _r = { type: "GsplatSkinning" }, Or = EA(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`), GC = EA(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function RC(t, A) {
  return new O({
    inTypes: { gsplat: j, skinning: _r },
    outTypes: { gsplat: j },
    globals: () => [Or, GC],
    inputs: { gsplat: t, skinning: A },
    statements: ({ inputs: s, outputs: i }) => {
      const { skinning: n } = s, { gsplat: a } = i;
      return UA(`
        ${a} = ${s.gsplat};
        if (isGsplatActive(${a}.flags)) {
          applyGsplatSkinning(
            ${n}.numSplats, ${n}.numBones,
            ${n}.skinTexture, ${n}.boneTexture,
            ${a}.index, ${a}.center, ${a}.quaternion
          );
        }
      `);
    }
  }).outputs.gsplat;
}
function hE({
  // PackedSplats object to add splats to
  splats: t,
  // min and max box extents of the grid
  extents: A,
  // step size along each grid axis
  stepSize: e = 1,
  // spherical radius of each Gsplat
  pointRadius: s = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale: i = 2,
  // Gsplat opacity
  opacity: n = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color: a
}) {
  const g = new B.Vector3(), I = new B.Vector3(), Q = new B.Quaternion(0, 0, 0, 1);
  a == null && (a = (C, E) => C.set(
    0.55 + 0.45 * Math.cos(E.x * 1),
    0.55 + 0.45 * Math.cos(E.y * 1),
    0.55 + 0.45 * Math.cos(E.z * 1)
  ));
  const o = new B.Color();
  for (let C = A.min.z; C < A.max.z + 1e-6; C += e)
    for (let E = A.min.y; E < A.max.y + 1e-6; E += e)
      for (let l = A.min.x; l < A.max.x + 1e-6; l += e) {
        g.set(l, E, C);
        for (let c = 0; c < 2; ++c)
          I.setScalar(s * (c ? 1 : i)), c ? typeof a == "function" ? a(o, g) : o.copy(a) : o.setScalar(0), t.pushSplat(g, I, Q, n, o);
      }
}
function lE({
  // PackedSplats object to add splats to
  splats: t,
  // scale (Gsplat scale along axis)
  scale: A = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius: e = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale: s = 2,
  // origins of the axes (default single axis at origin)
  origins: i = [new B.Vector3()]
}) {
  const n = new B.Vector3(), a = new B.Vector3(), r = new B.Quaternion(0, 0, 0, 1), g = new B.Color(), I = 1;
  for (const Q of i)
    for (let o = 0; o < 3; ++o) {
      n.set(
        Q.x + (o === 0 ? A : 0),
        Q.y + (o === 1 ? A : 0),
        Q.z + (o === 2 ? A : 0)
      );
      for (let C = 0; C < 2; ++C)
        a.set(
          (o === 0 ? A : e) * (C ? 1 : s),
          (o === 1 ? A : e) * (C ? 1 : s),
          (o === 2 ? A : e) * (C ? 1 : s)
        ), g.setRGB(
          C === 0 ? 0 : o === 0 ? 1 : 0,
          C === 0 ? 0 : o === 1 ? 1 : 0,
          C === 0 ? 0 : o === 2 ? 1 : 0
        ), t.pushSplat(n, a, r, I, g);
    }
}
function uE({
  // PackedSplats object to add splats to
  splats: t,
  // center of the sphere (default: origin)
  origin: A = new B.Vector3(),
  // radius of the sphere
  radius: e = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth: s = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter: i = null,
  // radius of each oriented Gsplat
  pointRadius: n = 0.02,
  // flatness of each oriented Gsplat
  pointThickness: a = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color: r = new B.Color(1, 1, 1)
}) {
  const g = {};
  function I(c) {
    if (i && !i(c))
      return;
    const h = `${c.x},${c.y},${c.z}`;
    g[h] || (g[h] = c);
  }
  function Q(c, h, u, p) {
    if (I(h), I(u), I(p), c >= s)
      return;
    const d = new B.Vector3().addVectors(h, u).normalize(), y = new B.Vector3().addVectors(u, p).normalize(), D = new B.Vector3().addVectors(p, h).normalize();
    Q(c + 1, h, d, D), Q(c + 1, d, u, y), Q(c + 1, D, y, p), Q(c + 1, d, y, D);
  }
  for (const c of [-1, 1])
    for (const h of [-1, 1])
      for (const u of [-1, 1]) {
        const p = new B.Vector3(c, 0, 0), d = new B.Vector3(0, h, 0), y = new B.Vector3(0, 0, u);
        Q(0, p, d, y);
      }
  const o = Object.values(g), C = new B.Vector3(n, n, a), E = new B.Quaternion(), l = typeof r == "function" ? new B.Color() : r;
  for (const c of o)
    E.setFromUnitVectors(new B.Vector3(0, 0, -1), c), typeof r == "function" && r(l, c), c.multiplyScalar(e), c.add(A), t.pushSplat(c, C, E, 1, l);
}
function dE({
  // text string to display
  text: t,
  // browser font to render text with (default: "Arial")
  font: A,
  // font size in pixels/Gsplats (default: 32)
  fontSize: e,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color: s,
  // Individual Gsplat color (default: white)
  rgb: i,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius: n,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign: a,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight: r,
  // Coordinate scale in object-space (default: 1.0)
  objectScale: g
}) {
  A = A ?? "Arial", e = e ?? 32, s = s ?? new B.Color(1, 1, 1), n = n ?? 0.8, a = a ?? "start", r = r ?? 1, g = g ?? 1;
  const I = t.split(`
`), Q = document.createElement("canvas"), o = Q.getContext("2d");
  if (!o)
    throw new Error("Failed to create canvas context");
  o.font = `${e}px ${A}`, o.textAlign = a;
  const C = o.measureText(""), E = C.fontBoundingBoxAscent + C.fontBoundingBoxDescent;
  let l = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, h = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY;
  for (let N = 0; N < I.length; ++N) {
    const k = o.measureText(I[N]), U = E * r * N;
    l = Math.min(l, -k.actualBoundingBoxLeft), c = Math.max(c, k.actualBoundingBoxRight), h = Math.min(h, U - k.actualBoundingBoxAscent), u = Math.max(u, U + k.actualBoundingBoxDescent);
  }
  const p = Math.floor(l), d = Math.floor(h), y = Math.ceil(c) - p, D = Math.ceil(u) - d;
  Q.width = y, Q.height = D, o.font = `${e}px ${A}`, o.textAlign = a, o.textBaseline = "alphabetic", o.fillStyle = "#FFFFFF";
  for (let N = 0; N < I.length; ++N) {
    const k = E * r * N - d;
    o.fillText(I[N], -p, k);
  }
  const S = o.getImageData(0, 0, y, D), m = new Uint8Array(S.data.buffer), f = new KA(), w = new B.Vector3(), R = new B.Vector3().setScalar(n * g), M = new B.Quaternion(0, 0, 0, 1);
  i = i ?? new B.Color(1, 1, 1);
  let x = 0;
  for (let N = 0; N < D; ++N)
    for (let k = 0; k < y; ++k) {
      const U = m[x + 3];
      if (U > 0) {
        const v = U / 255;
        w.set(k - 0.5 * (y - 1), 0.5 * (D - 1) - N, 0), w.multiplyScalar(g), f.pushSplat(w, R, M, v, i);
      }
      x += 4;
    }
  const L = new ZA({ packedSplats: f });
  return L.recolor = s, L;
}
function pE({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url: t,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius: A,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY: e,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat: s
}) {
  return A = A ?? 0.8, e = Math.max(1, Math.floor(e ?? 1)), new ZA({
    constructSplats: async (i) => new Promise((n, a) => {
      const r = new Image();
      r.crossOrigin = "anonymous", r.onerror = a, r.onload = () => {
        const { width: g, height: I } = r, Q = document.createElement("canvas");
        Q.width = g, Q.height = I;
        const o = Q.getContext("2d");
        if (!o) {
          a(new Error("Failed to create canvas context"));
          return;
        }
        o.imageSmoothingEnabled = !0, o.imageSmoothingQuality = "high";
        const C = Math.round(g / e), E = Math.round(I / e);
        o.drawImage(r, 0, 0, C, E);
        try {
          const l = o.getImageData(0, 0, C, E), c = new Uint8Array(l.data.buffer), h = new B.Vector3(), u = new B.Vector3().setScalar(A), p = new B.Quaternion(0, 0, 0, 1), d = new B.Color();
          let y = 0;
          for (let D = 0; D < E; ++D)
            for (let S = 0; S < C; ++S) {
              const m = y * 4, f = c[m + 3];
              if (f > 0) {
                let w = f / 255;
                d.set(
                  c[m + 0] / 255,
                  c[m + 1] / 255,
                  c[m + 2] / 255
                ), h.set(
                  S - 0.5 * (C - 1),
                  0.5 * (E - 1) - D,
                  0
                ), u.setScalar(A), p.set(0, 0, 0, 1);
                let R = !0;
                if (s) {
                  const M = s(
                    C,
                    E,
                    y,
                    h,
                    u,
                    p,
                    w,
                    d
                  );
                  w = M ?? w, R = M !== null;
                }
                R && i.pushSplat(h, u, p, w, d);
              }
              y += 1;
            }
          n();
        } catch (l) {
          a(l);
        }
      }, r.src = t;
    })
  });
}
function UC({
  box: t,
  cells: A,
  dotScale: e,
  color: s,
  opacity: i
}) {
  A.x = Math.max(1, Math.round(A.x)), A.y = Math.max(1, Math.round(A.y)), A.z = Math.max(1, Math.round(A.z)), i = i ?? 1;
  const n = A.x * A.y * A.z, a = q("int", A.x), r = q("int", A.y);
  q("int", A.z);
  const g = JA(0), I = new Kt({
    numSplats: n,
    generator: kA(
      { index: "int" },
      { gsplat: j },
      ({ index: o }) => {
        if (!o)
          throw new Error("index is undefined");
        const C = be(o, a), E = ie(o, a), l = be(E, r), c = ie(E, r), h = qA({
          vectorType: "ivec3",
          x: C,
          y: l,
          z: c
        }), u = qn(g), p = qA({ vectorType: "ivec2", x: o, y: u }), d = Oa(p), y = q("vec3", t.min), D = q("vec3", t.max), S = Ft(D, y), m = ie(fA(ct(h), d), q("vec3", A));
        let f, w, R;
        s ? (f = q("float", s.r), w = q("float", s.g), R = q("float", s.b)) : { r: f, g: w, b: R } = St(m).outputs;
        const M = qA({
          vectorType: "vec4",
          r: f,
          g: w,
          b: R,
          a: q("float", i)
        }), x = fA(y, BA(S, m)), L = ct(q("float", e)), N = q("vec4", new B.Quaternion(0, 0, 0, 1));
        let k = at({
          flags: ae("uint", "GSPLAT_FLAG_ACTIVE"),
          index: o,
          center: x,
          scales: L,
          quaternion: N,
          rgba: M
        });
        return k = Q.applyGsplat(k), { gsplat: k };
      },
      {
        globals: () => [FA]
      }
    ),
    update: ({ time: o }) => {
      g.value = o, Q.update(I), I.updateVersion();
    }
  }), Q = new wt();
  return I;
}
const LC = {
  box: new B.Box3(
    new B.Vector3(-1, -1, -1),
    new B.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new B.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new B.Color(1, 1, 1),
  color2: new B.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new B.Vector3(1, 1, 1)
}, bC = {
  box: new B.Box3(
    new B.Vector3(-2, -1, -2),
    new B.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new B.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new B.Color(1, 1, 1),
  color2: new B.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new B.Vector3(0.1, 1, 0.1)
};
function vC({
  // min and max box extents of the snowBox
  box: t,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY: A,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats: e,
  // density of Gsplats per unit volume (default: 100)
  density: s,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale: i,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale: n,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale: a,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection: r,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity: g,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale: I,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance: Q,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1: o,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2: C,
  // The base opacity of the Gsplats (default: 1)
  opacity: E,
  // Optional callback function to call each frame.
  onFrame: l
}) {
  t = t ?? new B.Box3(new B.Vector3(-1, -1, -1), new B.Vector3(1, 1, 1));
  const c = (t.max.x - t.min.x) * (t.max.y - t.min.y) * (t.max.z - t.min.z);
  s = s ?? 100, e = e ?? Math.max(1, Math.min(1e6, Math.round(c * s)));
  const h = JA(n ?? 1e-3), u = JA(a ?? 5e-3), p = At(
    ((i == null ? void 0 : i.clone()) ?? new B.Vector3(1, 1, 1)).normalize()
  ), d = At(
    (r ?? new B.Vector3(0, -1, 0)).normalize()
  ), y = JA(g ?? 0.02), D = JA(I ?? 0.01), S = JA(Q ?? 2), m = At(o ?? new B.Color(1, 1, 1)), f = At(C ?? new B.Color(0.5, 0.5, 1)), w = JA(E ?? 1), R = JA(0), M = At(new B.Vector3(0, 0, 0)), x = At(t.min), L = At(t.max), N = JA(A ?? Number.NEGATIVE_INFINITY), k = Ft(L, x), U = new Kt({
    numSplats: e,
    generator: kA(
      { index: "int" },
      { gsplat: j },
      ({ index: AA }) => {
        if (!AA)
          throw new Error("index not defined");
        const z = ve(AA), sA = St(z).outputs.w;
        let tA = ct(z), P = ne(BA(sA, q("float", 100)));
        P = Ye(BA(ae("float", "PI"), P)), P = fA(h, BA(P, Ft(u, h)));
        const J = BA(P, p), Z = ne(BA(sA, q("float", 10))), V = ne(sA), X = zi(m, f, V), b = BA(X, Z), dA = ve(
          qA({
            vectorType: "ivec2",
            x: AA,
            y: q("int", 6837)
          })
        );
        let oA = ct(dA), pA = BA(St(dA).outputs.w, S);
        pA = fA(R, pA), tA = fA(tA, M);
        const yA = qi(
          tA,
          q("vec3", new B.Vector3(1, 1, 1))
        );
        tA = fA(x, BA(k, yA));
        const xA = q("vec4", new B.Quaternion(0, 0, 0, 1));
        oA = Ye(fA(ct(pA), oA)), oA = BA(oA, D);
        let cA = fA(tA, oA), LA = St(cA).outputs.y;
        LA = Ki(N, LA), cA = qA({ vector: cA, y: LA });
        let SA = at({
          flags: ae("uint", "GSPLAT_FLAG_ACTIVE"),
          index: AA,
          center: cA,
          scales: J,
          quaternion: xA,
          rgb: b,
          opacity: w
        });
        return SA = v.applyGsplat(SA), { gsplat: SA };
      },
      {
        globals: () => [FA]
      }
    ),
    update: ({ object: AA, time: z, deltaTime: sA }) => {
      R.value = z, v.update(U);
      const tA = d.value.clone().multiplyScalar(y.value * sA);
      M.value.add(tA), AA.visible = w.value > 0, l == null || l({ object: AA, time: z, deltaTime: sA }), U.updateVersion();
    }
  }), v = new wt();
  return {
    snow: U,
    min: x,
    max: L,
    minY: N,
    color1: m,
    color2: f,
    opacity: w,
    fallVelocity: y,
    wanderVariance: S,
    wanderScale: D,
    fallDirection: d,
    minScale: h,
    maxScale: u,
    anisoScale: p
  };
}
const yE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN: bC,
  DEFAULT_SNOW: LC,
  snowBox: vC,
  staticBox: UC
}, Symbol.toStringTag, { value: "Module" }));
function Vr(t) {
  return kA({ gsplat: j }, { gsplat: j }, ({ gsplat: A }) => {
    if (!A)
      throw new Error("No gsplat input");
    let e = Re(A);
    const s = t.applyGsplat(A), i = Bt(s).outputs.center, n = Re(s), a = ya(i, n), r = Dn(a, q("float", 0));
    e = $e(r, je(e), e);
    const g = fA(
      BA(e, q("float", 0.5)),
      q("float", 0.5)
    );
    return A = at({ gsplat: A, rgb: g }), { gsplat: A };
  });
}
function YC(t) {
  t.enableWorldToView = !0, t.worldModifier = Vr(t.context.worldToView), t.updateGenerator();
}
function Pr(t, A, e, s) {
  return kA({ gsplat: j }, { gsplat: j }, ({ gsplat: i }) => {
    if (!i)
      throw new Error("No gsplat input");
    let { center: n } = Bt(i).outputs;
    n = t.apply(n);
    const { z: a } = St(n).outputs;
    let r = Va(je(a), A, e);
    return r = $e(s, Ft(q("float", 1), r), r), i = at({ gsplat: i, r, g: r, b: r }), { gsplat: i };
  });
}
function JC(t, A, e, s) {
  t.enableWorldToView = !0;
  const i = q("float", A), n = q("float", e), a = q("bool", s ?? !1);
  return t.worldModifier = Pr(
    t.context.worldToView,
    i,
    n,
    a
  ), t.updateGenerator(), {
    minDepth: i,
    maxDepth: n,
    reverse: a
  };
}
const wE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  makeDepthColorModifier: Pr,
  makeNormalColorModifier: Vr,
  setDepthColor: JC,
  setWorldNormalColor: YC
}, Symbol.toStringTag, { value: "Module" })), Tt = class Tt {
  static createButton(A, e = {}) {
    const s = navigator.xr;
    if (!s)
      return null;
    const i = s, n = document.createElement("button");
    A.xr.enabled = !0, A.xr.setReferenceSpaceType("local");
    function a() {
      let o = null;
      async function C(c) {
        console.log("onSessionStarted"), c.addEventListener("end", E), await A.xr.setSession(c), n.textContent = "EXIT VR", o = c;
      }
      function E() {
        console.log("onSessionEnded"), o == null || o.removeEventListener("end", E), n.textContent = "ENTER VR", o = null;
      }
      n.style.display = "", n.style.cursor = "pointer", n.style.left = "calc(50% - 100px)", n.style.width = "200px", n.style.height = "100px", n.textContent = "ENTER VR";
      const l = {
        ...e,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...e.optionalFeatures || []
        ]
      };
      n.onmouseenter = () => {
        n.style.opacity = "1.0";
      }, n.onmouseleave = () => {
        n.style.opacity = "0.5";
      }, n.onclick = () => {
        o === null ? (console.log("requesting session"), i.requestSession("immersive-vr", l).then(
          C
        )) : (console.log("ending session"), o.end());
      };
    }
    function r() {
      n.style.display = "none", n.style.cursor = "auto", n.style.left = "calc(50% - 75px)", n.style.width = "150px", n.onmouseenter = null, n.onmouseleave = null, n.onclick = null;
    }
    function g() {
      r(), n.textContent = "VR NOT SUPPORTED";
    }
    function I(o) {
      r(), console.warn(
        "Exception when trying to call xr.isSessionSupported",
        o
      ), n.textContent = "VR NOT ALLOWED";
    }
    function Q(o) {
      o.style.position = "absolute", o.style.bottom = "20px", o.style.padding = "12px 6px", o.style.border = "1px solid #fff", o.style.borderRadius = "4px", o.style.background = "rgba(0,0,0,0.1)", o.style.color = "#fff", o.style.font = "normal 13px sans-serif", o.style.textAlign = "center", o.style.opacity = "0.5", o.style.outline = "none", o.style.zIndex = "999";
    }
    return n.id = "VRButton", n.style.display = "none", Q(n), i.isSessionSupported("immersive-vr").then((o) => {
      o ? a() : g(), o && Tt.xrSessionIsGranted && n.click();
    }).catch(I), n;
  }
  static registerSessionGrantedListener() {
    const A = navigator.xr;
    if (!A)
      return null;
    const e = A;
    /WebXRViewer\//i.test(navigator.userAgent) || e.addEventListener("sessiongranted", () => {
      Tt.xrSessionIsGranted = !0;
    });
  }
};
Tt.xrSessionIsGranted = !1;
let Ke = Tt;
Ke.registerSessionGrantedListener();
const TC = 0.5, HC = 0.5, qC = 0;
var es = /* @__PURE__ */ ((t) => (t.w = "wrist", t.t0 = "thumb-metacarpal", t.t1 = "thumb-phalanx-proximal", t.t2 = "thumb-phalanx-distal", t.t3 = "thumb-tip", t.i0 = "index-finger-metacarpal", t.i1 = "index-finger-phalanx-proximal", t.i2 = "index-finger-phalanx-intermediate", t.i3 = "index-finger-phalanx-distal", t.i4 = "index-finger-tip", t.m0 = "middle-finger-metacarpal", t.m1 = "middle-finger-phalanx-proximal", t.m2 = "middle-finger-phalanx-intermediate", t.m3 = "middle-finger-phalanx-distal", t.m4 = "middle-finger-tip", t.r0 = "ring-finger-metacarpal", t.r1 = "ring-finger-phalanx-proximal", t.r2 = "ring-finger-phalanx-intermediate", t.r3 = "ring-finger-phalanx-distal", t.r4 = "ring-finger-tip", t.p0 = "pinky-finger-metacarpal", t.p1 = "pinky-finger-phalanx-proximal", t.p2 = "pinky-finger-phalanx-intermediate", t.p3 = "pinky-finger-phalanx-distal", t.p4 = "pinky-finger-tip", t))(es || {});
const Zr = Object.keys(es), DE = Zr.length, fE = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
}, ee = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
}, KC = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
], zC = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
], mE = ["t3", "i4", "m4", "r4", "p4"], xE = ["i4", "m4", "r4", "p4"];
var Xr = /* @__PURE__ */ ((t) => (t.left = "left", t.right = "right", t))(Xr || {});
const ze = Object.keys(Xr);
class SE {
  constructor() {
    this.hands = {}, this.last = {}, this.values = {}, this.tests = {}, this.lastTests = {}, this.updated = !1;
  }
  update({ xr: A, xrFrame: e }) {
    const s = A.getSession();
    if (!s)
      return;
    const i = A.getReferenceSpace();
    if (i && e.getJointPose) {
      this.last = this.hands, this.lastTests = this.tests, this.hands = {}, this.values = {}, this.tests = {};
      for (const n of s.inputSources) {
        if (!n.hand)
          continue;
        const a = n.handedness;
        this.hands[a] = {};
        for (const r of Zr) {
          const g = n.hand.get(es[r]);
          if (g) {
            const I = e.getJointPose(g, i);
            if (I) {
              const { position: Q, orientation: o } = I.transform;
              this.hands[a][r] = {
                position: new vA(Q.x, Q.y, Q.z),
                quaternion: new ss(
                  o.x,
                  o.y,
                  o.z,
                  o.w
                ),
                radius: I.radius || 1e-3
              };
            }
          }
        }
      }
      for (const n of ze)
        for (const { key: a, value: r } of [
          { key: `${n}AllTips`, value: this.allTipsTouching(n) },
          {
            key: `${n}IndexThumb`,
            value: this.touching(n, "i4", n, "t3")
          },
          {
            key: `${n}MiddleThumb`,
            value: this.touching(n, "m4", n, "t3")
          },
          {
            key: `${n}RingThumb`,
            value: this.touching(n, "r4", n, "t3")
          },
          {
            key: `${n}PinkyThumb`,
            value: this.touching(n, "p4", n, "t3")
          },
          { key: `${n}TriTips`, value: this.triTipsTouching(n) }
        ])
          this.values[a] = r, this.tests[a] = r === 1 ? !0 : r === 0 ? !1 : this.lastTests[a] ?? !1;
    }
  }
  makeGhostMesh() {
    const A = new vA(), e = new vA(0.01, 0.01, 0.01), s = new ss(0, 0, 0, 1), i = new is(1, 1, 1), n = Math.PI * 3;
    new is(1, 1, 1);
    let a = 1;
    const r = new ZA({
      onFrame: () => {
        let g = 0;
        for (const I of ze) {
          const Q = this.hands[I];
          for (const [o, C] of KC.entries())
            for (let E = 1; E < C.length; ++E) {
              const l = zC[o][E - 1] * 2, c = E + 1 === C.length, h = Q == null ? void 0 : Q[C[E - 1]], u = Q == null ? void 0 : Q[C[E]];
              for (let p = 0; p < l; ++p) {
                const d = (p + 0.5) / l;
                if (a = 0, h && u) {
                  A.copy(h.position).lerp(u.position, d), s.copy(h.quaternion).slerp(u.quaternion, d);
                  const y = ee[C[E - 1]], D = ee[C[E]];
                  let S = (1 - d) * y + d * D;
                  c && d > 0.8 && (S *= Math.sqrt(1 - ((d - 0.8) / 0.2) ** 2)), e.set(0.65 * S, 0.5 * S, 3e-3), i.set(
                    0.55 + 0.45 * Math.sin(A.x * n),
                    0.55 + 0.45 * Math.sin(A.y * n),
                    0.55 + 0.45 * Math.sin(A.z * n)
                  ), I === "right" && i.set(1 - i.r, 1 - i.g, 1 - i.b), a = 0.75;
                }
                r.packedSplats.setSplat(
                  g,
                  A,
                  e,
                  s,
                  a,
                  i
                ), g += 1;
              }
            }
        }
        r.packedSplats.numSplats = g, r.packedSplats.needsUpdate = !0, r.numSplats = g, r.updateVersion();
      }
    });
    return r;
  }
  distance(A, e, s, i, n = !1) {
    const a = n ? this.last[A] : this.hands[A], r = n ? this.last[s] : this.hands[s], g = a == null ? void 0 : a[e], I = r == null ? void 0 : r[i];
    return !g || !I ? Number.POSITIVE_INFINITY : g.position.distanceTo(I.position);
  }
  separation(A, e, s, i, n = !1) {
    const a = this.distance(A, e, s, i, n);
    return a === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : a - ee[e] - ee[i];
  }
  touching(A, e, s, i, n = !1) {
    const a = this.separation(A, e, s, i, n);
    return a === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : 1 - Math.max(0, Math.min(1, a / 0.01 - qC));
  }
  allTipsTouching(A, e = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", e),
      this.touching(A, "i4", A, "m4", e),
      this.touching(A, "m4", A, "r4", e),
      this.touching(A, "r4", A, "p4", e)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(A, e = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", e),
      this.touching(A, "i4", A, "m4", e),
      this.touching(A, "m4", A, "t3", e)
    );
  }
}
class ME {
  constructor({
    xrHands: A,
    control: e,
    moveInertia: s,
    rotateInertia: i
  }) {
    this.lastGrip = {}, this.lastPivot = new vA(), this.rotateVelocity = 0, this.velocity = new vA(), this.xrHands = A, this.control = e, this.moveInertia = s ?? TC, this.rotateInertia = i ?? HC;
  }
  update(A) {
    var n, a, r, g, I;
    const e = {};
    for (const Q of ze) {
      const o = this.xrHands.hands[Q];
      o && this.xrHands.tests[`${Q}MiddleThumb`] && (e[Q] = new vA().add(((n = o.t3) == null ? void 0 : n.position) ?? new vA()).add(((a = o.i4) == null ? void 0 : a.position) ?? new vA()).add(((r = o.m4) == null ? void 0 : r.position) ?? new vA()).add(((g = o.r4) == null ? void 0 : g.position) ?? new vA()).add(((I = o.p4) == null ? void 0 : I.position) ?? new vA()).multiplyScalar(1 / 5));
    }
    if (e.left && e.right && this.lastGrip.left && this.lastGrip.right) {
      const Q = e.left.clone().add(e.right).multiplyScalar(0.5), o = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = Q;
      const C = Q.clone().applyMatrix4(this.control.matrix);
      C.sub(o.clone().applyMatrix4(this.control.matrix)), C.multiplyScalar(1 / A), this.velocity.lerp(C, 1 - Math.exp(-20 * A));
      const E = Math.atan2(e.left.z - Q.z, e.left.x - Q.x), l = Math.atan2(
        this.lastGrip.left.z - o.z,
        this.lastGrip.left.x - o.x
      );
      let c = E - l;
      c > Math.PI ? c -= Math.PI * 2 : c < -Math.PI && (c += Math.PI * 2);
      const h = c / A, u = Math.exp(-20 * A);
      this.rotateVelocity = this.rotateVelocity * u + h * (1 - u);
    } else if (this.rotateVelocity *= Math.exp(-A / this.rotateInertia), e.left && this.lastGrip.left) {
      const Q = e.left.clone().applyMatrix4(this.control.matrix);
      Q.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)), Q.multiplyScalar(1 / A), this.velocity.lerp(Q, 1 - Math.exp(-20 * A));
    } else if (e.right && this.lastGrip.right) {
      const Q = e.right.clone().applyMatrix4(this.control.matrix);
      Q.sub(
        this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
      ), Q.multiplyScalar(1 / A), this.velocity.lerp(Q, 1 - Math.exp(-20 * A));
    } else
      this.velocity.multiplyScalar(Math.exp(-A / this.moveInertia));
    const s = this.lastPivot.clone().negate(), i = new fe().makeTranslation(s).premultiply(new fe().makeRotationY(this.rotateVelocity * A)).premultiply(new fe().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(i), this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    ), this.control.updateMatrixWorld(!0), this.control.position.sub(this.velocity.clone().multiplyScalar(A)), this.lastGrip = e;
  }
}
const _C = 1, OC = 2, VC = 2e-3, PC = 6e-3, ZC = 15e-4, XC = 0.15, WC = 0.15, jC = 0.1, $C = 2, AE = 1, tE = 200, eE = 400, sE = 50, iE = {
  KeyW: new B.Vector3(0, 0, -1),
  KeyS: new B.Vector3(0, 0, 1),
  KeyA: new B.Vector3(-1, 0, 0),
  KeyD: new B.Vector3(1, 0, 0),
  KeyR: new B.Vector3(0, 1, 0),
  KeyF: new B.Vector3(0, -1, 0)
}, nE = {
  ArrowUp: new B.Vector3(0, 0, -1),
  ArrowDown: new B.Vector3(0, 0, 1),
  ArrowLeft: new B.Vector3(-1, 0, 0),
  ArrowRight: new B.Vector3(1, 0, 0),
  PageUp: new B.Vector3(0, 1, 0),
  PageDown: new B.Vector3(0, -1, 0)
}, aE = {
  KeyQ: new B.Vector3(0, 0, 1),
  KeyE: new B.Vector3(0, 0, -1)
}, rE = {
  Home: new B.Vector3(0, -1, 0),
  End: new B.Vector3(0, 1, 0),
  Insert: new B.Vector3(-1, 0, 0),
  Delete: new B.Vector3(1, 0, 0)
};
class FE {
  constructor({ canvas: A }) {
    this.lastTime = 0, this.fpsMovement = new gE({}), this.pointerControls = new oE({ canvas: A });
  }
  update(A) {
    const e = performance.now(), s = (e - (this.lastTime || e)) / 1e3;
    this.lastTime = e, this.fpsMovement.update(s, A), this.pointerControls.update(s, A);
  }
}
class gE {
  constructor({
    moveSpeed: A,
    rollSpeed: e,
    stickThreshold: s,
    rotateSpeed: i,
    keycodeMoveMapping: n,
    keycodeRotateMapping: a,
    gamepadMapping: r,
    capsMultiplier: g,
    shiftMultiplier: I,
    ctrlMultiplier: Q,
    xr: o
  } = {}) {
    this.enable = !0, this.moveSpeed = A ?? _C, this.rollSpeed = e ?? OC, this.stickThreshold = s ?? jC, this.rotateSpeed = i ?? $C, this.keycodeMoveMapping = n ?? {
      ...iE,
      ...nE
    }, this.keycodeRotateMapping = a ?? {
      ...aE,
      ...rE
    }, this.gamepadMapping = r ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    }, this.capsMultiplier = g ?? 10, this.shiftMultiplier = I ?? 5, this.ctrlMultiplier = Q ?? 1 / 5, this.xr = o, this.keydown = {}, this.keycode = {}, document.addEventListener("keydown", (C) => {
      this.keydown[C.key] = !0, this.keycode[C.code] = !0;
    }), document.addEventListener("keyup", (C) => {
      this.keydown[C.key] = !1, this.keycode[C.code] = !1;
    }), window.addEventListener("blur", () => {
      this.keydown = {}, this.keycode = {};
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(A, e) {
    var Q, o;
    if (!this.enable)
      return;
    const s = [new B.Vector2(), new B.Vector2()], i = navigator.getGamepads()[0];
    i && (s[0].set(i.axes[0], i.axes[1]), s[1].set(i.axes[2], i.axes[3]));
    const n = (i == null ? void 0 : i.buttons.map((C) => C.pressed)) || [], a = Array.from(((o = (Q = this.xr) == null ? void 0 : Q.getSession()) == null ? void 0 : o.inputSources) ?? []);
    for (const C of a) {
      const E = C.gamepad;
      if (E)
        switch (C.handedness) {
          case "none": {
            s[0].x += E.axes[0], s[0].y += E.axes[1], s[1].x += E.axes[2], s[1].y += E.axes[3];
            break;
          }
          case "left": {
            s[0].x += E.axes[2], s[0].y += E.axes[3];
            break;
          }
          case "right": {
            s[1].x += E.axes[2], s[1].y += E.axes[3];
            break;
          }
        }
    }
    for (const C of s)
      C.x = Math.abs(C.x) >= this.stickThreshold ? C.x : 0, C.y = Math.abs(C.y) >= this.stickThreshold ? C.y : 0;
    const r = new B.Vector3(
      s[1].x,
      s[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [C, E] of Object.entries(this.keycodeRotateMapping))
      this.keycode[C] && r.add(E);
    for (const C in this.gamepadMapping)
      if (n[Number.parseInt(C)])
        switch (this.gamepadMapping[C]) {
          case "rollLeft":
            r.z += 1;
            break;
          case "rollRight":
            r.z -= 1;
            break;
        }
    if (r.multiply(
      new B.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    ), r.manhattanLength() > 0) {
      r.multiplyScalar(A);
      const C = new B.Euler().setFromQuaternion(
        e.quaternion,
        "YXZ"
      );
      C.y -= r.x, C.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, C.x - r.y)
      ), C.z = Math.max(-Math.PI, Math.min(Math.PI, C.z + r.z)), e.quaternion.setFromEuler(C);
    }
    const g = new B.Vector3(s[0].x, 0, s[0].y);
    for (const [C, E] of Object.entries(this.keycodeMoveMapping))
      this.keycode[C] && g.add(E);
    let I = 1;
    this.keydown.CapsLock && (I *= this.capsMultiplier), (this.keycode.ShiftLeft || this.keycode.ShiftRight) && (I *= this.shiftMultiplier), (this.keycode.ControlLeft || this.keycode.ControlRight) && (I *= this.ctrlMultiplier);
    for (const C in this.gamepadMapping)
      if (n[Number.parseInt(C)])
        switch (this.gamepadMapping[C]) {
          case "shift":
            I *= this.shiftMultiplier;
            break;
          case "ctrl":
            I *= this.ctrlMultiplier;
            break;
        }
    g.applyQuaternion(e.quaternion), e.position.add(
      g.multiplyScalar(this.moveSpeed * I * A)
    );
  }
}
class oE {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas: A,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed: e,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed: s,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed: i,
    // Swap the direction of rotation and sliding (default: false)
    swapRotateSlide: n,
    // Reverse the direction of rotation (default: false)
    reverseRotate: a,
    // Reverse the direction of sliding (default: false)
    reverseSlide: r,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe: g,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll: I,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia: Q,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia: o,
    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)
    pointerRollScale: C,
    // Callback for double press events (default: () => {})
    doublePress: E
  }) {
    this.enable = !0, this.canvas = A, this.rotateSpeed = e ?? VC, this.slideSpeed = s ?? PC, this.scrollSpeed = i ?? ZC, this.swapRotateSlide = n ?? !1, this.reverseRotate = a ?? !1, this.reverseSlide = r ?? !1, this.reverseSwipe = g ?? !1, this.reverseScroll = I ?? !1, this.moveInertia = Q ?? WC, this.rotateInertia = o ?? XC, this.pointerRollScale = C ?? AE, this.doublePress = E ?? (() => {
    }), this.doublePressLimitMs = eE, this.doublePressDistance = sE, this.lastUp = null, this.rotating = null, this.sliding = null, this.dualPress = !1, this.scroll = new B.Vector3(), this.rotateVelocity = new B.Vector3(), this.moveVelocity = new B.Vector3(), A.addEventListener("pointerdown", (c) => {
      const h = this.getPointerPosition(c), u = h.clone(), p = h.clone(), d = !this.swapRotateSlide && !this.rotating && (c.pointerType !== "mouse" || c.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (c.pointerType !== "mouse" || c.button === 1), { pointerId: y, timeStamp: D } = c;
      if (d)
        this.rotating = { initial: u, last: p, position: h, pointerId: y, timeStamp: D }, A.setPointerCapture(c.pointerId), this.dualPress = !1;
      else if (!this.sliding) {
        const S = c.pointerType === "mouse" ? c.button : void 0;
        this.sliding = {
          initial: u,
          last: p,
          position: h,
          pointerId: y,
          button: S,
          timeStamp: D
        }, A.setPointerCapture(c.pointerId), this.dualPress = this.rotating != null && D - this.rotating.timeStamp < tE;
      }
    });
    const l = (c) => {
      var p, d;
      ((p = this.rotating) == null ? void 0 : p.pointerId) === c.pointerId ? (this.rotating = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.sliding && (A.releasePointerCapture(this.sliding.pointerId), this.sliding = null)) : ((d = this.sliding) == null ? void 0 : d.pointerId) === c.pointerId && (this.sliding = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.rotating && (A.releasePointerCapture(this.rotating.pointerId), this.rotating = null));
      const h = this.getPointerPosition(c), u = this.lastUp;
      if (this.lastUp = { position: h, time: c.timeStamp }, u && u.position.distanceTo(h) < this.doublePressDistance) {
        const D = c.timeStamp - u.time;
        D < this.doublePressLimitMs && (this.lastUp = null, this.doublePress({ position: h, intervalMs: D }));
      }
    };
    document.addEventListener("pointerup", l), document.addEventListener("pointercancel", l), document.addEventListener("pointermove", (c) => {
      var h, u;
      ((h = this.rotating) == null ? void 0 : h.pointerId) === c.pointerId ? this.rotating.position = this.getPointerPosition(c) : ((u = this.sliding) == null ? void 0 : u.pointerId) === c.pointerId && (this.sliding.position = this.getPointerPosition(c));
    }), A.addEventListener("contextmenu", (c) => {
      c.preventDefault();
    }), A.addEventListener("wheel", (c) => {
      this.scroll.add(
        new B.Vector3(c.deltaX, c.deltaY, c.deltaZ)
      ), c.preventDefault();
    });
  }
  getPointerPosition(A) {
    const e = this.canvas.getBoundingClientRect();
    return new B.Vector2(
      A.clientX - e.left,
      A.clientY - e.top
    );
  }
  update(A, e) {
    if (!this.enable)
      return;
    if (this.dualPress && this.rotating && this.sliding) {
      const i = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ], n = i[0].dot(i[1]);
      if (n >= 0.2) {
        const a = i[0].clone().add(i[1]), r = new B.Vector3(a.x, -a.y, 0);
        r.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1)), r.applyQuaternion(e.quaternion), e.position.add(r), this.moveVelocity = r.clone().multiplyScalar(1 / A);
      } else if (n <= -0.2) {
        const a = this.sliding.last.clone().sub(this.rotating.last), r = a.length();
        a.multiplyScalar(1 / r).normalize();
        const g = new B.Vector2(-a.y, a.x), I = [i[0].dot(a), i[1].dot(a)], Q = [i[0].dot(g), i[1].dot(g)], o = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let C = new B.Vector3();
        if (e instanceof B.Camera) {
          const p = new B.Vector2(
            o.x / this.canvas.clientWidth * 2 - 1,
            -(o.y / this.canvas.clientHeight) * 2 + 1
          ), d = new B.Raycaster();
          d.setFromCamera(p, e), C = d.ray.direction;
        }
        const E = I[1] - I[0], l = C.multiplyScalar(E * this.slideSpeed);
        e.position.add(l), this.moveVelocity = l.clone().multiplyScalar(1 / A);
        const c = [
          Math.atan(Q[0] / (-0.5 * r)),
          Math.atan(Q[1] / (0.5 * r))
        ], h = 0.5 * (c[0] + c[1]) * this.pointerRollScale, u = new B.Euler().setFromQuaternion(
          e.quaternion,
          "YXZ"
        );
        u.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, u.z + 0.5 * h)
        ), e.quaternion.setFromEuler(u);
      }
      this.rotating.last.copy(this.rotating.position), this.sliding.last.copy(this.sliding.position);
    } else {
      const i = new B.Vector3();
      if (this.rotating && !this.dualPress) {
        const a = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position), i.set(a.x, a.y, 0), i.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1)), this.rotateVelocity = i.clone().multiplyScalar(1 / A);
      } else
        this.rotateVelocity.multiplyScalar(
          Math.exp(-A / this.rotateInertia)
        ), i.addScaledVector(this.rotateVelocity, A);
      const n = new B.Euler().setFromQuaternion(
        e.quaternion,
        "YXZ"
      );
      if (n.y -= i.x, n.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, n.x - i.y)
      ), n.z *= Math.exp(-0 * A), e.quaternion.setFromEuler(n), this.sliding && !this.dualPress) {
        const a = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const r = this.sliding.button !== 2 ? new B.Vector3(a.x, 0, a.y) : new B.Vector3(a.x, -a.y, 0);
        r.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1)), r.applyQuaternion(e.quaternion), e.position.add(r), this.moveVelocity = r.clone().multiplyScalar(1 / A);
      } else
        this.moveVelocity.multiplyScalar(
          Math.exp(-A / this.moveInertia)
        ), e.position.addScaledVector(this.moveVelocity, A);
    }
    const s = this.scroll.multiplyScalar(this.scrollSpeed);
    s.set(s.x, s.z, s.y), this.reverseScroll && s.multiplyScalar(-1), s.applyQuaternion(e.quaternion), e.position.add(s), this.scroll.set(0, 0, 0);
  }
}
export {
  xE as FINGER_TIPS,
  gE as FpsMovement,
  ze as HANDS,
  Xr as Hand,
  ME as HandMovement,
  Zr as JOINT_IDS,
  fE as JOINT_INDEX,
  ee as JOINT_RADIUS,
  KC as JOINT_SEGMENTS,
  zC as JOINT_SEGMENT_STEPS,
  mE as JOINT_TIPS,
  es as JointEnum,
  DE as NUM_JOINTS,
  KA as PackedSplats,
  Qe as PlyReader,
  oE as PointerControls,
  oe as Readback,
  Lo as Sint8ToFloat,
  FE as SparkControls,
  Ee as SparkRenderer,
  Ce as SparkViewpoint,
  Fe as SplatAccumulator,
  Ie as SplatEdit,
  OB as SplatEditRgbaBlendMode,
  PB as SplatEditSdf,
  zB as SplatEditSdfType,
  ZB as SplatEdits,
  vt as SplatFileType,
  Kt as SplatGenerator,
  IC as SplatLoader,
  ZA as SplatMesh,
  WB as SplatModifier,
  cE as SplatSkinning,
  wt as SplatTransformer,
  MC as SpzReader,
  tt as SpzWriter,
  Uo as Uint8ToFloat,
  Ke as VRButton,
  SE as XrHands,
  lE as constructAxes,
  hE as constructGrid,
  uE as constructSpherePoints,
  BE as dyno,
  tI as flipPixels,
  se as floatToSint8,
  NA as floatToUint8,
  DA as fromHalf,
  yE as generators,
  Yr as getSplatFileType,
  pE as imageSplats,
  $o as isAndroid,
  jo as isMobile,
  AI as isOculus,
  CE as isPcSogs,
  wE as modifiers,
  eI as pixelsToPngUrl,
  Ue as setPackedSplat,
  dE as textSplats,
  Et as toHalf,
  EE as transcodeSpz,
  Le as unpackSplat,
  Tr as unpackSplats,
  QE as utils
};
//# sourceMappingURL=spark.module.min.js.map
